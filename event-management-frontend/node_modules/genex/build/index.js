"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const ret_1 = __importDefault(require("ret"));
const difference_1 = require("./helpers/difference");
const distinct_1 = require("./helpers/distinct");
const intersection_1 = require("./helpers/intersection");
const Literal_1 = require("./iterators/Literal");
const Option_1 = require("./iterators/Option");
const Reference_1 = require("./iterators/Reference");
const Repetition_1 = require("./iterators/Repetition");
const Stack_1 = require("./iterators/Stack");
class Genex {
    constructor(regex, charset) {
        this.tokens = null;
        if (regex instanceof RegExp) {
            regex = regex.source;
        }
        if (/[(][?]</.test(regex) === true) {
            throw new Error(`Unsupported lookbehind assertion.`);
        }
        if (charset == null) {
            charset = ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';
        }
        this.tokens = ret_1.default(regex);
        this.charset = charset.split('').map((value) => value.charCodeAt(0));
    }
    count() {
        let groups = 0;
        const counter = (tokens) => {
            let result = 0;
            if (tokens.type === ret_1.default.types.ROOT || tokens.type === ret_1.default.types.GROUP) {
                if (tokens.hasOwnProperty('options') !== true) {
                    tokens.options = [tokens.stack];
                }
                tokens.options = distinct_1.distinct(tokens.options.map((stack) => {
                    return stack.filter((value) => value.hasOwnProperty('notFollowedBy') !== true);
                }));
                for (let stack of tokens.options) {
                    let value = 1;
                    for (let node of stack) {
                        value *= counter(node);
                    }
                    result += value;
                }
                if (tokens.type === ret_1.default.types.GROUP && tokens.remember === true) {
                    ++groups;
                }
            }
            else if (tokens.type === ret_1.default.types.POSITION) {
                if (['B', '^', '$'].includes(tokens.value) === true) {
                    result = 1;
                }
            }
            else if (tokens.type === ret_1.default.types.SET) {
                let set = [];
                for (let stack of tokens.set) {
                    if (stack.type === ret_1.default.types.SET) {
                        let data = [];
                        for (let node of stack.set) {
                            if (node.type === ret_1.default.types.RANGE) {
                                for (let i = node.from; i <= node.to; ++i) {
                                    data.push(i);
                                }
                            }
                            else if (node.type === ret_1.default.types.CHAR) {
                                data.push(node.value);
                            }
                        }
                        set = set.concat(stack.not ? difference_1.difference(this.charset, data) : intersection_1.intersection(this.charset, data));
                    }
                    else if (stack.type === ret_1.default.types.RANGE) {
                        for (let i = stack.from; i <= stack.to; ++i) {
                            set.push(i);
                        }
                    }
                    else if (stack.type === ret_1.default.types.CHAR) {
                        set.push(stack.value);
                    }
                }
                result = (tokens.not === true ? difference_1.difference(this.charset, set) : intersection_1.intersection(this.charset, set)).length;
            }
            else if (tokens.type === ret_1.default.types.REPETITION) {
                if (tokens.type === ret_1.default.types.REPETITION && tokens.min === 0 && tokens.max === 1) {
                    if (tokens.value.type === ret_1.default.types.REPETITION) {
                        tokens = tokens.value;
                    }
                }
                let count = counter(tokens.value);
                if (tokens.max === null) {
                    return Infinity;
                }
                if (count === 1) {
                    return tokens.max - tokens.min + 1;
                }
                result = (Math.pow(count, tokens.max + 1) - 1) / (count - 1);
                if (tokens.min > 0) {
                    result -= (Math.pow(count, tokens.min + 0) - 1) / (count - 1);
                }
            }
            else if (tokens.type === ret_1.default.types.REFERENCE) {
                if (tokens.value > groups) {
                    throw new Error(`Reference to non-existent capture group.`);
                }
                return 1;
            }
            else if (tokens.type === ret_1.default.types.CHAR) {
                return 1;
            }
            return isFinite(result) === true ? result : Infinity;
        };
        return counter(this.tokens);
    }
    generate(callback) {
        let groups = [];
        const generator = (tokens) => {
            if (tokens.type === ret_1.default.types.ROOT || tokens.type === ret_1.default.types.GROUP) {
                if (tokens.hasOwnProperty('options') !== true) {
                    tokens.options = [tokens.stack];
                }
                let result = distinct_1.distinct(tokens.options.map((stack) => {
                    return stack.filter((value) => value.hasOwnProperty('notFollowedBy') !== true);
                })).map((stack) => new Stack_1.Stack(stack.map((node) => generator(node))));
                if (result.length > 1) {
                    result = [new Option_1.Option(result)];
                }
                if (tokens.type === ret_1.default.types.GROUP && tokens.remember === true) {
                    groups.push(result[0]);
                }
                return result.shift();
            }
            else if (tokens.type === ret_1.default.types.POSITION) {
                if (['B', '^', '$'].includes(tokens.value) === true) {
                    return new Literal_1.Literal(['']);
                }
            }
            else if (tokens.type === ret_1.default.types.SET) {
                let set = [];
                for (let stack of tokens.set) {
                    if (stack.type === ret_1.default.types.SET) {
                        let data = [];
                        for (let node of stack.set) {
                            if (node.type === ret_1.default.types.RANGE) {
                                for (let i = node.from; i <= node.to; ++i) {
                                    data.push(i);
                                }
                            }
                            else if (node.type === ret_1.default.types.CHAR) {
                                data.push(node.value);
                            }
                        }
                        set = set.concat(stack.not ? difference_1.difference(this.charset, data) : intersection_1.intersection(this.charset, data));
                    }
                    else if (stack.type === ret_1.default.types.RANGE) {
                        for (let i = stack.from; i <= stack.to; ++i) {
                            set.push(i);
                        }
                    }
                    else if (stack.type === ret_1.default.types.CHAR) {
                        set.push(stack.value);
                    }
                }
                set = tokens.not === true ? difference_1.difference(this.charset, set) : intersection_1.intersection(this.charset, set);
                if (set.length === 0) {
                    set = [];
                }
                return new Literal_1.Literal(set.map((value) => String.fromCharCode(value)));
            }
            else if (tokens.type === ret_1.default.types.REPETITION) {
                if (tokens.type === ret_1.default.types.REPETITION && tokens.min === 0 && tokens.max === 1) {
                    if (tokens.value.type === ret_1.default.types.REPETITION) {
                        tokens = tokens.value;
                    }
                }
                return Repetition_1.Repetition(generator(tokens.value), tokens.min, tokens.max);
            }
            else if (tokens.type === ret_1.default.types.REFERENCE) {
                if (groups.hasOwnProperty(tokens.value - 1) !== true) {
                    throw new Error(`Reference to non-existent capture group.`);
                }
                return new Reference_1.Reference(groups[tokens.value - 1]);
            }
            else if (tokens.type === ret_1.default.types.CHAR) {
                return new Literal_1.Literal([String.fromCharCode(tokens.value)]);
            }
            return new Literal_1.Literal([]);
        };
        let values = generator(this.tokens);
        if (typeof callback === 'function') {
            for (let value of values) {
                if (callback(value) === false) {
                    return null;
                }
            }
            return null;
        }
        let result = [];
        for (let value of values) {
            result.push(value);
        }
        return result;
    }
}
module.exports = (regex, charset) => {
    return new Genex(regex, charset);
};
