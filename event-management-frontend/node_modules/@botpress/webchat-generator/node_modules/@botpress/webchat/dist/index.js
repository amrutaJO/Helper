var zC = Object.defineProperty;
var ZC = (e, t, n) => t in e ? zC(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var k = (e, t, n) => (ZC(e, typeof t != "symbol" ? t + "" : t, n), n);
import * as D from "react";
import Xt, { createContext as gr, useMemo as ho, createElement as Me, useContext as Ir, useRef as Ke, useEffect as Ne, useLayoutEffect as Ls, useCallback as an, forwardRef as Ue, Children as Go, isValidElement as ds, cloneElement as Uu, Fragment as $i, useState as Ve, useDebugValue as VC, useId as HC, memo as Ao, useReducer as $b } from "react";
import * as WC from "react-dom";
import { flushSync as Db, createPortal as KC } from "react-dom";
var it = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Vi(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function vh(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var Nb = { exports: {} }, JC = Object.create, Oa = Object.defineProperty, YC = Object.defineProperties, GC = Object.getOwnPropertyDescriptor, XC = Object.getOwnPropertyDescriptors, QC = Object.getOwnPropertyNames, hl = Object.getOwnPropertySymbols, eT = Object.getPrototypeOf, bh = Object.prototype.hasOwnProperty, jb = Object.prototype.propertyIsEnumerable, wy = (e, t, n) => t in e ? Oa(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, O = (e, t) => {
  for (var n in t || (t = {}))
    bh.call(t, n) && wy(e, n, t[n]);
  if (hl)
    for (var n of hl(t))
      jb.call(t, n) && wy(e, n, t[n]);
  return e;
}, J = (e, t) => YC(e, XC(t)), C = (e, t) => Oa(e, "name", { value: t, configurable: !0 }), Mb = (e, t) => {
  var n = {};
  for (var r in e)
    bh.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && hl)
    for (var r of hl(e))
      t.indexOf(r) < 0 && jb.call(e, r) && (n[r] = e[r]);
  return n;
}, qb = (e, t) => {
  for (var n in t)
    Oa(e, n, { get: t[n], enumerable: !0 });
}, Lb = (e, t, n, r) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of QC(t))
      !bh.call(e, i) && i !== n && Oa(e, i, { get: () => t[i], enumerable: !(r = GC(t, i)) || r.enumerable });
  return e;
}, Bu = (e, t, n) => (n = e != null ? JC(eT(e)) : {}, Lb(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? Oa(n, "default", { value: e, enumerable: !0 }) : n,
  e
)), tT = (e) => Lb(Oa({}, "__esModule", { value: !0 }), e), Fb = {};
qb(Fb, {
  BRAND: () => hw,
  DIRTY: () => so,
  EMPTY_PATH: () => dw,
  ErrorBoundary: () => Qo,
  INVALID: () => Ge,
  NEVER: () => n0,
  OK: () => jn,
  ParseInputLazyPath: () => vr,
  ParseStatus: () => Vn,
  Schema: () => ot,
  UntitledDeclarationError: () => Xb,
  ZodAny: () => la,
  ZodArray: () => ua,
  ZodBigInt: () => Fs,
  ZodBoolean: () => Us,
  ZodBranded: () => Bs,
  ZodCatch: () => zu,
  ZodDate: () => Zu,
  ZodDefault: () => Vu,
  ZodDiscriminatedUnion: () => Eh,
  ZodEffects: () => pi,
  ZodEnum: () => di,
  ZodError: () => Zr,
  ZodFirstPartyTypeKind: () => wh,
  ZodFunction: () => Th,
  ZodIntersection: () => Hu,
  ZodIssueCode: () => he,
  ZodLazy: () => Wu,
  ZodLiteral: () => Zs,
  ZodMap: () => Rh,
  ZodNaN: () => Ah,
  ZodNativeEnum: () => Vs,
  ZodNever: () => Mi,
  ZodNull: () => Hs,
  ZodNullable: () => fi,
  ZodNumber: () => Ws,
  ZodObject: () => mo,
  ZodOptional: () => kr,
  ZodParsedType: () => Ce,
  ZodPipeline: () => Ku,
  ZodPromise: () => Ks,
  ZodReadonly: () => Ju,
  ZodRecord: () => Oh,
  ZodRef: () => Ih,
  ZodSchema: () => ot,
  ZodSet: () => Ph,
  ZodString: () => Tn,
  ZodSymbol: () => $h,
  ZodTemplateLiteral: () => nd,
  ZodTemplateLiteralUnsupportedCheckError: () => wl,
  ZodTemplateLiteralUnsupportedTypeError: () => _h,
  ZodTransformer: () => pi,
  ZodTuple: () => yo,
  ZodType: () => ot,
  ZodUndefined: () => Js,
  ZodUnion: () => Ys,
  ZodUnknown: () => Xo,
  ZodVoid: () => Dh,
  ZuiForm: () => GT,
  addIssueToContext: () => Ee,
  agent: () => cx,
  aimodel: () => px,
  any: () => kx,
  array: () => Rx,
  bigint: () => bx,
  boolean: () => Fh,
  coerce: () => t0,
  conversation: () => ox,
  createZodEnum: () => zs,
  cuid2Regex: () => Gu,
  cuidRegex: () => Yu,
  custom: () => kh,
  datasource: () => hx,
  date: () => wx,
  datetimeRegex: () => td,
  defaultComponentDefinitions: () => XT,
  discriminatedUnion: () => Px,
  effect: () => tu,
  emailRegex: () => ed,
  enum: () => Bx,
  errorUtil: () => He,
  event: () => lx,
  fromJsonSchema: () => Qx,
  fromObject: () => e0,
  function: () => Lx,
  getErrorMap: () => sa,
  getParsedType: () => oi,
  instanceof: () => gx,
  intent: () => fx,
  intersection: () => $x,
  ipv4Regex: () => hs,
  ipv6Regex: () => ms,
  isAborted: () => xl,
  isAsync: () => ps,
  isDirty: () => _l,
  isEmojiRegex: () => Aw,
  isValid: () => ca,
  jsonSchemaToZui: () => Gs,
  knowledgebase: () => mx,
  late: () => yx,
  lazy: () => Fx,
  literal: () => Ux,
  makeIssue: () => fs,
  map: () => Mx,
  message: () => sx,
  nan: () => vx,
  nativeEnum: () => zx,
  never: () => Cx,
  null: () => Sx,
  nullable: () => Hx,
  number: () => Lh,
  object: () => Ax,
  objectToZui: () => fa,
  objectUtil: () => vl,
  oboolean: () => Xx,
  onumber: () => Gx,
  optional: () => Vx,
  ostring: () => Yx,
  pipeline: () => Kx,
  preprocess: () => Wx,
  processCreateParams: () => st,
  promise: () => Zx,
  quotelessJson: () => aw,
  record: () => Nx,
  ref: () => jx,
  set: () => qx,
  setErrorMap: () => Sh,
  strictObject: () => Ox,
  string: () => qh,
  symbol: () => xx,
  table: () => ux,
  tablerow: () => dx,
  templateLiteral: () => Jx,
  transformer: () => tu,
  transforms: () => QT,
  tuple: () => Dx,
  ulidRegex: () => Xu,
  undefined: () => _x,
  union: () => Ix,
  unknown: () => Ex,
  user: () => ax,
  util: () => _t,
  uuidRegex: () => Qu,
  variable: () => ix,
  void: () => Tx,
  withErrorBoundary: () => a0,
  z: () => En,
  zuiToJsonSchema: () => rd
});
var vc = tT(Fb), En = {};
qb(En, {
  BRAND: () => hw,
  DIRTY: () => so,
  EMPTY_PATH: () => dw,
  INVALID: () => Ge,
  NEVER: () => n0,
  OK: () => jn,
  ParseInputLazyPath: () => vr,
  ParseStatus: () => Vn,
  Schema: () => ot,
  ZodAny: () => la,
  ZodArray: () => ua,
  ZodBigInt: () => Fs,
  ZodBoolean: () => Us,
  ZodBranded: () => Bs,
  ZodCatch: () => zu,
  ZodDate: () => Zu,
  ZodDefault: () => Vu,
  ZodDiscriminatedUnion: () => Eh,
  ZodEffects: () => pi,
  ZodEnum: () => di,
  ZodError: () => Zr,
  ZodFirstPartyTypeKind: () => wh,
  ZodFunction: () => Th,
  ZodIntersection: () => Hu,
  ZodIssueCode: () => he,
  ZodLazy: () => Wu,
  ZodLiteral: () => Zs,
  ZodMap: () => Rh,
  ZodNaN: () => Ah,
  ZodNativeEnum: () => Vs,
  ZodNever: () => Mi,
  ZodNull: () => Hs,
  ZodNullable: () => fi,
  ZodNumber: () => Ws,
  ZodObject: () => mo,
  ZodOptional: () => kr,
  ZodParsedType: () => Ce,
  ZodPipeline: () => Ku,
  ZodPromise: () => Ks,
  ZodReadonly: () => Ju,
  ZodRecord: () => Oh,
  ZodRef: () => Ih,
  ZodSchema: () => ot,
  ZodSet: () => Ph,
  ZodString: () => Tn,
  ZodSymbol: () => $h,
  ZodTemplateLiteral: () => nd,
  ZodTemplateLiteralUnsupportedCheckError: () => wl,
  ZodTemplateLiteralUnsupportedTypeError: () => _h,
  ZodTransformer: () => pi,
  ZodTuple: () => yo,
  ZodType: () => ot,
  ZodUndefined: () => Js,
  ZodUnion: () => Ys,
  ZodUnknown: () => Xo,
  ZodVoid: () => Dh,
  addIssueToContext: () => Ee,
  agent: () => cx,
  aimodel: () => px,
  any: () => kx,
  array: () => Rx,
  bigint: () => bx,
  boolean: () => Fh,
  coerce: () => t0,
  conversation: () => ox,
  createZodEnum: () => zs,
  cuid2Regex: () => Gu,
  cuidRegex: () => Yu,
  custom: () => kh,
  datasource: () => hx,
  date: () => wx,
  datetimeRegex: () => td,
  discriminatedUnion: () => Px,
  effect: () => tu,
  emailRegex: () => ed,
  enum: () => Bx,
  errorUtil: () => He,
  event: () => lx,
  fromJsonSchema: () => Qx,
  fromObject: () => e0,
  function: () => Lx,
  getErrorMap: () => sa,
  getParsedType: () => oi,
  instanceof: () => gx,
  intent: () => fx,
  intersection: () => $x,
  ipv4Regex: () => hs,
  ipv6Regex: () => ms,
  isAborted: () => xl,
  isAsync: () => ps,
  isDirty: () => _l,
  isEmojiRegex: () => Aw,
  isValid: () => ca,
  jsonSchemaToZui: () => Gs,
  knowledgebase: () => mx,
  late: () => yx,
  lazy: () => Fx,
  literal: () => Ux,
  makeIssue: () => fs,
  map: () => Mx,
  message: () => sx,
  nan: () => vx,
  nativeEnum: () => zx,
  never: () => Cx,
  null: () => Sx,
  nullable: () => Hx,
  number: () => Lh,
  object: () => Ax,
  objectToZui: () => fa,
  objectUtil: () => vl,
  oboolean: () => Xx,
  onumber: () => Gx,
  optional: () => Vx,
  ostring: () => Yx,
  pipeline: () => Kx,
  preprocess: () => Wx,
  processCreateParams: () => st,
  promise: () => Zx,
  quotelessJson: () => aw,
  record: () => Nx,
  ref: () => jx,
  set: () => qx,
  setErrorMap: () => Sh,
  strictObject: () => Ox,
  string: () => qh,
  symbol: () => xx,
  table: () => ux,
  tablerow: () => dx,
  templateLiteral: () => Jx,
  transformer: () => tu,
  tuple: () => Dx,
  ulidRegex: () => Xu,
  undefined: () => _x,
  union: () => Ix,
  unknown: () => Ex,
  user: () => ax,
  util: () => _t,
  uuidRegex: () => Qu,
  variable: () => ix,
  void: () => Tx,
  zuiToJsonSchema: () => rd
});
var Et = "x-zui", xy = Xt, In = Bu(Xt, 1), Ub = (0, In.createContext)({
  formData: void 0,
  formSchema: void 0,
  setFormData: /* @__PURE__ */ C(() => {
    throw new Error("Must be within a FormDataProvider");
  }, "setFormData"),
  setHiddenState: /* @__PURE__ */ C(() => {
    throw new Error("Must be within a FormDataProvider");
  }, "setHiddenState"),
  setDisabledState: /* @__PURE__ */ C(() => {
    throw new Error("Must be within a FormDataProvider");
  }, "setDisabledState"),
  hiddenState: {},
  disabledState: {},
  validation: { formValid: null, formErrors: null }
}), _y = /* @__PURE__ */ C((e, t, n) => {
  var r;
  const i = (r = t[Et]) == null ? void 0 : r[e];
  if (typeof i > "u")
    return !1;
  if (typeof i == "boolean")
    return i;
  if (typeof i == "string") {
    if (typeof window > "u")
      return console.warn("Function evaluation is not supported in server side rendering"), !1;
    const a = new Function("return " + i)()(n);
    switch (typeof a) {
      case "object":
      case "boolean":
        return a;
      default:
        return !1;
    }
  }
  return !1;
}, "parseMaskableField"), Bb = /* @__PURE__ */ C((e, t) => {
  const n = (0, In.useContext)(Ub);
  if (n === void 0)
    throw new Error("useFormData must be used within a FormDataProvider");
  const r = (0, In.useMemo)(() => ro(n.formData, t), [n.formData, t]), i = (0, In.useMemo)(() => {
    var f;
    return n.validation.formValid === null ? { formValid: null, formErrors: null } : n.validation.formValid === !1 ? {
      formValid: !1,
      formErrors: ((f = n.validation.formErrors) == null ? void 0 : f.filter((h) => Vb(h.path, t)).map((h) => ({
        message: h.message,
        code: h.code,
        path: t
      }))) || null
    } : { formValid: !0, formErrors: [] };
  }, [n.validation.formValid, n.validation.formErrors, t]), o = n.dataTransform ? n.dataTransform(r) : r, a = (0, In.useMemo)(
    () => _y("hidden", e, o),
    [e, o]
  ), s = (0, In.useMemo)(
    () => _y("disabled", e, o),
    [e, o]
  );
  (0, In.useEffect)(() => {
    n.setHiddenState((f) => Bo(f, t, a || {})), n.setDisabledState((f) => Bo(f, t, s || {}));
  }, [JSON.stringify({ fieldSchema: e, data: r })]);
  const { disabled: c, hidden: l } = (0, In.useMemo)(() => {
    const f = a === !0 || ro(n.hiddenState, t), h = s === !0 || ro(n.disabledState, t);
    return { hidden: f === !0, disabled: h === !0 };
  }, [n.hiddenState, n.disabledState, a, s, t]), u = (0, In.useCallback)(
    (f, h) => {
      n.setFormData((m) => Bo(m, f, h));
    },
    [n.setFormData]
  ), d = (0, In.useCallback)(
    (f, h = void 0) => {
      const m = Ko(e.items);
      n.setFormData((y) => {
        const g = ro(y, f) || [];
        return h === void 0 && (h = m), Bo(y, f, Array.isArray(g) ? [...g, h] : [h]);
      });
    },
    [n.setFormData]
  ), p = (0, In.useCallback)(
    (f, h) => {
      n.setFormData((m) => {
        const y = ro(m, f) || [];
        return Array.isArray(y) ? (y.splice(h, 1), Bo(m, f, y)) : m;
      });
    },
    [n.setFormData]
  );
  return O(J(O({}, n), { data: r, disabled: c, hidden: l, handlePropertyChange: u, addArrayItem: d, removeArrayItem: p }), i);
}, "useFormData");
function Bo(e, t, n) {
  if (t.length === 0)
    return n;
  const r = t.length;
  return t.reduce((i, o, a) => (a === r - 1 ? i[o] = n : i[o] || (i[o] = isNaN(Number(o)) ? {} : []), i[o]), e ?? {}), O({}, e);
}
C(Bo, "setObjectPath");
var Ko = /* @__PURE__ */ C((e, t) => {
  var n, r, i, o;
  if (Array.isArray(e))
    return Ko(e[0]);
  if (e.default)
    return e.default;
  if (e.nullable)
    return null;
  if (!t) {
    if ((n = e.anyOf) != null && n.length)
      return Ko(e.anyOf[0]);
    if (e.type === "object" && e.properties) {
      const a = {};
      return Object.entries(e.properties).map(([s, c]) => {
        var l;
        a[s] = Ko(c, !((l = e.required) != null && l.includes(s)) || zb(c) || !1);
      }), a;
    }
    if (e.type === "array")
      return e.minItems && e.minItems > 0 ? [Ko(e.items)] : [];
    if (e.type === "string")
      return (r = e.enum) != null && r.length ? e.enum[0] : "";
    if (e.type === "number")
      return (i = e.enum) != null && i.length ? e.enum[0] : 0;
    if (e.type === "boolean")
      return (o = e.enum) != null && o.length ? e.enum[0] : !1;
  }
}, "getDefaultValues"), nT = /* @__PURE__ */ C(({
  children: e,
  setFormData: t,
  formData: n,
  formSchema: r,
  disableValidation: i,
  onValidation: o,
  dataTransform: a
}) => {
  const [s, c] = (0, In.useState)({}), [l, u] = (0, In.useState)({}), d = a ? a(n) : n, p = (0, In.useMemo)(() => {
    if (i)
      return { formValid: null, formErrors: null };
    if (!r)
      return { formValid: null, formErrors: null };
    const f = Gs(r).safeParse(d);
    return f.success ? {
      formValid: !0,
      formErrors: []
    } : {
      formValid: !1,
      formErrors: f.error.issues
    };
  }, [JSON.stringify({ transformedData: d })]);
  return (0, In.useEffect)(() => {
    o && o(p);
  }, [p]), /* @__PURE__ */ In.default.createElement(
    Ub.Provider,
    {
      value: {
        formData: n,
        setFormData: t,
        formSchema: r,
        validation: p,
        hiddenState: s,
        setHiddenState: c,
        disabledState: l,
        setDisabledState: u,
        dataTransform: a
      }
    },
    e
  );
}, "FormDataProvider");
function ro(e, t) {
  return t.reduce((n, r) => n ? n[r] : null, e);
}
C(ro, "getPathData");
function zb(e) {
  var t;
  return ((t = e.anyOf) == null ? void 0 : t.some((n) => n.not && Object.keys(n.not).length === 0)) || !1;
}
C(zb, "isOptional");
function ml(e, t) {
  const n = O({}, e);
  for (const r in t)
    t.hasOwnProperty(r) && (typeof t[r] == "object" && t[r] !== null && !Array.isArray(t[r]) ? typeof n[r] == "object" && n[r] !== null && !Array.isArray(n[r]) ? n[r] = ml(n[r], t[r]) : n[r] = ml({}, t[r]) : n[r] = t[r]);
  return n;
}
C(ml, "deepMerge");
var rT = /* @__PURE__ */ C((e, t) => {
  const { handlePropertyChange: n, data: r } = Bb(e, t), { discriminator: i, value: o, discriminatedSchema: a } = (0, xy.useMemo)(() => {
    const s = Zb(e.anyOf), c = s != null && s.key ? r == null ? void 0 : r[s.key] : e.default || null, l = iT((s == null ? void 0 : s.key) || null, c, e.anyOf);
    return {
      discriminator: s,
      value: c,
      discriminatedSchema: l
    };
  }, [e.anyOf, r]);
  return (0, xy.useEffect)(() => {
    i != null && i.key && (i != null && i.values.length) && Object.keys(r || {}).length < 1 && !e.default && n(t, { [i.key]: i.values[0] });
  }, []), { discriminator: i, discriminatorValue: o, discriminatedSchema: a };
}, "useDiscriminator"), Zb = /* @__PURE__ */ C((e) => {
  const t = e == null ? void 0 : e.map((n) => n.type !== "object" || !n.properties ? null : Object.entries(n.properties).map(([r, i]) => {
    var o;
    return i.type === "string" && ((o = i.enum) != null && o.length) ? { key: r, value: i.enum[0] } : null;
  }).filter((r) => !!r)).flat().reduce(
    (n, r) => {
      if (!r)
        return n;
      const { key: i, value: o } = r;
      return n.key === null && (n.key = i), n.key === i && n.values.push(o), n;
    },
    { key: null, values: [] }
  );
  return (t == null ? void 0 : t.key) === null || !(t != null && t.values.length) ? null : t;
}, "resolveDiscriminator"), iT = /* @__PURE__ */ C((e, t, n) => {
  var r, i;
  if (!(n != null && n.length) || !e || !t)
    return null;
  for (const o of n) {
    if (o.type !== "object")
      continue;
    const a = (r = o.properties) == null ? void 0 : r[e];
    if ((a == null ? void 0 : a.type) === "string" && ((i = a.enum) != null && i.length) && a.enum[0] === t)
      return J(O({}, o), {
        properties: J(O({}, o.properties), {
          [e]: J(O({}, a), { [Et]: { hidden: !0 } })
        })
      });
  }
  return null;
}, "resolveDiscriminatedSchema"), oT = /* @__PURE__ */ C((e) => {
  var t;
  return (t = e.anyOf) != null && t.length ? Zb(e.anyOf) ? "discriminatedUnion" : "object" : e.type === "integer" ? "number" : e.type;
}, "getSchemaType"), aT = /* @__PURE__ */ C((e, t) => {
  var n, r, i;
  const o = oT(t), a = ((n = t[Et]) == null ? void 0 : n.displayAs) || null;
  if (!a || !Array.isArray(a) || a.length < 2) {
    const u = (r = e == null ? void 0 : e[o]) == null ? void 0 : r.default;
    return u ? {
      Component: u,
      type: o,
      id: "default",
      params: {}
    } : null;
  }
  const s = a[0], c = ((i = e == null ? void 0 : e[o]) == null ? void 0 : i[s]) || null;
  if (!c)
    return console.warn(`Component ${o}.${s} not found`), null;
  const l = a[1] || {};
  return {
    Component: c,
    type: o,
    id: s,
    params: l
  };
}, "resolveComponent");
function Vb(e, t) {
  return e.length !== t.length ? !1 : e.every((n, r) => n === t[r]);
}
C(Vb, "pathMatches");
function op(e, t) {
  return t || (t = new RegExp("/s|-|_| ", "g")), Kb(e).split(t).map(Hb).map(Jb).reduce(Wb);
}
C(op, "formatTitle");
function Hb(e) {
  return e.charAt(0).toUpperCase() + e.substring(1);
}
C(Hb, "capitalize");
function Wb(e, t) {
  return `${e} ${t}`;
}
C(Wb, "combine");
function Kb(e) {
  return e.replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1_$2").toLowerCase();
}
C(Kb, "decamelize");
function Jb(e, t, n) {
  const r = e.toLowerCase(), i = e.toUpperCase();
  for (const o of dT)
    if (o.toLowerCase() === r)
      return o;
  return sT.includes(i) ? i : t === 0 || t === n.length - 1 || e.length >= 4 ? e : uT.includes(r) || lT.includes(r) || cT.includes(r) ? r : e;
}
C(Jb, "handleSpecialWords");
var sT = [
  "2D",
  "3D",
  "4WD",
  "A2O",
  "API",
  "BIOS",
  "CCTV",
  "CC",
  "CCV",
  "CD",
  "CD-ROM",
  "COBOL",
  "CIA",
  "CMS",
  "CSS",
  "CSV",
  "CV",
  "DIY",
  "DVD",
  "DB",
  "DNA",
  "E3",
  "EIN",
  "ESPN",
  "FAQ",
  "FAQs",
  "FTP",
  "FPS",
  "FORTRAN",
  "FBI",
  "HTML",
  "HTTP",
  "ID",
  "IP",
  "ISO",
  "JS",
  "JSON",
  "LASER",
  "M2A",
  "M2M",
  "M2MM",
  "M2O",
  "MMORPG",
  "NAFTA",
  "NASA",
  "NDA",
  "O2M",
  "PDF",
  "PHP",
  "POP",
  "RAM",
  "RNGR",
  "ROM",
  "RPG",
  "RTFM",
  "RTS",
  "SCUBA",
  "SITCOM",
  "SKU",
  "SMTP",
  "SQL",
  "SSN",
  "SWAT",
  "TBS",
  "TTL",
  "TV",
  "TNA",
  "UI",
  "URL",
  "USB",
  "UWP",
  "VIP",
  "W3C",
  "WYSIWYG",
  "WWW",
  "WWE",
  "WWF"
], cT = ["a", "an", "the"], lT = [
  "and",
  "that",
  "but",
  "or",
  "as",
  "if",
  "when",
  "than",
  "because",
  "while",
  "where",
  "after",
  "so",
  "though",
  "since",
  "until",
  "whether",
  "before",
  "although",
  "nor",
  "like",
  "once",
  "unless",
  "now",
  "except"
], uT = [
  "about",
  "above",
  "across",
  "after",
  "against",
  "along",
  "among",
  "around",
  "at",
  "because of",
  "before",
  "behind",
  "below",
  "beneath",
  "beside",
  "besides",
  "between",
  "beyond",
  "but",
  "by",
  "concerning",
  "despite",
  "down",
  "during",
  "except",
  "excepting",
  "for",
  "from",
  "in",
  "in front of",
  "inside",
  "in spite of",
  "instead of",
  "into",
  "like",
  "near",
  "of",
  "off",
  "on",
  "onto",
  "out",
  "outside",
  "over",
  "past",
  "regarding",
  "since",
  "through",
  "throughout",
  "to",
  "toward",
  "under",
  "underneath",
  "until",
  "up",
  "upon",
  "up to",
  "with",
  "within",
  "without",
  "with regard to",
  "with respect to"
], dT = [
  "2FA",
  "3D",
  "4K",
  "5K",
  "8K",
  "AGI",
  "BI",
  "ChatGPT",
  "CTA",
  "DateTime",
  "GitHub",
  "GPT",
  "HD",
  "IBMid",
  "ID",
  "IDs",
  "iMac",
  "IMAX",
  "iOS",
  "IP",
  "iPad",
  "iPhone",
  "iPod",
  "LDAP",
  "LinkedIn",
  "LLM",
  "M2M",
  "M2O",
  "macOS",
  "McDonalds",
  "ML",
  "MySQL",
  "NLG",
  "NLP",
  "NLU",
  "O2M",
  "OpenAI",
  "PDFs",
  "PEFT",
  "pH",
  "PostgreSQL",
  "SEO",
  "TTS",
  "UHD",
  "UUID",
  "XSS",
  "YouTube"
];
function yl(e) {
  if (typeof e != "string")
    return "";
  const t = String.raw`${e}`;
  return t.includes("`") ? `"${t.replace(/"/g, '\\"')}"` : t.includes("'") ? `'${t.replace(/'/g, "\\'")}'` : `'${t}'`;
}
C(yl, "escapeString");
var Sy = /* @__PURE__ */ C((e) => /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(e) ? e : yl(e), "toPropertyKey"), un = /* @__PURE__ */ C((e) => {
  const t = (e ?? "").split(`
`).filter((n) => n.trim().length > 0);
  return t.length === 0 ? "" : t.length === 1 ? `/** ${t[0]} */` : `/**
 * ${t.join(`
 * `)}
 */`;
}, "getMultilineComment"), Yb = [
  "string",
  "number",
  "boolean",
  "unknown",
  "void",
  "any",
  "null",
  "undefined",
  "never",
  "bigint",
  "symbol",
  "object"
], Gb = class extends Error {
  constructor(t) {
    super(t), this.name = "UntitledDeclarationError";
  }
  static isUntitledDeclarationError(t) {
    return t.name === "UntitledDeclarationError";
  }
};
C(Gb, "UntitledDeclarationError");
var Xb = Gb, fT = /* @__PURE__ */ C((e) => Yb.includes(e), "isPrimitive"), pT = /* @__PURE__ */ C((e) => Yb.map((t) => `${t}[]`).includes(e), "isArrayOfPrimitives"), ky = /* @__PURE__ */ C((e) => e.replace(/ +/g, " ").trim(), "stripSpaces"), Qb = class {
  constructor(t, n) {
    this.key = t, this.value = n;
  }
};
C(Qb, "KeyValue");
var bc = Qb, ew = class {
  constructor(t) {
    this.schema = t;
  }
};
C(ew, "FnParameters");
var Ey = ew, tw = class {
  constructor(t) {
    this.schema = t;
  }
};
C(tw, "FnReturn");
var Cy = tw, nw = class {
  constructor(t, n) {
    this.schema = t, this.identifier = n;
  }
};
C(nw, "Declaration");
var rw = nw;
function gl(e, t) {
  var n;
  t ?? (t = {}), (n = t.declaration) != null || (t.declaration = !1);
  let r = e;
  if (t != null && t.declaration && e instanceof Je.Schema) {
    const o = "title" in e.ui ? e.ui.title : null;
    if (!o)
      throw new Xb('Only schemas with "title" Zui property can be declared.');
    r = new rw(e, o);
  }
  let i = gt(r, O({}, t));
  return t.formatter && (i = t.formatter(i)), i;
}
C(gl, "toTypescript");
function gt(e, t) {
  var n, r, i;
  const o = J(O({}, t), {
    declaration: !1,
    parent: e
  });
  if (e === null)
    return "";
  if (e instanceof rw) {
    const c = un(e.schema.description), l = e.schema.describe(""), u = gt(l, J(O({}, o), { declaration: !0 }));
    return e.schema instanceof Je.ZodFunction ? ky(`${c}
declare function ${e.identifier}${u};`) : ky(`${c}
declare const ${e.identifier}: ${u};`);
  }
  if (e instanceof bc) {
    if (e.value instanceof Je.ZodOptional) {
      let d = e.value._def.innerType;
      return d instanceof Je.Schema && !d.description && e.value.description && (d = d == null ? void 0 : d.describe(e.value.description)), gt(new bc(e.key + "?", d), o);
    }
    const c = un(e.value._def.description), l = (c == null ? void 0 : c.trim().length) > 0 ? `
` : "", u = e.value.describe("");
    return `${l}${c}${l}${e.key}: ${gt(u, o)}${l}`;
  }
  if (e instanceof Ey) {
    if (e.schema instanceof Je.ZodTuple) {
      let u = "";
      for (let d = 0; d < e.schema.items.length; d++) {
        const p = (i = (r = (n = e.schema.items[d]) == null ? void 0 : n.ui) == null ? void 0 : r.title) != null ? i : `arg${d}`, f = e.schema.items[d];
        u += `${gt(new bc(Sy(p), f), o)}${d < e.schema.items.length - 1 ? ", " : ""} `;
      }
      return u;
    }
    const c = gt(e.schema, o);
    return c.startsWith("{") && c.endsWith("}") || c.startsWith("[") && c.endsWith("]") || c.startsWith("(") && c.endsWith(")") || c.startsWith("Array<") && c.endsWith(">") || c.startsWith("Record<") && c.endsWith(">") || pT(c) ? `args: ${c}` : c;
  }
  if (e instanceof Cy)
    return e.schema instanceof Je.ZodOptional ? `${gt(e.schema.unwrap(), o)} | undefined` : gt(e.schema, o);
  const s = e._def;
  switch (s.typeName) {
    case Je.ZodFirstPartyTypeKind.ZodString:
      return `${un(s.description)} string`.trim();
    case Je.ZodFirstPartyTypeKind.ZodNumber:
    case Je.ZodFirstPartyTypeKind.ZodNaN:
    case Je.ZodFirstPartyTypeKind.ZodBigInt:
      return `${un(s.description)} number`.trim();
    case Je.ZodFirstPartyTypeKind.ZodBoolean:
      return `${un(e._def.description)} boolean`.trim();
    case Je.ZodFirstPartyTypeKind.ZodDate:
      return `${un(s.description)} Date`.trim();
    case Je.ZodFirstPartyTypeKind.ZodUndefined:
      return `${un(s.description)} undefined`.trim();
    case Je.ZodFirstPartyTypeKind.ZodNull:
      return `${un(s.description)} null`.trim();
    case Je.ZodFirstPartyTypeKind.ZodAny:
      return `${un(s.description)} any`.trim();
    case Je.ZodFirstPartyTypeKind.ZodUnknown:
      return `${un(s.description)} unknown`.trim();
    case Je.ZodFirstPartyTypeKind.ZodNever:
      return `${un(s.description)} never`.trim();
    case Je.ZodFirstPartyTypeKind.ZodVoid:
      return `${un(s.description)} void`.trim();
    case Je.ZodFirstPartyTypeKind.ZodArray:
      const c = gt(s.type, o);
      return fT(c) ? `${c}[]` : `Array<${c}>`;
    case Je.ZodFirstPartyTypeKind.ZodObject:
      return `{ ${Object.entries(e.shape).map(([b, _]) => _ instanceof Je.Schema ? gt(new bc(Sy(b), _), o) : `${b}: unknown`).join("; ")} }`;
    case Je.ZodFirstPartyTypeKind.ZodUnion:
      const u = e.options.map((b) => gt(b, o));
      return `${un(s.description)}
${u.join(" | ")}`;
    case Je.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      const d = e.options.map((b) => gt(b, o));
      return `${un(e._def.description)}
${d.join(" | ")}`;
    case Je.ZodFirstPartyTypeKind.ZodIntersection:
      return `${gt(s.left, o)} & ${gt(s.right, o)}`;
    case Je.ZodFirstPartyTypeKind.ZodTuple:
      return s.items.length === 0 ? "" : `[${s.items.map((b) => gt(b, o)).join(", ")}]`;
    case Je.ZodFirstPartyTypeKind.ZodRecord:
      const f = gt(s.keyType, o), h = gt(s.valueType, o);
      return `${un(s.description)} { [key: ${f}]: ${h} }`;
    case Je.ZodFirstPartyTypeKind.ZodMap:
      return `Map<${gt(s.keyType, o)}, ${gt(s.valueType, o)}>`;
    case Je.ZodFirstPartyTypeKind.ZodSet:
      return `Set<${gt(s.valueType, o)}>`;
    case Je.ZodFirstPartyTypeKind.ZodFunction:
      const m = gt(new Ey(s.args), o), y = gt(new Cy(s.returns), o);
      return t != null && t.declaration ? `${un(s.description)}
(${m}): ${y}` : `${un(s.description)}
(${m}) => ${y}`;
    case Je.ZodFirstPartyTypeKind.ZodLazy:
      return gt(s.getter(), o);
    case Je.ZodFirstPartyTypeKind.ZodLiteral:
      return `${un(s.description)}
${yl(e.value)}`.trim();
    case Je.ZodFirstPartyTypeKind.ZodEnum:
      return s.values.map(yl).join(" | ");
    case Je.ZodFirstPartyTypeKind.ZodEffects:
      return gt(s.schema, o);
    case Je.ZodFirstPartyTypeKind.ZodNativeEnum:
      return gt(s.values, o);
    case Je.ZodFirstPartyTypeKind.ZodOptional:
      return t != null && t.declaration || (t == null ? void 0 : t.parent) instanceof Je.ZodRecord || (t == null ? void 0 : t.parent) instanceof Je.ZodObject ? `${gt(s.innerType, o)} | undefined` : (t == null ? void 0 : t.parent) instanceof Je.ZodDefault || (t == null ? void 0 : t.parent) instanceof Je.ZodNullable || (t == null ? void 0 : t.parent) instanceof Je.ZodOptional ? `${gt(s.innerType, o)} | undefined` : `${gt(s.innerType, o)}?`;
    case Je.ZodFirstPartyTypeKind.ZodNullable:
      return `${gt(e.unwrap(), o)} | null`;
    case Je.ZodFirstPartyTypeKind.ZodDefault:
      return gt(s.innerType, o);
    case Je.ZodFirstPartyTypeKind.ZodCatch:
      return gt(e.removeCatch(), o);
    case Je.ZodFirstPartyTypeKind.ZodPromise:
      return `Promise<${gt(e.unwrap(), o)}>`;
    case Je.ZodFirstPartyTypeKind.ZodBranded:
      return gt(s.type, o);
    case Je.ZodFirstPartyTypeKind.ZodPipeline:
      return gt(s.in, o);
    case Je.ZodFirstPartyTypeKind.ZodSymbol:
      return `${un(s.description)} symbol`.trim();
    case Je.ZodFirstPartyTypeKind.ZodReadonly:
      return `readonly ${gt(s.innerType, o)}`;
    case Je.ZodFirstPartyTypeKind.ZodRef:
      throw new Error("ZodRef cannot be transformed to TypeScript yet");
    case Je.ZodFirstPartyTypeKind.ZodTemplateLiteral:
      return `\`${s.parts.map((b) => typeof b > "u" || b === null ? "" : typeof b == "string" ? b : typeof b == "boolean" || typeof b == "number" ? `${b}` : "${" + gt(b, J(O({}, o), { declaration: !1 })) + "}").join("")}\``;
    default:
      _t.assertNever(s);
  }
}
C(gt, "sUnwrapZod");
var iw = class {
  constructor(t, n, r, i) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
C(iw, "ParseInputLazyPath");
var vr = iw, Ty = /* @__PURE__ */ C((e, t) => {
  if (ca(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new Zr(e.common.issues);
      return this._error = n, this._error;
    }
  };
}, "handleResult"), ow = class {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  /** deeply replace all references in the schema */
  dereference(t) {
    return this;
  }
  /** deeply scans the schema to check if it contains references */
  getReferences() {
    return [];
  }
  _getType(t) {
    return oi(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: oi(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Vn(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: oi(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (ps(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const i = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) != null ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: oi(t)
    }, o = this._parseSync({ data: t, path: i.path, parent: i });
    return Ty(i, o);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: oi(t)
    }, i = this._parse({ data: t, path: r.path, parent: r }), o = await (ps(i) ? i : Promise.resolve(i));
    return Ty(r, o);
  }
  refine(t, n) {
    const r = /* @__PURE__ */ C((i) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(i) : n, "getIssueProperties");
    return this._refinement((i, o) => {
      const a = t(i), s = /* @__PURE__ */ C(() => o.addIssue(O({
        code: he.custom
      }, r(i))), "setError");
      return typeof Promise < "u" && a instanceof Promise ? a.then((c) => c ? !0 : (s(), !1)) : a ? !0 : (s(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, i) => t(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1));
  }
  _refinement(t) {
    return new pi({
      schema: this,
      typeName: "ZodEffects",
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return kr.create(this, this._def);
  }
  nullable() {
    return fi.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ua.create(this, this._def);
  }
  promise() {
    return Ks.create(this, this._def);
  }
  or(t) {
    return Ys.create([this, t], this._def);
  }
  and(t) {
    return Hu.create(this, t, this._def);
  }
  transform(t) {
    return new pi(J(O({}, st(this._def)), {
      schema: this,
      typeName: "ZodEffects",
      effect: { type: "transform", transform: t }
    }));
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Vu(J(O({}, st(this._def)), {
      innerType: this,
      defaultValue: n,
      typeName: "ZodDefault"
      /* ZodDefault */
    }));
  }
  brand() {
    return new Bs(O({
      typeName: "ZodBranded",
      type: this
    }, st(this._def)));
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new zu(J(O({}, st(this._def)), {
      innerType: this,
      catchValue: n,
      typeName: "ZodCatch"
      /* ZodCatch */
    }));
  }
  describe(t) {
    const n = this.constructor;
    return new n(J(O({}, this._def), {
      description: t
    }));
  }
  pipe(t) {
    return Ku.create(this, t);
  }
  readonly() {
    return Ju.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
  // BOTPRESS EXTENSIONS
  _setZuiMeta(t, n) {
    const r = this._def, i = typeof n == "function" ? n.toString() : n;
    switch (r.typeName) {
      case "ZodNullable":
      case "ZodDefault":
      case "ZodOptional":
      case "ZodReadonly":
        r.innerType._def[Et] = J(O({}, r.innerType._def[Et]), {
          [t]: i
        });
        break;
      case "ZodEffects":
        r.schema._def[Et] = J(O({}, r.schema._def[Et]), {
          [t]: i
        });
        break;
      default:
        r[Et] = J(O({}, r[Et]), {
          [t]: i
        });
    }
  }
  get ui() {
    const t = this._def;
    switch (t.typeName) {
      case "ZodNullable":
      case "ZodDefault":
      case "ZodOptional":
      case "ZodReadonly":
        return t.innerType.ui;
      case "ZodEffects":
        return t.schema.ui;
      default:
        return t[Et] || {};
    }
  }
  /**
   * The type of component to use to display the field and its options
   */
  displayAs(t) {
    var n, r, i;
    return (i = (n = this._def)[r = Et]) != null || (n[r] = {}), this._def[Et].displayAs = [t.id, t.params], this;
  }
  /**
   * The title of the field. Defaults to the field name.
   */
  title(t) {
    return this._setZuiMeta("title", t), this;
  }
  /**
   * Whether the field is hidden in the UI. Useful for internal fields.
   * @default false
   */
  hidden(t) {
    return this._setZuiMeta("hidden", typeof t > "u" ? !0 : t), this;
  }
  /**
   * Whether the field is disabled
   * @default false
   */
  disabled(t) {
    return this._setZuiMeta("disabled", typeof t > "u" ? !0 : t), this;
  }
  /**
   * Placeholder text for the field
   */
  placeholder(t) {
    return this._setZuiMeta("placeholder", t), this;
  }
  toJsonSchema(t) {
    return rd(this, t);
  }
  toTypescript(t) {
    return gl(this, t);
  }
  async toTypescriptAsync(t) {
    let n = gl(this, J(O({}, t), { formatter: void 0 }));
    return t != null && t.formatter && (n = await t.formatter(n)), n;
  }
  static fromObject(t, n) {
    return fa(t, n);
  }
  static fromJsonSchema(t) {
    return Gs(t);
  }
};
C(ow, "ZodType");
var ot = ow, wh = /* @__PURE__ */ ((e) => (e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodRef = "ZodRef", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodTemplateLiteral = "ZodTemplateLiteral", e.ZodReadonly = "ZodReadonly", e))(wh || {}), _t;
((e) => {
  e.assertEqual = /* @__PURE__ */ C((i) => i, "assertEqual");
  function t(i) {
  }
  e.assertIs = t, C(t, "assertIs");
  function n(i) {
    throw new Error("assertNever called");
  }
  e.assertNever = n, C(n, "assertNever"), e.arrayToEnum = /* @__PURE__ */ C((i) => {
    const o = {};
    for (const a of i)
      o[a] = a;
    return o;
  }, "arrayToEnum"), e.getValidEnumValues = /* @__PURE__ */ C((i) => {
    const o = (0, e.objectKeys)(i).filter((s) => typeof i[i[s]] != "number"), a = {};
    for (const s of o)
      a[s] = i[s];
    return (0, e.objectValues)(a);
  }, "getValidEnumValues"), e.objectValues = /* @__PURE__ */ C((i) => (0, e.objectKeys)(i).map(function(o) {
    return i[o];
  }), "objectValues"), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const o = [];
    for (const a in i)
      Object.prototype.hasOwnProperty.call(i, a) && o.push(a);
    return o;
  }, e.find = /* @__PURE__ */ C((i, o) => {
    for (const a of i)
      if (o(a))
        return a;
  }, "find"), e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function r(i, o = " | ") {
    return i.map((a) => typeof a == "string" ? `'${a}'` : a).join(o);
  }
  e.joinValues = r, C(r, "joinValues"), e.jsonStringifyReplacer = /* @__PURE__ */ C((i, o) => typeof o == "bigint" ? o.toString() : o, "jsonStringifyReplacer");
})(_t || (_t = {}));
var vl;
((e) => {
  e.mergeShapes = /* @__PURE__ */ C((t, n) => O(O({}, t), n), "mergeShapes");
})(vl || (vl = {}));
var Ce = _t.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), oi = /* @__PURE__ */ C((e) => {
  switch (typeof e) {
    case "undefined":
      return Ce.undefined;
    case "string":
      return Ce.string;
    case "number":
      return isNaN(e) ? Ce.nan : Ce.number;
    case "boolean":
      return Ce.boolean;
    case "function":
      return Ce.function;
    case "bigint":
      return Ce.bigint;
    case "symbol":
      return Ce.symbol;
    case "object":
      return Array.isArray(e) ? Ce.array : e === null ? Ce.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Ce.promise : typeof Map < "u" && e instanceof Map ? Ce.map : typeof Set < "u" && e instanceof Set ? Ce.set : typeof Date < "u" && e instanceof Date ? Ce.date : Ce.object;
    default:
      return Ce.unknown;
  }
}, "getParsedType");
function st(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: i } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i, [Et]: e == null ? void 0 : e[Et] } : { errorMap: /* @__PURE__ */ C((a, s) => a.code !== "invalid_type" ? { message: s.defaultError } : typeof s.data > "u" ? { message: r ?? s.defaultError } : { message: n ?? s.defaultError }, "customMap"), description: i, [Et]: e == null ? void 0 : e[Et] };
}
C(st, "processCreateParams");
var xh = /* @__PURE__ */ C((e, t) => {
  let n;
  switch (e.code) {
    case he.invalid_type:
      e.received === Ce.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case he.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, _t.jsonStringifyReplacer)}`;
      break;
    case he.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${_t.joinValues(e.keys, ", ")}`;
      break;
    case he.invalid_union:
      n = "Invalid input";
      break;
    case he.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${_t.joinValues(e.options)}`;
      break;
    case he.invalid_enum_value:
      n = `Invalid enum value. Expected ${_t.joinValues(e.options)}, received '${e.received}'`;
      break;
    case he.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case he.invalid_return_type:
      n = "Invalid function return type";
      break;
    case he.invalid_date:
      n = "Invalid date";
      break;
    case he.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : _t.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case he.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case he.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case he.custom:
      n = "Invalid input";
      break;
    case he.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case he.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case he.not_finite:
      n = "Number must be finite";
      break;
    case he.unresolved_reference:
      n = "Unresolved reference";
      break;
    default:
      n = t.defaultError, _t.assertNever(e);
  }
  return { message: n };
}, "errorMap"), Ry = xh, he = _t.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite",
  "unresolved_reference"
]), aw = /* @__PURE__ */ C((e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"), "quotelessJson"), bl = class sw extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = /* @__PURE__ */ C((r) => {
      this.issues = [...this.issues, r];
    }, "addIssue"), this.addIssues = /* @__PURE__ */ C((r = []) => {
      this.issues = [...this.issues, ...r];
    }, "addIssues");
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(o) {
      return o.message;
    }, r = { _errors: [] }, i = /* @__PURE__ */ C((o) => {
      for (const a of o.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(i);
        else if (a.code === "invalid_return_type")
          i(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          i(a.argumentsError);
        else if (a.path.length === 0)
          r._errors.push(n(a));
        else {
          let s = r, c = 0;
          for (; c < a.path.length; ) {
            const l = a.path[c];
            c === a.path.length - 1 ? (s[l] = s[l] || { _errors: [] }, s[l]._errors.push(n(a))) : s[l] = s[l] || { _errors: [] }, s = s[l], c++;
          }
        }
    }, "processError");
    return i(this), r;
  }
  static assert(t) {
    if (!(t instanceof sw))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, _t.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const i of this.issues)
      i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
};
C(bl, "ZodError");
bl.create = /* @__PURE__ */ C((e) => new bl(e), "create");
var Zr = bl, cw = class extends Error {
  constructor() {
    super("Unsupported zod type!");
    const t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodTemplateLiteralUnsupportedTypeError";
  }
};
C(cw, "ZodTemplateLiteralUnsupportedTypeError");
var _h = cw, lw = class extends Error {
  constructor(t, n) {
    super(`${t}'s "${n}" check is not supported in template literals!`);
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodTemplateLiteralUnsupportedCheckError";
  }
};
C(lw, "ZodTemplateLiteralUnsupportedCheckError");
var wl = lw, uw = xh;
function Sh(e) {
  uw = e;
}
C(Sh, "setErrorMap");
function sa() {
  return uw;
}
C(sa, "getErrorMap");
var fs = /* @__PURE__ */ C((e) => {
  var t;
  const { data: n, path: r, errorMaps: i, issueData: o } = e, a = [...r, ...o.path || []], s = J(O({}, o), {
    path: a
  });
  let c = "";
  const l = i.filter((u) => !!u).slice().reverse();
  for (const u of l)
    c = u(s, { data: n, defaultError: c }).message;
  return J(O({}, o), {
    path: a,
    message: (t = o.message) != null ? t : c
  });
}, "makeIssue"), dw = [];
function Ee(e, t) {
  const n = fs({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      // contextual error map is first priority
      e.schemaErrorMap,
      // then schema-bound map if available
      sa(),
      // then global override map
      xh
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(n);
}
C(Ee, "addIssueToContext");
var fw = class pw {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const i of n) {
      if (i.status === "aborted")
        return Ge;
      i.status === "dirty" && t.dirty(), r.push(i.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const i of n)
      r.push({
        key: await i.key,
        value: await i.value
      });
    return pw.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const i of n) {
      const { key: o, value: a } = i;
      if (o.status === "aborted" || a.status === "aborted")
        return Ge;
      o.status === "dirty" && t.dirty(), a.status === "dirty" && t.dirty(), o.value !== "__proto__" && (typeof a.value < "u" || i.alwaysSet) && (r[o.value] = a.value);
    }
    return { status: t.value, value: r };
  }
};
C(fw, "ParseStatus");
var Vn = fw, Ge = Object.freeze({
  status: "aborted"
}), so = /* @__PURE__ */ C((e) => ({ status: "dirty", value: e }), "DIRTY"), jn = /* @__PURE__ */ C((e) => ({ status: "valid", value: e }), "OK"), xl = /* @__PURE__ */ C((e) => e.status === "aborted", "isAborted"), _l = /* @__PURE__ */ C((e) => e.status === "dirty", "isDirty"), ca = /* @__PURE__ */ C((e) => e.status === "valid", "isValid"), ps = /* @__PURE__ */ C((e) => typeof Promise < "u" && e instanceof Promise, "isAsync"), He;
((e) => {
  e.errToObj = /* @__PURE__ */ C((t) => typeof t == "string" ? { message: t } : t || {}, "errToObj"), e.toString = /* @__PURE__ */ C((t) => typeof t == "string" ? t : t == null ? void 0 : t.message, "toString");
})(He || (He = {}));
var Sl = class extends ot {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return jn(t.data);
  }
};
C(Sl, "ZodAny");
Sl.create = /* @__PURE__ */ C((e) => new Sl(O({
  typeName: "ZodAny"
  /* ZodAny */
}, st(e))), "create");
var la = Sl, kl = class Ya extends ot {
  dereference(t) {
    return new Ya(J(O({}, this._def), {
      type: this._def.type.dereference(t)
    }));
  }
  getReferences() {
    return this._def.type.getReferences();
  }
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), i = this._def;
    if (n.parsedType !== Ce.array)
      return Ee(n, {
        code: he.invalid_type,
        expected: Ce.array,
        received: n.parsedType
      }), Ge;
    if (i.exactLength !== null) {
      const a = n.data.length > i.exactLength.value, s = n.data.length < i.exactLength.value;
      (a || s) && (Ee(n, {
        code: a ? he.too_big : he.too_small,
        minimum: s ? i.exactLength.value : void 0,
        maximum: a ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), r.dirty());
    }
    if (i.minLength !== null && n.data.length < i.minLength.value && (Ee(n, {
      code: he.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), r.dirty()), i.maxLength !== null && n.data.length > i.maxLength.value && (Ee(n, {
      code: he.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all(
        [...n.data].map((a, s) => i.type._parseAsync(new vr(n, a, n.path, s)))
      ).then((a) => Vn.mergeArray(r, a));
    const o = [...n.data].map((a, s) => i.type._parseSync(new vr(n, a, n.path, s)));
    return Vn.mergeArray(r, o);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new Ya(J(O({}, this._def), {
      minLength: { value: t, message: He.toString(n) }
    }));
  }
  max(t, n) {
    return new Ya(J(O({}, this._def), {
      maxLength: { value: t, message: He.toString(n) }
    }));
  }
  length(t, n) {
    return new Ya(J(O({}, this._def), {
      exactLength: { value: t, message: He.toString(n) }
    }));
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
C(kl, "ZodArray");
kl.create = /* @__PURE__ */ C((e, t) => new kl(O({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: "ZodArray"
  /* ZodArray */
}, st(t))), "create");
var ua = kl, El = class ap extends ot {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== Ce.bigint) {
      const o = this._getOrReturnCtx(t);
      return Ee(o, {
        code: he.invalid_type,
        expected: Ce.bigint,
        received: o.parsedType
      }), Ge;
    }
    let r;
    const i = new Vn();
    for (const o of this._def.checks)
      o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: he.too_small,
        type: "bigint",
        minimum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: he.too_big,
        type: "bigint",
        maximum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), i.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: he.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), i.dirty()) : _t.assertNever(o);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, He.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, He.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, He.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, He.toString(n));
  }
  setLimit(t, n, r, i) {
    return new ap(J(O({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: He.toString(i)
        }
      ]
    }));
  }
  _addCheck(t) {
    return new ap(J(O({}, this._def), {
      checks: [...this._def.checks, t]
    }));
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: He.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: He.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: He.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: He.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: He.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
C(El, "ZodBigInt");
El.create = /* @__PURE__ */ C((e) => {
  var t;
  return new El(O({
    checks: [],
    typeName: "ZodBigInt",
    coerce: (t = e == null ? void 0 : e.coerce) != null ? t : !1
  }, st(e)));
}, "create");
var Fs = El, Cl = class extends ot {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Ce.boolean) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: he.invalid_type,
        expected: Ce.boolean,
        received: r.parsedType
      }), Ge;
    }
    return jn(t.data);
  }
};
C(Cl, "ZodBoolean");
Cl.create = /* @__PURE__ */ C((e) => new Cl(O({
  typeName: "ZodBoolean",
  coerce: (e == null ? void 0 : e.coerce) || !1
}, st(e))), "create");
var Us = Cl, hw = Symbol("zod_brand"), mw = class extends ot {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
};
C(mw, "ZodBranded");
var Bs = mw, Tl = class extends ot {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = J(O({}, n), {
      common: J(O({}, n.common), {
        issues: []
      })
    }), i = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: O({}, r)
    });
    return ps(i) ? i.then((o) => ({
      status: "valid",
      value: o.status === "valid" ? o.value : this._def.catchValue({
        get error() {
          return new Zr(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Zr(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
C(Tl, "ZodCatch");
Tl.create = /* @__PURE__ */ C((e, t) => new Tl(O({
  innerType: e,
  typeName: "ZodCatch",
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch
}, st(t))), "create");
var zu = Tl, kh = /* @__PURE__ */ C((e, t = {}, n) => e ? la.create().superRefine((r, i) => {
  var o, a;
  if (!e(r)) {
    const s = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t, c = (a = (o = s.fatal) != null ? o : n) != null ? a : !0, l = typeof s == "string" ? { message: s } : s;
    i.addIssue(J(O({ code: "custom" }, l), { fatal: c }));
  }
}) : la.create(), "custom"), Rl = class yw extends ot {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Ce.date) {
      const o = this._getOrReturnCtx(t);
      return Ee(o, {
        code: he.invalid_type,
        expected: Ce.date,
        received: o.parsedType
      }), Ge;
    }
    if (isNaN(t.data.getTime())) {
      const o = this._getOrReturnCtx(t);
      return Ee(o, {
        code: he.invalid_date
      }), Ge;
    }
    const r = new Vn();
    let i;
    for (const o of this._def.checks)
      o.kind === "min" ? t.data.getTime() < o.value && (i = this._getOrReturnCtx(t, i), Ee(i, {
        code: he.too_small,
        message: o.message,
        inclusive: !0,
        exact: !1,
        minimum: o.value,
        type: "date"
      }), r.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (i = this._getOrReturnCtx(t, i), Ee(i, {
        code: he.too_big,
        message: o.message,
        inclusive: !0,
        exact: !1,
        maximum: o.value,
        type: "date"
      }), r.dirty()) : _t.assertNever(o);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new yw(J(O({}, this._def), {
      checks: [...this._def.checks, t]
    }));
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: He.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: He.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
};
C(Rl, "ZodDate");
Rl.create = /* @__PURE__ */ C((e) => new Rl(O({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: "ZodDate"
  /* ZodDate */
}, st(e))), "create");
var Zu = Rl, Al = class extends ot {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === Ce.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
C(Al, "ZodDefault");
Al.create = /* @__PURE__ */ C((e, t) => new Al(O({
  innerType: e,
  typeName: "ZodDefault",
  defaultValue: typeof t.default == "function" ? t.default : () => t.default
}, st(t))), "create");
var Vu = Al, ti = /* @__PURE__ */ C((e) => e instanceof Wu ? ti(e.schema) : e instanceof pi ? ti(e.innerType()) : e instanceof Zs ? [e.value] : e instanceof di ? e.options : e instanceof Vs ? _t.objectValues(e.enum) : e instanceof Vu ? ti(e._def.innerType) : e instanceof Js ? [void 0] : e instanceof Hs ? [null] : e instanceof kr ? [void 0, ...ti(e.unwrap())] : e instanceof fi ? [null, ...ti(e.unwrap())] : e instanceof Bs || e instanceof Ju ? ti(e.unwrap()) : e instanceof zu ? ti(e._def.innerType) : [], "getDiscriminator"), gw = class Ga extends ot {
  dereference(t) {
    const n = this.options.map((i) => i.dereference(t)), r = Ga._getOptionsMap(this.discriminator, n);
    return new Ga(J(O({}, this._def), {
      options: n,
      optionsMap: r
    }));
  }
  getReferences() {
    return this.options.flatMap((t) => t.getReferences());
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Ce.object)
      return Ee(n, {
        code: he.invalid_type,
        expected: Ce.object,
        received: n.parsedType
      }), Ge;
    const r = this.discriminator, i = n.data[r], o = this.optionsMap.get(i);
    return o ? n.common.async ? o._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : o._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (Ee(n, {
      code: he.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), Ge);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, r) {
    const i = Ga._getOptionsMap(t, n);
    return new Ga(O({
      typeName: "ZodDiscriminatedUnion",
      discriminator: t,
      options: n,
      optionsMap: i
    }, st(r)));
  }
  static _getOptionsMap(t, n) {
    const r = /* @__PURE__ */ new Map();
    for (const i of n) {
      const o = ti(i.shape[t]);
      if (!o.length)
        throw new Error(
          `A discriminator value for key \`${t}\` could not be extracted from all schema options`
        );
      for (const a of o) {
        if (r.has(a))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(a)}`);
        r.set(a, i);
      }
    }
    return r;
  }
};
C(gw, "ZodDiscriminatedUnion");
var Eh = gw;
function zs(e, t) {
  return new di(O({
    values: e,
    typeName: "ZodEnum"
    /* ZodEnum */
  }, st(t)));
}
C(zs, "createZodEnum");
var Ch = class sp extends ot {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return Ee(n, {
        expected: _t.joinValues(r),
        received: n.parsedType,
        code: he.invalid_type
      }), Ge;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return Ee(n, {
        received: n.data,
        code: he.invalid_enum_value,
        options: r
      }), Ge;
    }
    return jn(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t, n = this._def) {
    return sp.create(t, O(O({}, this._def), n));
  }
  exclude(t, n = this._def) {
    return sp.create(this.options.filter((r) => !t.includes(r)), O(O({}, this._def), n));
  }
};
C(Ch, "ZodEnum");
Ch.create = zs;
var di = Ch, vw = class Xa extends ot {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  dereference(t) {
    const n = this._def.args.dereference(t), r = this._def.returns.dereference(t);
    return new Xa(J(O({}, this._def), {
      args: n,
      returns: r
    }));
  }
  getReferences() {
    return [...this._def.args.getReferences(), ...this._def.returns.getReferences()];
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Ce.function)
      return Ee(n, {
        code: he.invalid_type,
        expected: Ce.function,
        received: n.parsedType
      }), Ge;
    function r(s, c) {
      return fs({
        data: s,
        path: n.path,
        errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, sa(), Ry].filter(
          (l) => !!l
        ),
        issueData: {
          code: he.invalid_arguments,
          argumentsError: c
        }
      });
    }
    C(r, "makeArgsIssue");
    function i(s, c) {
      return fs({
        data: s,
        path: n.path,
        errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, sa(), Ry].filter(
          (l) => !!l
        ),
        issueData: {
          code: he.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    C(i, "makeReturnsIssue");
    const o = { errorMap: n.common.contextualErrorMap }, a = n.data;
    if (this._def.returns instanceof Ks) {
      const s = this;
      return jn(async function(...c) {
        const l = new Zr([]), u = await s._def.args.parseAsync(c, o).catch((f) => {
          throw l.addIssue(r(c, f)), l;
        }), d = await Reflect.apply(a, this, u);
        return await s._def.returns._def.type.parseAsync(d, o).catch((f) => {
          throw l.addIssue(i(d, f)), l;
        });
      });
    } else {
      const s = this;
      return jn(function(...c) {
        const l = s._def.args.safeParse(c, o);
        if (!l.success)
          throw new Zr([r(c, l.error)]);
        const u = Reflect.apply(a, this, l.data), d = s._def.returns.safeParse(u, o);
        if (!d.success)
          throw new Zr([i(u, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Xa(J(O({}, this._def), {
      args: yo.create(t).rest(Xo.create())
    }));
  }
  returns(t) {
    return new Xa(J(O({}, this._def), {
      returns: t
    }));
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new Xa(O({
      args: t || yo.create([]).rest(Xo.create()),
      returns: n || Xo.create(),
      typeName: "ZodFunction"
      /* ZodFunction */
    }, st(r)));
  }
};
C(vw, "ZodFunction");
var Th = vw;
function Ol(e, t) {
  const n = oi(e), r = oi(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === Ce.object && r === Ce.object) {
    const i = _t.objectKeys(t), o = _t.objectKeys(e).filter((s) => i.indexOf(s) !== -1), a = O(O({}, e), t);
    for (const s of o) {
      const c = Ol(e[s], t[s]);
      if (!c.valid)
        return { valid: !1 };
      a[s] = c.data;
    }
    return { valid: !0, data: a };
  } else if (n === Ce.array && r === Ce.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let o = 0; o < e.length; o++) {
      const a = e[o], s = t[o], c = Ol(a, s);
      if (!c.valid)
        return { valid: !1 };
      i.push(c.data);
    }
    return { valid: !0, data: i };
  } else
    return n === Ce.date && r === Ce.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
C(Ol, "mergeValues");
var Il = class bw extends ot {
  dereference(t) {
    return new bw(J(O({}, this._def), {
      left: this._def.left.dereference(t),
      right: this._def.right.dereference(t)
    }));
  }
  getReferences() {
    return [...this._def.left.getReferences(), ...this._def.right.getReferences()];
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = /* @__PURE__ */ C((o, a) => {
      if (xl(o) || xl(a))
        return Ge;
      const s = Ol(o.value, a.value);
      return s.valid ? ((_l(o) || _l(a)) && n.dirty(), { status: n.value, value: s.data }) : (Ee(r, {
        code: he.invalid_intersection_types
      }), Ge);
    }, "handleParsed");
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([o, a]) => i(o, a)) : i(
      this._def.left._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      })
    );
  }
};
C(Il, "ZodIntersection");
Il.create = /* @__PURE__ */ C((e, t, n) => new Il(O({
  left: e,
  right: t,
  typeName: "ZodIntersection"
  /* ZodIntersection */
}, st(n))), "create");
var Hu = Il, Pl = class extends ot {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
};
C(Pl, "ZodLazy");
Pl.create = /* @__PURE__ */ C((e, t) => new Pl(O({
  getter: e,
  typeName: "ZodLazy"
  /* ZodLazy */
}, st(t))), "create");
var Wu = Pl, $l = class extends ot {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return Ee(n, {
        received: n.data,
        code: he.invalid_literal,
        expected: this._def.value
      }), Ge;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
};
C($l, "ZodLiteral");
$l.create = /* @__PURE__ */ C((e, t) => new $l(O({
  value: e,
  typeName: "ZodLiteral"
  /* ZodLiteral */
}, st(t))), "create");
var Zs = $l, Dl = class ww extends ot {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  dereference(t) {
    const n = this._def.keyType.dereference(t), r = this._def.valueType.dereference(t);
    return new ww(J(O({}, this._def), {
      keyType: n,
      valueType: r
    }));
  }
  getReferences() {
    return [...this._def.keyType.getReferences(), ...this._def.valueType.getReferences()];
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ce.map)
      return Ee(r, {
        code: he.invalid_type,
        expected: Ce.map,
        received: r.parsedType
      }), Ge;
    const i = this._def.keyType, o = this._def.valueType, a = [...r.data.entries()].map(([s, c], l) => ({
      key: i._parse(new vr(r, s, r.path, [l, "key"])),
      value: o._parse(new vr(r, c, r.path, [l, "value"]))
    }));
    if (r.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of a) {
          const l = await c.key, u = await c.value;
          if (l.status === "aborted" || u.status === "aborted")
            return Ge;
          (l.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(l.value, u.value);
        }
        return { status: n.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const c of a) {
        const l = c.key, u = c.value;
        if (l.status === "aborted" || u.status === "aborted")
          return Ge;
        (l.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(l.value, u.value);
      }
      return { status: n.value, value: s };
    }
  }
};
C(Dl, "ZodMap");
Dl.create = /* @__PURE__ */ C((e, t, n) => new Dl(O({
  valueType: t,
  keyType: e,
  typeName: "ZodMap"
  /* ZodMap */
}, st(n))), "create");
var Rh = Dl, Nl = class extends ot {
  _parse(t) {
    if (this._getType(t) !== Ce.nan) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: he.invalid_type,
        expected: Ce.nan,
        received: r.parsedType
      }), Ge;
    }
    return { status: "valid", value: t.data };
  }
};
C(Nl, "ZodNaN");
Nl.create = /* @__PURE__ */ C((e) => new Nl(O({
  typeName: "ZodNaN"
  /* ZodNaN */
}, st(e))), "create");
var Ah = Nl, jl = class extends ot {
  _parse(t) {
    const n = _t.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== Ce.string && r.parsedType !== Ce.number) {
      const i = _t.objectValues(n);
      return Ee(r, {
        expected: _t.joinValues(i),
        received: r.parsedType,
        code: he.invalid_type
      }), Ge;
    }
    if (n.indexOf(t.data) === -1) {
      const i = _t.objectValues(n);
      return Ee(r, {
        received: r.data,
        code: he.invalid_enum_value,
        options: i
      }), Ge;
    }
    return jn(t.data);
  }
  get enum() {
    return this._def.values;
  }
};
C(jl, "ZodNativeEnum");
jl.create = /* @__PURE__ */ C((e, t) => new jl(O({
  values: e,
  typeName: "ZodNativeEnum"
  /* ZodNativeEnum */
}, st(t))), "create");
var Vs = jl, Ml = class extends ot {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return Ee(n, {
      code: he.invalid_type,
      expected: Ce.never,
      received: n.parsedType
    }), Ge;
  }
};
C(Ml, "ZodNever");
Ml.create = /* @__PURE__ */ C((e) => new Ml(O({
  typeName: "ZodNever"
  /* ZodNever */
}, st(e))), "create");
var Mi = Ml, ql = class extends ot {
  _parse(t) {
    if (this._getType(t) !== Ce.null) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: he.invalid_type,
        expected: Ce.null,
        received: r.parsedType
      }), Ge;
    }
    return jn(t.data);
  }
};
C(ql, "ZodNull");
ql.create = /* @__PURE__ */ C((e) => new ql(O({
  typeName: "ZodNull"
  /* ZodNull */
}, st(e))), "create");
var Hs = ql, Ll = class xw extends ot {
  dereference(t) {
    return new xw(J(O({}, this._def), {
      innerType: this._def.innerType.dereference(t)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  _parse(t) {
    return this._getType(t) === Ce.null ? jn(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
C(Ll, "ZodNullable");
Ll.create = /* @__PURE__ */ C((e, t) => new Ll(O({
  innerType: e,
  typeName: "ZodNullable"
  /* ZodNullable */
}, st(t))), "create");
var fi = Ll;
function _w(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, i = n > r ? n : r, o = parseInt(e.toFixed(i).replace(".", "")), a = parseInt(t.toFixed(i).replace(".", ""));
  return o % a / Math.pow(10, i);
}
C(_w, "floatSafeRemainder");
var Fl = class cp extends ot {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Ce.number) {
      const o = this._getOrReturnCtx(t);
      return Ee(o, {
        code: he.invalid_type,
        expected: Ce.number,
        received: o.parsedType
      }), Ge;
    }
    let r;
    const i = new Vn();
    for (const o of this._def.checks)
      o.kind === "int" ? _t.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: he.invalid_type,
        expected: "integer",
        received: "float",
        message: o.message
      }), i.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: he.too_small,
        minimum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: he.too_big,
        maximum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), i.dirty()) : o.kind === "multipleOf" ? _w(t.data, o.value) !== 0 && (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: he.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), i.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), Ee(r, {
        code: he.not_finite,
        message: o.message
      }), i.dirty()) : _t.assertNever(o);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, He.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, He.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, He.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, He.toString(n));
  }
  setLimit(t, n, r, i) {
    return new cp(J(O({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: He.toString(i)
        }
      ]
    }));
  }
  _addCheck(t) {
    return new cp(J(O({}, this._def), {
      checks: [...this._def.checks, t]
    }));
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: He.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: He.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: He.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: He.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: He.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: He.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: He.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: He.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: He.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && _t.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
};
C(Fl, "ZodNumber");
Fl.create = /* @__PURE__ */ C((e) => new Fl(O({
  checks: [],
  typeName: "ZodNumber",
  coerce: (e == null ? void 0 : e.coerce) || !1
}, st(e))), "create");
var Ws = Fl;
function io(e) {
  if (e instanceof mo) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = kr.create(io(r));
    }
    return new mo(J(O({}, e._def), {
      shape: /* @__PURE__ */ C(() => t, "shape")
    }));
  } else
    return e instanceof ua ? new ua(J(O({}, e._def), {
      type: io(e.element)
    })) : e instanceof kr ? kr.create(io(e.unwrap())) : e instanceof fi ? fi.create(io(e.unwrap())) : e instanceof yo ? yo.create(e.items.map((t) => io(t))) : e;
}
C(io, "deepPartialify");
var qi = class pr extends ot {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = _t.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  dereference(t) {
    const n = this._def.shape(), r = {};
    for (const i in n)
      r[i] = n[i].dereference(t);
    return new pr(J(O({}, this._def), {
      shape: /* @__PURE__ */ C(() => r, "shape")
    }));
  }
  getReferences() {
    const t = this._def.shape(), n = [];
    for (const r in t)
      n.push(...t[r].getReferences());
    return n;
  }
  _parse(t) {
    if (this._getType(t) !== Ce.object) {
      const l = this._getOrReturnCtx(t);
      return Ee(l, {
        code: he.invalid_type,
        expected: Ce.object,
        received: l.parsedType
      }), Ge;
    }
    const { status: r, ctx: i } = this._processInputParams(t), { shape: o, keys: a } = this._getCached(), s = [];
    if (!(this._def.catchall instanceof Mi && this._def.unknownKeys === "strip"))
      for (const l in i.data)
        a.includes(l) || s.push(l);
    const c = [];
    for (const l of a) {
      const u = o[l], d = i.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: u._parse(new vr(i, d, i.path, l)),
        alwaysSet: l in i.data
      });
    }
    if (this._def.catchall instanceof Mi) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const u of s)
          c.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: i.data[u] }
          });
      else if (l === "strict")
        s.length > 0 && (Ee(i, {
          code: he.unrecognized_keys,
          keys: s
        }), r.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const u of s) {
        const d = i.data[u];
        c.push({
          key: { status: "valid", value: u },
          value: l._parse(
            new vr(i, d, i.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const u of c) {
        const d = await u.key;
        l.push({
          key: d,
          value: await u.value,
          alwaysSet: u.alwaysSet
        });
      }
      return l;
    }).then((l) => Vn.mergeObjectSync(r, l)) : Vn.mergeObjectSync(r, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return He.errToObj, new pr(O(J(O({}, this._def), {
      unknownKeys: "strict"
    }), t !== void 0 ? {
      errorMap: /* @__PURE__ */ C((n, r) => {
        var i, o, a, s;
        const c = (a = (o = (i = this._def).errorMap) == null ? void 0 : o.call(i, n, r).message) != null ? a : r.defaultError;
        return n.code === "unrecognized_keys" ? {
          message: (s = He.errToObj(t).message) != null ? s : c
        } : {
          message: c
        };
      }, "errorMap")
    } : {}));
  }
  strip() {
    return new pr(J(O({}, this._def), {
      unknownKeys: "strip"
    }));
  }
  passthrough() {
    return new pr(J(O({}, this._def), {
      unknownKeys: "passthrough"
    }));
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new pr(J(O({}, this._def), {
      shape: /* @__PURE__ */ C(() => O(O({}, this._def.shape()), t), "shape")
    }));
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new pr({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: /* @__PURE__ */ C(() => O(O({}, this._def.shape()), t._def.shape()), "shape"),
      typeName: "ZodObject"
      /* ZodObject */
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new pr(J(O({}, this._def), {
      catchall: t
    }));
  }
  pick(t) {
    const n = {};
    return _t.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new pr(J(O({}, this._def), {
      shape: /* @__PURE__ */ C(() => n, "shape")
    }));
  }
  omit(t) {
    const n = {};
    return _t.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new pr(J(O({}, this._def), {
      shape: /* @__PURE__ */ C(() => n, "shape")
    }));
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return io(this);
  }
  partial(t) {
    const n = {};
    return _t.objectKeys(this.shape).forEach((r) => {
      const i = this.shape[r];
      t && !t[r] ? n[r] = i : n[r] = i == null ? void 0 : i.optional();
    }), new pr(J(O({}, this._def), {
      shape: /* @__PURE__ */ C(() => n, "shape")
    }));
  }
  required(t) {
    const n = {};
    return _t.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let o = this.shape[r];
        for (; o instanceof kr; )
          o = o._def.innerType;
        n[r] = o;
      }
    }), new pr(J(O({}, this._def), {
      shape: /* @__PURE__ */ C(() => n, "shape")
    }));
  }
  keyof() {
    return zs(_t.objectKeys(this.shape));
  }
};
C(qi, "ZodObject");
qi.create = /* @__PURE__ */ C((e, t) => new qi(O({
  shape: /* @__PURE__ */ C(() => e, "shape"),
  unknownKeys: "strip",
  catchall: Mi.create(),
  typeName: "ZodObject"
  /* ZodObject */
}, st(t))), "create");
qi.strictCreate = /* @__PURE__ */ C((e, t) => new qi(O({
  shape: /* @__PURE__ */ C(() => e, "shape"),
  unknownKeys: "strict",
  catchall: Mi.create(),
  typeName: "ZodObject"
  /* ZodObject */
}, st(t))), "strictCreate");
qi.lazycreate = /* @__PURE__ */ C((e, t) => new qi(O({
  shape: e,
  unknownKeys: "strip",
  catchall: Mi.create(),
  typeName: "ZodObject"
  /* ZodObject */
}, st(t))), "lazycreate");
var mo = qi, Ul = class Sw extends ot {
  dereference(t) {
    return new Sw(J(O({}, this._def), {
      innerType: this._def.innerType.dereference(t)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  _parse(t) {
    return this._getType(t) === Ce.undefined ? jn(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
C(Ul, "ZodOptional");
Ul.create = /* @__PURE__ */ C((e, t) => new Ul(O({
  innerType: e,
  typeName: "ZodOptional"
  /* ZodOptional */
}, st(t))), "create");
var kr = Ul, kw = class lp extends ot {
  dereference(t) {
    return new lp(J(O({}, this._def), {
      in: this._def.in.dereference(t),
      out: this._def.out.dereference(t)
    }));
  }
  getReferences() {
    return [...this._def.in.getReferences(), ...this._def.out.getReferences()];
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (/* @__PURE__ */ C(async () => {
        const o = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? Ge : o.status === "dirty" ? (n.dirty(), so(o.value)) : this._def.out._parseAsync({
          data: o.value,
          path: r.path,
          parent: r
        });
      }, "handleAsync"))();
    {
      const i = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return i.status === "aborted" ? Ge : i.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new lp({
      in: t,
      out: n,
      typeName: "ZodPipeline"
      /* ZodPipeline */
    });
  }
};
C(kw, "ZodPipeline");
var Ku = kw, Bl = class Ew extends ot {
  unwrap() {
    return this._def.type;
  }
  dereference(t) {
    return new Ew(J(O({}, this._def), {
      type: this._def.type.dereference(t)
    }));
  }
  getReferences() {
    return this._def.type.getReferences();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Ce.promise && n.common.async === !1)
      return Ee(n, {
        code: he.invalid_type,
        expected: Ce.promise,
        received: n.parsedType
      }), Ge;
    const r = n.parsedType === Ce.promise ? n.data : Promise.resolve(n.data);
    return jn(
      r.then((i) => this._def.type.parseAsync(i, {
        path: n.path,
        errorMap: n.common.contextualErrorMap
      }))
    );
  }
};
C(Bl, "ZodPromise");
Bl.create = /* @__PURE__ */ C((e, t) => new Bl(O({
  type: e,
  typeName: "ZodPromise"
  /* ZodPromise */
}, st(t))), "create");
var Ks = Bl, zl = class Cw extends ot {
  dereference(t) {
    return new Cw(J(O({}, this._def), {
      innerType: this._def.innerType.dereference(t)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  _parse(t) {
    const n = this._def.innerType._parse(t);
    return ca(n) && (n.value = Object.freeze(n.value)), n;
  }
  unwrap() {
    return this._def.innerType;
  }
};
C(zl, "ZodReadonly");
zl.create = /* @__PURE__ */ C((e, t) => new zl(O({
  innerType: e,
  typeName: "ZodReadonly"
  /* ZodReadonly */
}, st(t))), "create");
var Ju = zl, Tw = class zc extends ot {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  dereference(t) {
    const n = this._def.keyType.dereference(t), r = this._def.valueType.dereference(t);
    return new zc(J(O({}, this._def), {
      keyType: n,
      valueType: r
    }));
  }
  getReferences() {
    return [...this._def.keyType.getReferences(), ...this._def.valueType.getReferences()];
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ce.object)
      return Ee(r, {
        code: he.invalid_type,
        expected: Ce.object,
        received: r.parsedType
      }), Ge;
    const i = [], o = this._def.keyType, a = this._def.valueType;
    for (const s in r.data)
      i.push({
        key: o._parse(new vr(r, s, r.path, s)),
        value: a._parse(new vr(r, r.data[s], r.path, s))
      });
    return r.common.async ? Vn.mergeObjectAsync(n, i) : Vn.mergeObjectSync(n, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof ot ? new zc(O({
      keyType: t,
      valueType: n,
      typeName: "ZodRecord"
      /* ZodRecord */
    }, st(r))) : new zc(O({
      keyType: Tn.create(),
      valueType: t,
      typeName: "ZodRecord"
      /* ZodRecord */
    }, st(n)));
  }
};
C(Tw, "ZodRecord");
var Oh = Tw, Zl = class extends ot {
  dereference(t) {
    const n = t[this._def.uri];
    return n || this;
  }
  getReferences() {
    return [this._def.uri];
  }
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return Ee(n, {
      code: he.unresolved_reference
    }), Ge;
  }
  isOptional() {
    return !1;
  }
  isNullable() {
    return !1;
  }
};
C(Zl, "ZodRef");
Zl.create = /* @__PURE__ */ C((e) => new Zl({
  typeName: "ZodRef",
  uri: e
}), "create");
var Ih = Zl, Vl = class Zc extends ot {
  dereference(t) {
    return new Zc(J(O({}, this._def), {
      valueType: this._def.valueType.dereference(t)
    }));
  }
  getReferences() {
    return this._def.valueType.getReferences();
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ce.set)
      return Ee(r, {
        code: he.invalid_type,
        expected: Ce.set,
        received: r.parsedType
      }), Ge;
    const i = this._def;
    i.minSize !== null && r.data.size < i.minSize.value && (Ee(r, {
      code: he.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), n.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (Ee(r, {
      code: he.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), n.dirty());
    const o = this._def.valueType;
    function a(c) {
      const l = /* @__PURE__ */ new Set();
      for (const u of c) {
        if (u.status === "aborted")
          return Ge;
        u.status === "dirty" && n.dirty(), l.add(u.value);
      }
      return { status: n.value, value: l };
    }
    C(a, "finalizeSet");
    const s = [...r.data.values()].map(
      (c, l) => o._parse(new vr(r, c, r.path, l))
    );
    return r.common.async ? Promise.all(s).then((c) => a(c)) : a(s);
  }
  min(t, n) {
    return new Zc(J(O({}, this._def), {
      minSize: { value: t, message: He.toString(n) }
    }));
  }
  max(t, n) {
    return new Zc(J(O({}, this._def), {
      maxSize: { value: t, message: He.toString(n) }
    }));
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
C(Vl, "ZodSet");
Vl.create = /* @__PURE__ */ C((e, t) => new Vl(O({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: "ZodSet"
  /* ZodSet */
}, st(t))), "create");
var Ph = Vl, Yu = /^c[^\s-]{8,}$/i, Gu = /^[a-z][a-z0-9]*$/, Xu = /^[0-9A-HJKMNP-TV-Z]{26}$/, Qu = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, ed = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Rw = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", Aw = /* @__PURE__ */ C((e) => e === Rw, "isEmojiRegex"), tf, hs = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, ms = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, td = /* @__PURE__ */ C((e) => e.precision ? e.offset ? new RegExp(
  `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$"), "datetimeRegex");
function Ow(e, t) {
  return !!((t === "v4" || !t) && hs.test(e) || (t === "v6" || !t) && ms.test(e));
}
C(Ow, "isValidIP");
var Hl = class Qa extends ot {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Ce.string) {
      const o = this._getOrReturnCtx(t);
      return Ee(
        o,
        {
          code: he.invalid_type,
          expected: Ce.string,
          received: o.parsedType
        }
        //
      ), Ge;
    }
    const r = new Vn();
    let i;
    for (const o of this._def.checks)
      if (o.kind === "min")
        t.data.length < o.value && (i = this._getOrReturnCtx(t, i), Ee(i, {
          code: he.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), r.dirty());
      else if (o.kind === "max")
        t.data.length > o.value && (i = this._getOrReturnCtx(t, i), Ee(i, {
          code: he.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), r.dirty());
      else if (o.kind === "length") {
        const a = t.data.length > o.value, s = t.data.length < o.value;
        (a || s) && (i = this._getOrReturnCtx(t, i), a ? Ee(i, {
          code: he.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }) : s && Ee(i, {
          code: he.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }), r.dirty());
      } else if (o.kind === "email")
        ed.test(t.data) || (i = this._getOrReturnCtx(t, i), Ee(i, {
          validation: "email",
          code: he.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "emoji")
        tf || (tf = new RegExp(Rw, "u")), tf.test(t.data) || (i = this._getOrReturnCtx(t, i), Ee(i, {
          validation: "emoji",
          code: he.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "uuid")
        Qu.test(t.data) || (i = this._getOrReturnCtx(t, i), Ee(i, {
          validation: "uuid",
          code: he.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "cuid")
        Yu.test(t.data) || (i = this._getOrReturnCtx(t, i), Ee(i, {
          validation: "cuid",
          code: he.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "cuid2")
        Gu.test(t.data) || (i = this._getOrReturnCtx(t, i), Ee(i, {
          validation: "cuid2",
          code: he.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "ulid")
        Xu.test(t.data) || (i = this._getOrReturnCtx(t, i), Ee(i, {
          validation: "ulid",
          code: he.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), Ee(i, {
            validation: "url",
            code: he.invalid_string,
            message: o.message
          }), r.dirty();
        }
      else
        o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), Ee(i, {
          validation: "regex",
          code: he.invalid_string,
          message: o.message
        }), r.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (i = this._getOrReturnCtx(t, i), Ee(i, {
          code: he.invalid_string,
          validation: { includes: o.value, position: o.position },
          message: o.message
        }), r.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (i = this._getOrReturnCtx(t, i), Ee(i, {
          code: he.invalid_string,
          validation: { startsWith: o.value },
          message: o.message
        }), r.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (i = this._getOrReturnCtx(t, i), Ee(i, {
          code: he.invalid_string,
          validation: { endsWith: o.value },
          message: o.message
        }), r.dirty()) : o.kind === "datetime" ? td(o).test(t.data) || (i = this._getOrReturnCtx(t, i), Ee(i, {
          code: he.invalid_string,
          validation: "datetime",
          message: o.message
        }), r.dirty()) : o.kind === "ip" ? Ow(t.data, o.version) || (i = this._getOrReturnCtx(t, i), Ee(i, {
          validation: "ip",
          code: he.invalid_string,
          message: o.message
        }), r.dirty()) : _t.assertNever(o);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((i) => t.test(i), O({
      validation: n,
      code: he.invalid_string
    }, He.errToObj(r)));
  }
  _addCheck(t) {
    return new Qa(J(O({}, this._def), {
      checks: [...this._def.checks, t]
    }));
  }
  email(t) {
    return this._addCheck(O({ kind: "email" }, He.errToObj(t)));
  }
  url(t) {
    return this._addCheck(O({ kind: "url" }, He.errToObj(t)));
  }
  emoji(t) {
    return this._addCheck(O({ kind: "emoji" }, He.errToObj(t)));
  }
  uuid(t) {
    return this._addCheck(O({ kind: "uuid" }, He.errToObj(t)));
  }
  cuid(t) {
    return this._addCheck(O({ kind: "cuid" }, He.errToObj(t)));
  }
  cuid2(t) {
    return this._addCheck(O({ kind: "cuid2" }, He.errToObj(t)));
  }
  ulid(t) {
    return this._addCheck(O({ kind: "ulid" }, He.errToObj(t)));
  }
  ip(t) {
    return this._addCheck(O({ kind: "ip" }, He.errToObj(t)));
  }
  datetime(t) {
    var n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck(O({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) != null ? n : !1
    }, He.errToObj(t == null ? void 0 : t.message)));
  }
  regex(t, n) {
    return this._addCheck(O({
      kind: "regex",
      regex: t
    }, He.errToObj(n)));
  }
  includes(t, n) {
    return this._addCheck(O({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position
    }, He.errToObj(n == null ? void 0 : n.message)));
  }
  startsWith(t, n) {
    return this._addCheck(O({
      kind: "startsWith",
      value: t
    }, He.errToObj(n)));
  }
  endsWith(t, n) {
    return this._addCheck(O({
      kind: "endsWith",
      value: t
    }, He.errToObj(n)));
  }
  min(t, n) {
    return this._addCheck(O({
      kind: "min",
      value: t
    }, He.errToObj(n)));
  }
  max(t, n) {
    return this._addCheck(O({
      kind: "max",
      value: t
    }, He.errToObj(n)));
  }
  length(t, n) {
    return this._addCheck(O({
      kind: "length",
      value: t
    }, He.errToObj(n)));
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, He.errToObj(t));
  }
  trim() {
    return new Qa(J(O({}, this._def), {
      checks: [...this._def.checks, { kind: "trim" }]
    }));
  }
  secret() {
    return this._def[Et] = J(O({}, this._def[Et]), { secret: !0 }), this;
  }
  toLowerCase() {
    return new Qa(J(O({}, this._def), {
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }));
  }
  toUpperCase() {
    return new Qa(J(O({}, this._def), {
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    }));
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
C(Hl, "ZodString");
Hl.create = /* @__PURE__ */ C((e) => {
  var t;
  return new Hl(O({
    checks: [],
    typeName: "ZodString",
    coerce: (t = e == null ? void 0 : e.coerce) != null ? t : !1
  }, st(e)));
}, "create");
var Tn = Hl, Wl = class extends ot {
  _parse(t) {
    if (this._getType(t) !== Ce.symbol) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: he.invalid_type,
        expected: Ce.symbol,
        received: r.parsedType
      }), Ge;
    }
    return jn(t.data);
  }
};
C(Wl, "ZodSymbol");
Wl.create = /* @__PURE__ */ C((e) => new Wl(O({
  typeName: "ZodSymbol"
  /* ZodSymbol */
}, st(e))), "create");
var $h = Wl, Kl = class up extends ot {
  interpolated(t) {
    return this._addPart(t);
  }
  literal(t) {
    return this._addPart(t);
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Ce.string) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: he.invalid_type,
        expected: Ce.string,
        received: r.parsedType
      }), Ge;
    }
    if (!new RegExp(this._def.regexString).test(t.data)) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: he.invalid_string,
        message: `does not match template literal with pattern /${this._def.regexString}/`,
        path: r.path,
        validation: "regex"
      }), Ge;
    }
    return { status: "valid", value: t.data };
  }
  _addPart(t) {
    const n = [...this._def.parts, t];
    return new up(J(O({}, this._def), {
      parts: n,
      regexString: this._appendToRegexString(this._def.regexString, t)
    }));
  }
  _appendToRegexString(t, n) {
    return `^${this._unwrapRegExp(t)}${this._transformPartToRegexString(n)}$`;
  }
  _transformPartToRegexString(t) {
    if (!(t instanceof ot))
      return this._escapeRegExp(t);
    if (t instanceof Zs)
      return this._escapeRegExp(t._def.value);
    if (t instanceof Tn)
      return this._transformZodStringPartToRegexString(t);
    if (t instanceof di || t instanceof Vs)
      return `(${(t instanceof di ? t._def.values : _t.getValidEnumValues(t._def.values)).map(this._escapeRegExp).join("|")})`;
    if (t instanceof Ys)
      return `(${t._def.options.map((n) => this._transformPartToRegexString(n)).join("|")})`;
    if (t instanceof Ws)
      return this._transformZodNumberPartToRegexString(t);
    if (t instanceof kr)
      return `(${this._transformPartToRegexString(t.unwrap())})?`;
    if (t instanceof up)
      return this._unwrapRegExp(t._def.regexString);
    if (t instanceof Fs)
      return "\\-?\\d+";
    if (t instanceof Us)
      return "(true|false)";
    if (t instanceof fi) {
      do
        t = t.unwrap();
      while (t instanceof fi);
      return `(${this._transformPartToRegexString(t)}|null)${t instanceof kr ? "?" : ""}`;
    }
    if (t instanceof Bs)
      return this._transformPartToRegexString(t.unwrap());
    if (t instanceof la)
      return ".*";
    if (t instanceof Hs)
      return "null";
    if (t instanceof Js)
      return "undefined";
    throw new _h();
  }
  // FIXME: we don't support transformations, so `.trim()` is not supported.
  _transformZodStringPartToRegexString(t) {
    let n = 1 / 0, r = 0, i = "", o = "";
    for (const c of t._def.checks) {
      const l = this._resolveRegexForStringCheck(c);
      if (l)
        return this._unwrapRegExp(l);
      if (c.kind === "endsWith")
        i = c.value;
      else if (c.kind === "length")
        r = n = c.value;
      else if (c.kind === "max")
        n = Math.max(0, Math.min(n, c.value));
      else if (c.kind === "min")
        r = Math.max(r, c.value);
      else if (c.kind === "startsWith")
        o = c.value;
      else
        throw new wl("ZodString", c.kind);
    }
    const a = Math.max(0, r - o.length - i.length), s = Number.isFinite(n) ? Math.max(0, n - o.length - i.length) : 1 / 0;
    return s === 0 || a > s ? `${o}${i}` : `${o}.${this._resolveRegexWildcardLength(a, s)}${i}`;
  }
  _resolveRegexForStringCheck(t) {
    var n;
    return (n = {
      [t.kind]: null,
      cuid: Yu,
      cuid2: Gu,
      datetime: t.kind === "datetime" ? td(t) : null,
      email: ed,
      ip: t.kind === "ip" ? {
        any: new RegExp(
          `^(${this._unwrapRegExp(hs.source)})|(${this._unwrapRegExp(ms.source)})$`
        ),
        v4: hs,
        v6: ms
      }[t.version || "any"] : null,
      regex: t.kind === "regex" ? t.regex : null,
      ulid: Xu,
      uuid: Qu
    }[t.kind]) != null ? n : null;
  }
  _resolveRegexWildcardLength(t, n) {
    return t === n ? t === 1 ? "" : `{${t}}` : n !== 1 / 0 ? `{${t},${n}}` : t === 0 ? "*" : t === 1 ? "+" : `{${t},}`;
  }
  // FIXME: we do not support exponent notation (e.g. 2e5) since it conflicts with `.int()`.
  _transformZodNumberPartToRegexString(t) {
    let n = !0, r = !0, i = -1 / 0, o = 1 / 0, a = !0, s = !1, c = !1, l = "";
    for (const u of t._def.checks)
      if (u.kind === "finite")
        s = !0;
      else if (u.kind === "int")
        c = !0;
      else if (u.kind === "max")
        o = Math.min(o, u.value), u.value <= 0 && (r = !1, u.value === 0 && !u.inclusive && (a = !1));
      else if (u.kind === "min")
        i = Math.max(i, u.value), u.value >= 0 && (n = !1, u.value === 0 && !u.inclusive && (a = !1));
      else
        throw new wl("ZodNumber", u.kind);
    if (Number.isFinite(i) && Number.isFinite(o) && (s = !0), n)
      l = `${l}\\-`, r && (l = `${l}?`);
    else if (!r)
      return "0+";
    return s || (l = `${l}(Infinity|(`), a ? c ? l = `${l}\\d+` : l = `${l}\\d+(\\.\\d+)?` : c ? l = `${l}\\d*[1-9]\\d*` : l = `${l}((\\d*[1-9]\\d*(\\.\\d+)?)|(\\d+\\.\\d*[1-9]\\d*))`, s || (l = `${l}))`), l;
  }
  _unwrapRegExp(t) {
    const n = typeof t == "string" ? "" : t.flags, r = typeof t == "string" ? t : t.source;
    return n.includes("i") ? this._unwrapRegExp(this._makeRegexStringCaseInsensitive(r)) : r.replace(/(^\^)|(\$$)/g, "");
  }
  _makeRegexStringCaseInsensitive(t) {
    const n = /* @__PURE__ */ C((o) => o.match(/[a-z]/i) != null, "isAlphabetic");
    let r = "", i = !1;
    for (let o = 0; o < t.length; o++) {
      const a = t.charAt(o), s = t.charAt(o + 1);
      if (a === "\\") {
        r += `${a}${s}`, o++;
        continue;
      }
      if (a === "[" ? i = !0 : i && a === "]" && (i = !1), !n(a)) {
        r += a;
        continue;
      }
      if (!i) {
        r += `[${a.toLowerCase()}${a.toUpperCase()}]`;
        continue;
      }
      const c = t.charAt(o + 2);
      if (s !== "-" || !n(c)) {
        r += `${a.toLowerCase()}${a.toUpperCase()}`;
        continue;
      }
      r += `${a.toLowerCase()}-${c.toLowerCase()}${a.toUpperCase()}-${c.toUpperCase()}`, o += 2;
    }
    return r;
  }
  _escapeRegExp(t) {
    return typeof t != "string" && (t = `${t}`), t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};
C(Kl, "ZodTemplateLiteral");
Kl.create = /* @__PURE__ */ C((e) => {
  var t;
  return new Kl(J(O({}, st(e)), {
    coerce: (t = e == null ? void 0 : e.coerce) != null ? t : !1,
    parts: [],
    regexString: "^$",
    typeName: "ZodTemplateLiteral"
    /* ZodTemplateLiteral */
  }));
}, "create");
var nd = Kl, da = class Iw extends ot {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === "ZodEffects" ? this._def.schema.sourceType() : this._def.schema;
  }
  dereference(t) {
    return new Iw(J(O({}, this._def), {
      schema: this._def.schema.dereference(t)
    }));
  }
  getReferences() {
    return this._def.schema.getReferences();
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = this._def.effect || null, o = {
      addIssue: /* @__PURE__ */ C((a) => {
        Ee(r, a), a.fatal ? n.abort() : n.dirty();
      }, "addIssue"),
      get path() {
        return r.path;
      }
    };
    if (o.addIssue = o.addIssue.bind(o), i.type === "preprocess") {
      const a = i.transform(r.data, o);
      if (r.common.async)
        return Promise.resolve(a).then(async (s) => {
          if (n.value === "aborted")
            return Ge;
          const c = await this._def.schema._parseAsync({
            data: s,
            path: r.path,
            parent: r
          });
          return c.status === "aborted" ? Ge : c.status === "dirty" || n.value === "dirty" ? so(c.value) : c;
        });
      {
        if (n.value === "aborted")
          return Ge;
        const s = this._def.schema._parseSync({
          data: a,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? Ge : s.status === "dirty" || n.value === "dirty" ? so(s.value) : s;
      }
    }
    if (i.type === "refinement") {
      const a = /* @__PURE__ */ C((s) => {
        const c = i.refinement(s, o);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      }, "executeRefinement");
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? Ge : (s.status === "dirty" && n.dirty(), a(s.value), { status: n.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => s.status === "aborted" ? Ge : (s.status === "dirty" && n.dirty(), a(s.value).then(() => ({ status: n.value, value: s.value }))));
    }
    if (i.type === "transform")
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!ca(a))
          return a;
        const s = i.transform(a.value, o);
        if (s instanceof Promise)
          throw new Error(
            "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return { status: n.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((a) => ca(a) ? Promise.resolve(i.transform(a.value, o)).then((s) => ({
          status: n.value,
          value: s
        })) : a);
    _t.assertNever(i);
  }
};
C(da, "ZodEffects");
da.create = /* @__PURE__ */ C((e, t, n) => new da(O({
  schema: e,
  typeName: "ZodEffects",
  effect: t
}, st(n))), "create");
da.createWithPreprocess = /* @__PURE__ */ C((e, t, n) => new da(O({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: "ZodEffects"
  /* ZodEffects */
}, st(n))), "createWithPreprocess");
var pi = da, Jl = class dp extends ot {
  dereference(t) {
    const n = this._def.items.map((i) => i.dereference(t)), r = this._def.rest ? this._def.rest.dereference(t) : null;
    return new dp(J(O({}, this._def), {
      items: n,
      rest: r
    }));
  }
  getReferences() {
    return [
      ...this._def.items.flatMap((t) => t.getReferences()),
      ...this._def.rest ? this._def.rest.getReferences() : []
    ];
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Ce.array)
      return Ee(r, {
        code: he.invalid_type,
        expected: Ce.array,
        received: r.parsedType
      }), Ge;
    if (r.data.length < this._def.items.length)
      return Ee(r, {
        code: he.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Ge;
    !this._def.rest && r.data.length > this._def.items.length && (Ee(r, {
      code: he.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const o = [...r.data].map((a, s) => {
      const c = this._def.items[s] || this._def.rest;
      return c ? c._parse(new vr(r, a, r.path, s)) : null;
    }).filter((a) => !!a);
    return r.common.async ? Promise.all(o).then((a) => Vn.mergeArray(n, a)) : Vn.mergeArray(n, o);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new dp(J(O({}, this._def), {
      rest: t
    }));
  }
};
C(Jl, "ZodTuple");
Jl.create = /* @__PURE__ */ C((e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Jl(O({
    items: e,
    typeName: "ZodTuple",
    rest: null
  }, st(t)));
}, "create");
var yo = Jl, Yl = class extends ot {
  _parse(t) {
    if (this._getType(t) !== Ce.undefined) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: he.invalid_type,
        expected: Ce.undefined,
        received: r.parsedType
      }), Ge;
    }
    return jn(t.data);
  }
};
C(Yl, "ZodUndefined");
Yl.create = /* @__PURE__ */ C((e) => new Yl(O({
  typeName: "ZodUndefined"
  /* ZodUndefined */
}, st(e))), "create");
var Js = Yl, Gl = class Pw extends ot {
  dereference(t) {
    const n = this._def.options.map((r) => r.dereference(t));
    return new Pw(J(O({}, this._def), {
      options: n
    }));
  }
  getReferences() {
    return this._def.options.reduce((t, n) => [...t, ...n.getReferences()], []);
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function i(o) {
      for (const s of o)
        if (s.result.status === "valid")
          return s.result;
      for (const s of o)
        if (s.result.status === "dirty")
          return n.common.issues.push(...s.ctx.common.issues), s.result;
      const a = o.map((s) => new Zr(s.ctx.common.issues));
      return Ee(n, {
        code: he.invalid_union,
        unionErrors: a
      }), Ge;
    }
    if (C(i, "handleResults"), n.common.async)
      return Promise.all(
        r.map(async (o) => {
          const a = J(O({}, n), {
            common: J(O({}, n.common), {
              issues: []
            }),
            parent: null
          });
          return {
            result: await o._parseAsync({
              data: n.data,
              path: n.path,
              parent: a
            }),
            ctx: a
          };
        })
      ).then(i);
    {
      let o;
      const a = [];
      for (const c of r) {
        const l = J(O({}, n), {
          common: J(O({}, n.common), {
            issues: []
          }),
          parent: null
        }), u = c._parseSync({
          data: n.data,
          path: n.path,
          parent: l
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !o && (o = { result: u, ctx: l }), l.common.issues.length && a.push(l.common.issues);
      }
      if (o)
        return n.common.issues.push(...o.ctx.common.issues), o.result;
      const s = a.map((c) => new Zr(c));
      return Ee(n, {
        code: he.invalid_union,
        unionErrors: s
      }), Ge;
    }
  }
  get options() {
    return this._def.options;
  }
};
C(Gl, "ZodUnion");
Gl.create = /* @__PURE__ */ C((e, t) => new Gl(O({
  options: e,
  typeName: "ZodUnion"
  /* ZodUnion */
}, st(t))), "create");
var Ys = Gl, Xl = class extends ot {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return jn(t.data);
  }
};
C(Xl, "ZodUnknown");
Xl.create = /* @__PURE__ */ C((e) => new Xl(O({
  typeName: "ZodUnknown"
  /* ZodUnknown */
}, st(e))), "create");
var Xo = Xl, Ql = class extends ot {
  _parse(t) {
    if (this._getType(t) !== Ce.undefined) {
      const r = this._getOrReturnCtx(t);
      return Ee(r, {
        code: he.invalid_type,
        expected: Ce.void,
        received: r.parsedType
      }), Ge;
    }
    return jn(t.data);
  }
};
C(Ql, "ZodVoid");
Ql.create = /* @__PURE__ */ C((e) => new Ql(O({
  typeName: "ZodVoid"
  /* ZodVoid */
}, st(e))), "create");
var Dh = Ql, hT = /^\d{4}-\d{2}-\d{2}(T|\s)?((\d{2}:\d{2}:\d{2}(\.\d{1,3})?)|(\d{2}:\d{2}))?(\s?([+-]\d{2}:\d{2}|Z))?$/, fa = /* @__PURE__ */ C((e, t, n = !0) => {
  if (typeof e != "object")
    throw new Error("Input must be an object");
  const r = /* @__PURE__ */ C((a) => {
    let s = a;
    return t != null && t.nullable && (s = s.nullable()), t != null && t.optional && (s = s.optional()), t != null && t.passtrough && typeof s.passthrough == "function" && (s = s.passthrough()), s;
  }, "applyOptions"), i = Object.entries(e).reduce((a, [s, c]) => {
    if (c === null)
      a[s] = r(En.null());
    else
      switch (typeof c) {
        case "string":
          a[s] = hT.test(c) ? r(En.string().datetime()) : r(En.string());
          break;
        case "number":
          a[s] = r(En.number());
          break;
        case "boolean":
          a[s] = r(En.boolean());
          break;
        case "object":
          Array.isArray(c) ? c.length === 0 ? a[s] = r(En.array(En.unknown())) : typeof c[0] == "object" ? a[s] = r(En.array(fa(c[0], t, !1))) : ["string", "number", "boolean"].includes(typeof c[0]) && (a[s] = r(En.array(En[typeof c[0]]()))) : a[s] = r(fa(c, t, !1));
          break;
        default:
          throw new Error(`Unsupported type for key ${s}`);
      }
    return a;
  }, {}), o = Object.keys(i).length > 0;
  return t != null && t.passtrough || !n && !o ? En.object(i).passthrough() : En.object(i);
}, "objectToZui");
function $w() {
  return {};
}
C($w, "parseAnyDef");
function Nh(e, t, n, r) {
  r != null && r.errorMessages && n && (e.errorMessage = J(O({}, e.errorMessage), {
    [t]: n
  }));
}
C(Nh, "addErrorMessage");
function Dt(e, t, n, r, i) {
  e[t] = n, Nh(e, t, r, i);
}
C(Dt, "setResponseValueAndErrors");
function Dw(e, t) {
  var n, r;
  const i = {
    type: "array"
  };
  return ((r = (n = e.type) == null ? void 0 : n._def) == null ? void 0 : r.typeName) !== "ZodAny" && (i.items = Ot(e.type._def, J(O({}, t), {
    currentPath: [...t.currentPath, "items"]
  }))), e.minLength && Dt(i, "minItems", e.minLength.value, e.minLength.message, t), e.maxLength && Dt(i, "maxItems", e.maxLength.value, e.maxLength.message, t), e.exactLength && (Dt(i, "minItems", e.exactLength.value, e.exactLength.message, t), Dt(i, "maxItems", e.exactLength.value, e.exactLength.message, t)), i;
}
C(Dw, "parseArrayDef");
function Nw(e, t) {
  const n = O({
    type: "integer",
    format: "int64"
  }, e.coerce ? {
    [Et]: {
      coerce: e.coerce || void 0
    }
  } : {});
  if (!e.checks)
    return n;
  for (const r of e.checks)
    switch (r.kind) {
      case "min":
        t.target === "jsonSchema7" ? r.inclusive ? Dt(n, "minimum", r.value, r.message, t) : Dt(n, "exclusiveMinimum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMinimum = !0), Dt(n, "minimum", r.value, r.message, t));
        break;
      case "max":
        t.target === "jsonSchema7" ? r.inclusive ? Dt(n, "maximum", r.value, r.message, t) : Dt(n, "exclusiveMaximum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMaximum = !0), Dt(n, "maximum", r.value, r.message, t));
        break;
      case "multipleOf":
        Dt(n, "multipleOf", r.value, r.message, t);
        break;
    }
  return n;
}
C(Nw, "parseBigintDef");
function jw(e) {
  return O({
    type: "boolean"
  }, e.coerce ? {
    [Et]: {
      coerce: e.coerce || void 0
    }
  } : {});
}
C(jw, "parseBooleanDef");
function Mw(e, t) {
  return Ot(e.type._def, t);
}
C(Mw, "parseBrandedDef");
var mT = /* @__PURE__ */ C((e, t) => Ot(e.innerType._def, t), "parseCatchDef");
function qw(e, t) {
  return t.dateStrategy == "integer" ? yT(e, t) : O({
    type: "string",
    format: "date-time"
  }, e.coerce ? {
    [Et]: {
      coerce: e.coerce || void 0
    }
  } : {});
}
C(qw, "parseDateDef");
var yT = /* @__PURE__ */ C((e, t) => {
  const n = O({
    type: "integer",
    format: "unix-time"
  }, e.coerce ? {
    [Et]: {
      coerce: e.coerce || void 0
    }
  } : {});
  for (const r of e.checks)
    switch (r.kind) {
      case "min":
        t.target === "jsonSchema7" && Dt(
          n,
          "minimum",
          r.value,
          // This is in milliseconds
          r.message,
          t
        );
        break;
      case "max":
        t.target === "jsonSchema7" && Dt(
          n,
          "maximum",
          r.value,
          // This is in milliseconds
          r.message,
          t
        );
        break;
    }
  return n;
}, "integerDateParser");
function Lw(e, t) {
  return J(O({}, Ot(e.innerType._def, t)), {
    default: e.defaultValue()
  });
}
C(Lw, "parseDefaultDef");
function Fw(e, t) {
  return t.effectStrategy === "input" ? Ot(e.schema._def, t) : {};
}
C(Fw, "parseEffectsDef");
function Uw(e) {
  return {
    type: "string",
    enum: e.values
  };
}
C(Uw, "parseEnumDef");
var gT = /* @__PURE__ */ C((e) => "type" in e && e.type === "string" ? !1 : "allOf" in e, "isJsonSchema7AllOfType");
function Bw(e, t) {
  const n = [
    Ot(e.left._def, J(O({}, t), {
      currentPath: [...t.currentPath, "allOf", "0"]
    })),
    Ot(e.right._def, J(O({}, t), {
      currentPath: [...t.currentPath, "allOf", "1"]
    }))
  ].filter((o) => !!o);
  let r = t.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const i = [];
  return n.forEach((o) => {
    if (gT(o))
      i.push(...o.allOf), o.unevaluatedProperties === void 0 && (r = void 0);
    else {
      let a = o;
      "additionalProperties" in o && o.additionalProperties === !1 ? a = Mb(o, ["additionalProperties"]) : r = void 0, i.push(a);
    }
  }), i.length ? O({
    allOf: i
  }, r) : void 0;
}
C(Bw, "parseIntersectionDef");
function zw(e, t) {
  const n = typeof e.value;
  return n !== "bigint" && n !== "number" && n !== "boolean" && n !== "string" ? {
    type: Array.isArray(e.value) ? "array" : "object"
  } : t.target === "openApi3" ? {
    type: n === "bigint" ? "integer" : n,
    enum: [e.value]
  } : {
    type: n === "bigint" ? "integer" : n,
    const: e.value
  };
}
C(zw, "parseLiteralDef");
var Ua = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: "^[cC][^\\s-]{8,}$",
  cuid2: "^[a-z][a-z0-9]*$",
  ulid: "^[0-9A-HJKMNP-TV-Z]{26}$",
  /**
   * `a-z` was added to replicate /i flag
   */
  email: "^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_+-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$",
  emoji: "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  /**
   * Unused
   */
  uuid: "^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$",
  /**
   * Unused
   */
  ipv4: "^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$",
  /**
   * Unused
   */
  ipv6: "^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$"
};
function jh(e, t) {
  const n = O({
    type: "string"
  }, e.coerce ? {
    [Et]: {
      coerce: e.coerce || void 0
    }
  } : {});
  function r(i) {
    return t.patternStrategy === "escape" ? vT(i) : i;
  }
  if (C(r, "processPattern"), e.checks)
    for (const i of e.checks)
      switch (i.kind) {
        case "min":
          Dt(
            n,
            "minLength",
            typeof n.minLength == "number" ? Math.max(n.minLength, i.value) : i.value,
            i.message,
            t
          );
          break;
        case "max":
          Dt(
            n,
            "maxLength",
            typeof n.maxLength == "number" ? Math.min(n.maxLength, i.value) : i.value,
            i.message,
            t
          );
          break;
        case "email":
          switch (t.emailStrategy) {
            case "format:email":
              Qi(n, "email", i.message, t);
              break;
            case "format:idn-email":
              Qi(n, "idn-email", i.message, t);
              break;
            case "pattern:zod":
              Qr(n, Ua.email, i.message, t);
              break;
          }
          break;
        case "url":
          Qi(n, "uri", i.message, t);
          break;
        case "uuid":
          Qi(n, "uuid", i.message, t);
          break;
        case "regex":
          Qr(n, i.regex.source, i.message, t);
          break;
        case "cuid":
          Qr(n, Ua.cuid, i.message, t);
          break;
        case "cuid2":
          Qr(n, Ua.cuid2, i.message, t);
          break;
        case "startsWith":
          Qr(n, "^" + r(i.value), i.message, t);
          break;
        case "endsWith":
          Qr(n, r(i.value) + "$", i.message, t);
          break;
        case "datetime":
          Qi(n, "date-time", i.message, t);
          break;
        case "length":
          Dt(
            n,
            "minLength",
            typeof n.minLength == "number" ? Math.max(n.minLength, i.value) : i.value,
            i.message,
            t
          ), Dt(
            n,
            "maxLength",
            typeof n.maxLength == "number" ? Math.min(n.maxLength, i.value) : i.value,
            i.message,
            t
          );
          break;
        case "includes": {
          Qr(n, r(i.value), i.message, t);
          break;
        }
        case "ip": {
          i.version !== "v6" && Qi(n, "ipv4", i.message, t), i.version !== "v4" && Qi(n, "ipv6", i.message, t);
          break;
        }
        case "emoji":
          Qr(n, Ua.emoji, i.message, t);
          break;
        case "ulid": {
          Qr(n, Ua.ulid, i.message, t);
          break;
        }
      }
  return n;
}
C(jh, "parseStringDef");
var vT = /* @__PURE__ */ C((e) => Array.from(e).map((t) => /[a-zA-Z0-9]/.test(t) ? t : `\\${t}`).join(""), "escapeNonAlphaNumeric"), Qi = /* @__PURE__ */ C((e, t, n, r) => {
  var i;
  e.format || (i = e.anyOf) != null && i.some((o) => o.format) ? (e.anyOf || (e.anyOf = []), e.format && (e.anyOf.push(O({
    format: e.format
  }, e.errorMessage && r.errorMessages && {
    errorMessage: { format: e.errorMessage.format }
  })), delete e.format, e.errorMessage && (delete e.errorMessage.format, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.anyOf.push(O({
    format: t
  }, n && r.errorMessages && { errorMessage: { format: n } }))) : Dt(e, "format", t, n, r);
}, "addFormat"), Qr = /* @__PURE__ */ C((e, t, n, r) => {
  var i;
  e.pattern || (i = e.allOf) != null && i.some((o) => o.pattern) ? (e.allOf || (e.allOf = []), e.pattern && (e.allOf.push(O({
    pattern: e.pattern
  }, e.errorMessage && r.errorMessages && {
    errorMessage: { pattern: e.errorMessage.pattern }
  })), delete e.pattern, e.errorMessage && (delete e.errorMessage.pattern, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.allOf.push(O({
    pattern: t
  }, n && r.errorMessages && { errorMessage: { pattern: n } }))) : Dt(e, "pattern", t, n, r);
}, "addPattern");
function Mh(e, t) {
  var n, r, i, o, a;
  if (t.target === "openApi3" && ((n = e.keyType) == null ? void 0 : n._def.typeName) === "ZodEnum")
    return {
      type: "object",
      required: e.keyType._def.values,
      properties: e.keyType._def.values.reduce(
        (c, l) => {
          var u;
          return J(O({}, c), {
            [l]: (u = Ot(e.valueType._def, J(O({}, t), {
              currentPath: [...t.currentPath, "properties", l]
            }))) != null ? u : {}
          });
        },
        {}
      ),
      additionalProperties: !1
    };
  const s = {
    type: "object",
    additionalProperties: (r = Ot(e.valueType._def, J(O({}, t), {
      currentPath: [...t.currentPath, "additionalProperties"]
    }))) != null ? r : {}
  };
  if (t.target === "openApi3")
    return s;
  if (((i = e.keyType) == null ? void 0 : i._def.typeName) === "ZodString" && ((o = e.keyType._def.checks) != null && o.length)) {
    const c = Object.entries(jh(e.keyType._def, t)).reduce(
      (l, [u, d]) => u === "type" ? l : J(O({}, l), { [u]: d }),
      {}
    );
    return J(O({}, s), {
      propertyNames: c
    });
  } else if (((a = e.keyType) == null ? void 0 : a._def.typeName) === "ZodEnum")
    return J(O({}, s), {
      propertyNames: {
        enum: e.keyType._def.values
      }
    });
  return s;
}
C(Mh, "parseRecordDef");
function Zw(e, t) {
  if (t.mapStrategy === "record")
    return Mh(e, t);
  const n = Ot(e.keyType._def, J(O({}, t), {
    currentPath: [...t.currentPath, "items", "items", "0"]
  })) || {}, r = Ot(e.valueType._def, J(O({}, t), {
    currentPath: [...t.currentPath, "items", "items", "1"]
  })) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, r],
      minItems: 2,
      maxItems: 2
    }
  };
}
C(Zw, "parseMapDef");
function Vw(e) {
  const t = e.values, r = Object.keys(e.values).filter((o) => typeof t[t[o]] != "number").map((o) => t[o]), i = Array.from(new Set(r.map((o) => typeof o)));
  return {
    type: i.length === 1 ? i[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: r.filter(
      (o) => typeof o == "string" || typeof o == "number"
    )
  };
}
C(Vw, "parseNativeEnumDef");
function Hw() {
  return {
    not: {}
  };
}
C(Hw, "parseNeverDef");
function Ww(e) {
  return e.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
C(Ww, "parseNullDef");
var eu = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function Kw(e, t) {
  if (t.target === "openApi3")
    return Ay(e, t);
  const n = e.options instanceof Map ? Array.from(e.options.values()) : e.options;
  if (n.every((r) => r._def.typeName in eu && (!r._def.checks || !r._def.checks.length))) {
    const r = n.reduce((i, o) => {
      const a = eu[o._def.typeName];
      return a && !i.includes(a) ? [...i, a] : i;
    }, []);
    return {
      type: r.length > 1 ? r : r[0]
    };
  } else if (n.every((r) => r._def.typeName === "ZodLiteral" && !r.description)) {
    const r = n.reduce((i, o) => {
      const a = typeof o._def.value;
      switch (a) {
        case "string":
        case "number":
        case "boolean":
          return [...i, a];
        case "bigint":
          return [...i, "integer"];
        case "object":
          if (o._def.value === null)
            return [...i, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return i;
      }
    }, []);
    if (r.length === n.length) {
      const i = r.filter((o, a, s) => s.indexOf(o) === a);
      return {
        type: i.length > 1 ? i : i[0],
        enum: n.reduce(
          (o, a) => o.includes(a._def.value) ? o : [...o, a._def.value],
          []
        )
      };
    }
  } else if (n.every((r) => r._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce(
        (r, i) => [...r, ...i._def.values.filter((o) => !r.includes(o))],
        []
      )
    };
  return Ay(e, t);
}
C(Kw, "parseUnionDef");
var Ay = /* @__PURE__ */ C((e, t) => {
  const n = (e.options instanceof Map ? Array.from(e.options.values()) : e.options).map(
    (i, o) => Ot(i._def, J(O({}, t), {
      currentPath: [...t.currentPath, t.unionStrategy, `${o}`]
    }))
  ).filter(
    (i) => !!i && (!t.strictUnions || typeof i == "object" && Object.keys(i).length > 0)
  ), r = t.discriminator && e.typeName === "ZodDiscriminatedUnion" && typeof e.discriminator == "string" ? { discriminator: { propertyName: e.discriminator } } : {};
  if (n.length)
    return t.unionStrategy === "anyOf" ? O({ anyOf: n }, r) : O({ oneOf: n }, r);
}, "asUnionOf");
function Jw(e, t) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(e.innerType._def.typeName) && (!e.innerType._def.checks || !e.innerType._def.checks.length))
    return t.target === "openApi3" ? {
      type: eu[e.innerType._def.typeName],
      nullable: !0
    } : {
      type: [eu[e.innerType._def.typeName], "null"]
    };
  if (t.target === "openApi3") {
    const r = Ot(e.innerType._def, J(O({}, t), {
      currentPath: [...t.currentPath]
    }));
    return r && J(O({}, r), { nullable: !0 });
  }
  const n = Ot(e.innerType._def, J(O({}, t), {
    currentPath: [...t.currentPath, "anyOf", "0"]
  }));
  return n && { anyOf: [n, { type: "null" }] };
}
C(Jw, "parseNullableDef");
function Yw(e, t) {
  const n = O({
    type: "number"
  }, e.coerce ? {
    [Et]: {
      coerce: e.coerce || void 0
    }
  } : {});
  if (!e.checks)
    return n;
  for (const r of e.checks)
    switch (r.kind) {
      case "int":
        n.type = "integer", Nh(n, "type", r.message, t);
        break;
      case "min":
        t.target === "jsonSchema7" ? r.inclusive ? Dt(n, "minimum", r.value, r.message, t) : Dt(n, "exclusiveMinimum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMinimum = !0), Dt(n, "minimum", r.value, r.message, t));
        break;
      case "max":
        t.target === "jsonSchema7" ? r.inclusive ? Dt(n, "maximum", r.value, r.message, t) : Dt(n, "exclusiveMaximum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMaximum = !0), Dt(n, "maximum", r.value, r.message, t));
        break;
      case "multipleOf":
        Dt(n, "multipleOf", r.value, r.message, t);
        break;
    }
  return n;
}
C(Yw, "parseNumberDef");
function Gw(e, t) {
  var n;
  const r = J(O({
    type: "object"
  }, Object.entries(e.shape()).reduce(
    (i, [o, a]) => {
      if (a === void 0 || a._def === void 0)
        return i;
      const s = Ot(a._def, J(O({}, t), {
        currentPath: [...t.currentPath, "properties", o],
        propertyPath: [...t.currentPath, "properties", o]
      }));
      return s === void 0 ? i : {
        properties: J(O({}, i.properties), { [o]: s }),
        required: a.isOptional() ? i.required : [...i.required, o]
      };
    },
    { properties: {}, required: [] }
  )), {
    additionalProperties: e.catchall._def.typeName === "ZodNever" ? e.unknownKeys === "passthrough" : (n = Ot(e.catchall._def, J(O({}, t), {
      currentPath: [...t.currentPath, "additionalProperties"]
    }))) != null ? n : !0
  });
  return r.required.length || delete r.required, r;
}
C(Gw, "parseObjectDef");
var bT = /* @__PURE__ */ C((e, t) => {
  var n;
  if (t.currentPath.toString() === ((n = t.propertyPath) == null ? void 0 : n.toString()))
    return Ot(e.innerType._def, t);
  const r = Ot(e.innerType._def, J(O({}, t), {
    currentPath: [...t.currentPath, "anyOf", "1"]
  }));
  return r ? {
    anyOf: [
      {
        not: {}
      },
      r
    ]
  } : {};
}, "parseOptionalDef"), wT = /* @__PURE__ */ C((e, t) => {
  if (t.pipeStrategy === "input")
    return Ot(e.in._def, t);
  if (t.pipeStrategy === "output")
    return Ot(e.out._def, t);
  const n = Ot(e.in._def, J(O({}, t), {
    currentPath: [...t.currentPath, "allOf", "0"]
  })), r = Ot(e.out._def, J(O({}, t), {
    currentPath: [...t.currentPath, "allOf", n ? "1" : "0"]
  }));
  return {
    allOf: [n, r].filter((i) => i !== void 0)
  };
}, "parsePipelineDef");
function Xw(e, t) {
  return Ot(e.type._def, t);
}
C(Xw, "parsePromiseDef");
function Qw(e, t) {
  const r = {
    type: "array",
    uniqueItems: !0,
    items: Ot(e.valueType._def, J(O({}, t), {
      currentPath: [...t.currentPath, "items"]
    }))
  };
  return e.minSize && Dt(r, "minItems", e.minSize.value, e.minSize.message, t), e.maxSize && Dt(r, "maxItems", e.maxSize.value, e.maxSize.message, t), r;
}
C(Qw, "parseSetDef");
function ex(e, t) {
  return e.rest ? {
    type: "array",
    minItems: e.items.length,
    items: e.items.map(
      (n, r) => Ot(n._def, J(O({}, t), {
        currentPath: [...t.currentPath, "items", `${r}`]
      }))
    ).reduce((n, r) => r === void 0 ? n : [...n, r], []),
    additionalItems: Ot(e.rest._def, J(O({}, t), {
      currentPath: [...t.currentPath, "additionalItems"]
    }))
  } : {
    type: "array",
    minItems: e.items.length,
    maxItems: e.items.length,
    items: e.items.map(
      (n, r) => Ot(n._def, J(O({}, t), {
        currentPath: [...t.currentPath, "items", `${r}`]
      }))
    ).reduce((n, r) => r === void 0 ? n : [...n, r], [])
  };
}
C(ex, "parseTupleDef");
function tx() {
  return {
    not: {}
  };
}
C(tx, "parseUndefinedDef");
function nx() {
  return {};
}
C(nx, "parseUnknownDef");
var xT = /* @__PURE__ */ C((e, t) => Ot(e.innerType._def, t), "parseReadonlyDef");
function rx(e) {
  return {
    $ref: e.uri
  };
}
C(rx, "parseRefDef");
function Ot(e, t, n = !1) {
  const r = t.seen.get(e);
  if (r && !n) {
    const a = _T(r, t);
    if (a !== void 0)
      return a;
  }
  const i = { def: e, path: t.currentPath, jsonSchema: void 0 };
  t.seen.set(e, i);
  const o = kT(e, e.typeName, t);
  return o && ET(e, t, o), i.jsonSchema = o, o;
}
C(Ot, "parseDef");
var _T = /* @__PURE__ */ C((e, t) => {
  switch (t.$refStrategy) {
    case "root":
      return { $ref: e.path.join("/") };
    case "relative":
      return { $ref: ST(t.currentPath, e.path) };
    case "none":
    case "seen":
      return e.path.length < t.currentPath.length && e.path.every((n, r) => t.currentPath[r] === n) ? (console.warn(`Recursive reference detected at ${t.currentPath.join("/")}! Defaulting to any`), {}) : t.$refStrategy === "seen" ? {} : void 0;
  }
}, "get$ref"), ST = /* @__PURE__ */ C((e, t) => {
  let n = 0;
  for (; n < e.length && n < t.length && e[n] === t[n]; n++)
    ;
  return [(e.length - n).toString(), ...t.slice(n)].join("/");
}, "getRelativePath"), kT = /* @__PURE__ */ C((e, t, n) => {
  switch (t) {
    case "ZodString":
      return jh(e, n);
    case "ZodNumber":
      return Yw(e, n);
    case "ZodObject":
      return Gw(e, n);
    case "ZodBigInt":
      return Nw(e, n);
    case "ZodBoolean":
      return jw(e);
    case "ZodDate":
      return qw(e, n);
    case "ZodUndefined":
      return tx();
    case "ZodNull":
      return Ww(n);
    case "ZodArray":
      return Dw(e, n);
    case "ZodUnion":
    case "ZodDiscriminatedUnion":
      return Kw(e, n);
    case "ZodIntersection":
      return Bw(e, n);
    case "ZodTuple":
      return ex(e, n);
    case "ZodRecord":
      return Mh(e, n);
    case "ZodRef":
      return rx(e);
    case "ZodLiteral":
      return zw(e, n);
    case "ZodEnum":
      return Uw(e);
    case "ZodNativeEnum":
      return Vw(e);
    case "ZodNullable":
      return Jw(e, n);
    case "ZodOptional":
      return bT(e, n);
    case "ZodMap":
      return Zw(e, n);
    case "ZodSet":
      return Qw(e, n);
    case "ZodLazy":
      return Ot(e.getter()._def, n);
    case "ZodPromise":
      return Xw(e, n);
    case "ZodNaN":
    case "ZodNever":
      return Hw();
    case "ZodEffects":
      return Fw(e, n);
    case "ZodAny":
      return $w();
    case "ZodUnknown":
      return nx();
    case "ZodDefault":
      return Lw(e, n);
    case "ZodBranded":
      return Mw(e, n);
    case "ZodReadonly":
      return xT(e, n);
    case "ZodCatch":
      return mT(e, n);
    case "ZodPipeline":
      return wT(e, n);
    case "ZodTemplateLiteral":
      throw new Error("Template literals are not supported yet");
    case "ZodFunction":
    case "ZodVoid":
    case "ZodSymbol":
      return;
    default:
      return /* @__PURE__ */ ((r) => {
      })();
  }
}, "selectParser"), ET = /* @__PURE__ */ C((e, t, n) => (e.description && (n.description = e.description, t.markdownDescription && (n.markdownDescription = e.description)), Object.assign(n, { [Et]: O(O({}, e[Et]), n[Et]) || {} }), n), "addMeta"), Oy = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "string",
  mapStrategy: "entries",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  emailStrategy: "format:email",
  discriminator: !1,
  unionStrategy: "anyOf"
}, CT = /* @__PURE__ */ C((e) => typeof e == "string" ? J(O({}, Oy), {
  name: e
}) : O(O({}, Oy), e), "getDefaultOptions"), TT = /* @__PURE__ */ C((e) => {
  const t = CT(e), n = t.name !== void 0 ? [...t.basePath, t.definitionPath, t.name] : t.basePath;
  return J(O({}, t), {
    currentPath: n,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(t.definitions).map(([r, i]) => [
        i._def,
        {
          def: i._def,
          path: [...t.basePath, t.definitionPath, r],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  });
}, "getRefs"), RT = /* @__PURE__ */ C((e, t) => {
  var n;
  const r = TT(t), i = typeof t == "object" && t.definitions ? Object.entries(t.definitions).reduce(
    (c, [l, u]) => {
      var d;
      return J(O({}, c), {
        [l]: (d = Ot(
          u._def,
          J(O({}, r), {
            currentPath: [...r.basePath, r.definitionPath, l]
          }),
          !0
        )) != null ? d : {}
      });
    },
    {}
  ) : void 0, o = typeof t == "string" ? t : t == null ? void 0 : t.name, a = (n = Ot(
    e._def,
    o === void 0 ? r : J(O({}, r), {
      currentPath: [...r.basePath, r.definitionPath, o]
    }),
    !1
  )) != null ? n : {}, s = o === void 0 ? i ? J(O({}, a), {
    [r.definitionPath]: i
  }) : a : {
    $ref: [...r.$refStrategy === "relative" ? [] : r.basePath, r.definitionPath, o].join("/"),
    [r.definitionPath]: J(O({}, i), {
      [o]: a
    })
  };
  return r.target === "jsonSchema7" ? s.$schema = "http://json-schema.org/draft-07/schema#" : r.target === "jsonSchema2019-09" && (s.$schema = "https://json-schema.org/draft/2019-09/schema#"), s;
}, "zodToJsonSchema"), rd = /* @__PURE__ */ C((e, t = { target: "openApi3" }) => {
  const n = RT(e, t);
  return t.$schemaUrl === !1 ? delete n.$schema : typeof t.$schemaUrl == "string" && (n.$schema = t.$schemaUrl), n;
}, "zuiToJsonSchema"), AT = [
  "gpt-3.5-turbo",
  "gpt-3.5-turbo-16k",
  "gpt-4",
  "gpt-4-1106-preview",
  "gpt-4-vision-preview",
  "gpt-4-0125-preview",
  "gpt-4-turbo-preview",
  "gpt-4-turbo",
  "gpt-4o",
  "gpt-3.5-turbo-0125",
  "gpt-3.5-turbo-1106"
];
di.create([
  "any",
  "string",
  "number",
  "boolean",
  "object",
  "pattern",
  "date",
  "array",
  "target",
  "time",
  "enum"
]);
var ix = /* @__PURE__ */ C((e) => Tn.create().displayAs({ id: "variable", params: O({ type: (e == null ? void 0 : e.type) || "any" }, e == null ? void 0 : e.params) }), "variable"), ox = /* @__PURE__ */ C((e) => Tn.create().displayAs({ id: "conversation", params: O({}, e == null ? void 0 : e.params) }), "conversation"), ax = /* @__PURE__ */ C((e) => Tn.create().displayAs({ id: "user", params: O({}, e == null ? void 0 : e.params) }), "user"), sx = /* @__PURE__ */ C((e) => Tn.create().displayAs({ id: "message", params: O({}, e == null ? void 0 : e.params) }), "message"), cx = /* @__PURE__ */ C((e) => Tn.create().displayAs({ id: "agent", params: O({}, e == null ? void 0 : e.params) }), "agent"), lx = /* @__PURE__ */ C((e) => Tn.create().displayAs({ id: "event", params: O({}, e == null ? void 0 : e.params) }), "event"), ux = /* @__PURE__ */ C((e) => Tn.create().displayAs({ id: "table", params: O({}, e == null ? void 0 : e.params) }), "table"), dx = /* @__PURE__ */ C((e) => Tn.create().displayAs({ id: "tablerow", params: O({}, e == null ? void 0 : e.params) }), "tablerow"), fx = /* @__PURE__ */ C((e) => Tn.create().displayAs({ id: "intent", params: O({}, e == null ? void 0 : e.params) }), "intent"), px = /* @__PURE__ */ C(() => di.create(AT).displayAs({ id: "dropdown", params: {} }), "aimodel"), hx = /* @__PURE__ */ C((e) => Tn.create().displayAs({ id: "datasource", params: O({}, e) }), "datasource"), mx = /* @__PURE__ */ C((e) => Tn.create().displayAs({ id: "knowledgebase", params: O({}, e) }), "knowledgebase"), yx = {
  object: mo.lazycreate
}, gx = /* @__PURE__ */ C((e, t = {
  message: `Input not instance of ${e.name}`
}) => kh((n) => n instanceof e, t), "instanceOfType"), qh = Tn.create, Lh = Ws.create, vx = Ah.create, bx = Fs.create, Fh = Us.create, wx = Zu.create, xx = $h.create, _x = Js.create, Sx = Hs.create, kx = la.create, Ex = Xo.create, Cx = Mi.create, Tx = Dh.create, Rx = ua.create, Ax = mo.create, Ox = mo.strictCreate, Ix = Ys.create, Px = Eh.create, $x = Hu.create, Dx = yo.create, Nx = Oh.create, jx = Ih.create, Mx = Rh.create, qx = Ph.create, Lx = Th.create, Fx = Wu.create, Ux = Zs.create, Bx = di.create, zx = Vs.create, Zx = Ks.create, tu = pi.create, Vx = kr.create, Hx = fi.create, Wx = pi.createWithPreprocess, Kx = Ku.create, Jx = nd.create, Yx = /* @__PURE__ */ C(() => qh().optional(), "ostring"), Gx = /* @__PURE__ */ C(() => Lh().optional(), "onumber"), Xx = /* @__PURE__ */ C(() => Fh().optional(), "oboolean"), Qx = ot.fromJsonSchema, e0 = ot.fromObject, t0 = {
  string: /* @__PURE__ */ C((e) => Tn.create(J(O({}, e), { coerce: !0 })), "string"),
  number: /* @__PURE__ */ C((e) => Ws.create(J(O({}, e), { coerce: !0 })), "number"),
  boolean: /* @__PURE__ */ C((e) => Us.create(J(O({}, e), {
    coerce: !0
  })), "boolean"),
  bigint: /* @__PURE__ */ C((e) => Fs.create(J(O({}, e), { coerce: !0 })), "bigint"),
  date: /* @__PURE__ */ C((e) => Zu.create(J(O({}, e), { coerce: !0 })), "date"),
  templateLiteral: /* @__PURE__ */ C((e) => nd.create(J(O({}, e), {
    coerce: !0
  })), "templateLiteral")
}, n0 = Ge, Je = En, r0 = /* @__PURE__ */ C((e, t) => e.anyOf.length ? e.anyOf.length === 1 ? bn(e.anyOf[0], J(O({}, t), {
  path: [...t.path, "anyOf", 0]
})) : `z.union([${e.anyOf.map((n, r) => bn(n, J(O({}, t), { path: [...t.path, "anyOf", r] }))).join(", ")}])` : "z.any()", "parseAnyOf"), OT = /* @__PURE__ */ C((e) => {
  var t;
  return (t = e[Et]) != null && t.coerce ? "z.coerce.boolean()" : "z.boolean()";
}, "parseBoolean"), IT = /* @__PURE__ */ C((e) => "z.any()", "parseDefault"), PT = /* @__PURE__ */ C((e, t) => `z.union([${e.type.map((n) => bn(J(O({}, e), { type: n }), t)).join(", ")}])`, "parseMultipleType"), $T = /* @__PURE__ */ C((e, t) => `z.any().refine((value) => !${bn(e.not, J(O({}, t), {
  path: [...t.path, "not"]
}))}.safeParse(value).success, "Invalid input: Should NOT be valid against schema")`, "parseNot"), DT = /* @__PURE__ */ C((e) => "z.null()", "parseNull"), NT = /* @__PURE__ */ C((e) => [e.slice(0, e.length / 2), e.slice(e.length / 2)], "half"), jT = /* @__PURE__ */ C((e, ...t) => Object.keys(e).reduce((n, r) => (t.includes(r) || (n[r] = e[r]), n), {}), "omit");
function $n(e, t, n) {
  var r;
  const i = e[t];
  let o = "";
  if (i !== void 0) {
    const a = n({ value: i, json: JSON.stringify(i) });
    if (a) {
      const s = a[0], c = a.length === 3 ? a[1] : "", l = a.length === 3 ? a[2] : a[1];
      o += s, ((r = e.errorMessage) == null ? void 0 : r[t]) !== void 0 && (o += c + JSON.stringify(e.errorMessage[t])), o += l;
    }
  }
  return o;
}
C($n, "withMessage");
var es = Symbol("Original index"), MT = /* @__PURE__ */ C((e) => {
  let t = [];
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (typeof r == "boolean")
      t.push(r ? { [es]: n } : { [es]: n, not: {} });
    else {
      if (es in r)
        return e;
      t.push(J(O({}, r), { [es]: n }));
    }
  }
  return t;
}, "ensureOriginalIndex");
function ys(e, t) {
  if (e.allOf.length === 0)
    return "z.never()";
  if (e.allOf.length === 1) {
    const n = e.allOf[0];
    return bn(n, J(O({}, t), {
      path: [...t.path, "allOf", n[es]]
    }));
  } else {
    const [n, r] = NT(MT(e.allOf));
    return `z.intersection(${ys({ allOf: n }, t)}, ${ys(
      {
        allOf: r
      },
      t
    )})`;
  }
}
C(ys, "parseAllOf");
var qT = /* @__PURE__ */ C((e, t) => {
  if (Array.isArray(e.items))
    return `z.tuple([${e.items.map((r, i) => bn(r, J(O({}, t), { path: [...t.path, "items", i] })))}])`;
  let n = e.items ? `z.array(${bn(e.items, J(O({}, t), {
    path: [...t.path, "items"]
  }))})` : "z.array(z.any())";
  return n += $n(e, "minItems", ({ json: r }) => [`.min(${r}`, ", ", ")"]), n += $n(e, "maxItems", ({ json: r }) => [`.max(${r}`, ", ", ")"]), n;
}, "parseArray"), LT = /* @__PURE__ */ C((e) => `z.literal(${JSON.stringify(e.const)})`, "parseConst"), FT = /* @__PURE__ */ C((e) => e.enum.length === 0 ? "z.never()" : e.enum.length === 1 ? `z.literal(${JSON.stringify(e.enum[0])})` : e.enum.every((t) => typeof t == "string") ? `z.enum([${e.enum.map((t) => JSON.stringify(t))}])` : `z.union([${e.enum.map((t) => `z.literal(${JSON.stringify(t)})`).join(", ")}])`, "parseEnum"), UT = /* @__PURE__ */ C((e, t) => {
  const n = bn(e.if, J(O({}, t), { path: [...t.path, "if"] })), r = bn(e.then, J(O({}, t), {
    path: [...t.path, "then"]
  })), i = bn(e.else, J(O({}, t), {
    path: [...t.path, "else"]
  }));
  return `z.union([${r}, ${i}]).superRefine((value,ctx) => {
  const result = ${n}.safeParse(value).success
    ? ${r}.safeParse(value)
    : ${i}.safeParse(value);
  if (!result.success) {
    result.error.errors.forEach((error) => ctx.addIssue(error))
  }
})`;
}, "parseIfThenElse"), BT = /* @__PURE__ */ C((e) => {
  var t;
  let n = "z.number()";
  return (t = e[Et]) != null && t.coerce && (n = "z.coerce.number()"), e.type === "integer" ? n += $n(e, "type", () => [".int(", ")"]) : n += $n(e, "format", ({ value: r }) => {
    if (r === "int64")
      return [".int(", ")"];
  }), n += $n(e, "multipleOf", ({ value: r, json: i }) => r === 1 ? n.startsWith("z.number().int(") ? void 0 : [".int(", ")"] : [`.multipleOf(${i}`, ", ", ")"]), typeof e.minimum == "number" ? e.exclusiveMinimum === !0 ? n += $n(e, "minimum", ({ json: r }) => [`.gt(${r}`, ", ", ")"]) : n += $n(e, "minimum", ({ json: r }) => [`.gte(${r}`, ", ", ")"]) : typeof e.exclusiveMinimum == "number" && (n += $n(e, "exclusiveMinimum", ({ json: r }) => [`.gt(${r}`, ", ", ")"])), typeof e.maximum == "number" ? e.exclusiveMaximum === !0 ? n += $n(e, "maximum", ({ json: r }) => [`.lt(${r}`, ", ", ")"]) : n += $n(e, "maximum", ({ json: r }) => [`.lte(${r}`, ", ", ")"]) : typeof e.exclusiveMaximum == "number" && (n += $n(e, "exclusiveMaximum", ({ json: r }) => [`.lt(${r}`, ", ", ")"])), n;
}, "parseNumber"), Uh = /* @__PURE__ */ C((e, t) => e.oneOf.length ? e.oneOf.length === 1 ? bn(e.oneOf[0], J(O({}, t), {
  path: [...t.path, "oneOf", 0]
})) : `z.any().superRefine((x, ctx) => {
    const schemas = [${e.oneOf.map(
  (n, r) => bn(n, J(O({}, t), {
    path: [...t.path, "oneOf", r]
  }))
).join(", ")}];
    const errors = schemas.reduce(
      (errors: z.ZodError[], schema) =>
        ((result) => ("error" in result ? [...errors, result.error] : errors))(
          schema.safeParse(x)
        ),
      []
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })` : "z.any()", "parseOneOf");
function i0(e, t) {
  let n;
  e.properties && (Object.keys(e.properties).length ? (n = "z.object({ ", n += Object.keys(e.properties).map((a) => {
    const s = e.properties[a], c = `${JSON.stringify(a)}: ${bn(s, J(O({}, t), {
      path: [...t.path, "properties", a]
    }))}`, l = typeof s == "object" && s.default !== void 0 || typeof e.default == "object" && e.default !== null && a in e.default, u = Array.isArray(e.required) ? e.required.includes(a) : typeof s == "object" && s.required === !0;
    return !l && !u ? `${c}.optional()` : c;
  }).join(", "), n += " })") : n = "z.object({})");
  const r = e.additionalProperties !== void 0 ? bn(e.additionalProperties, J(O({}, t), {
    path: [...t.path, "additionalProperties"]
  })) : void 0;
  let i;
  if (e.patternProperties) {
    const a = Object.fromEntries(
      Object.entries(e.patternProperties).map(([s, c]) => [
        s,
        bn(c, J(O({}, t), {
          path: [...t.path, "patternProperties", s]
        }))
      ], {})
    );
    i = "", n ? r ? i += `.catchall(z.union([${[
      ...Object.values(a),
      r
    ].join(", ")}]))` : Object.keys(a).length > 1 ? i += `.catchall(z.union([${Object.values(a).join(", ")}]))` : i += `.catchall(${Object.values(a)})` : r ? i += `z.record(z.union([${[
      ...Object.values(a),
      r
    ].join(", ")}]))` : Object.keys(a).length > 1 ? i += `z.record(z.union([${Object.values(a).join(", ")}]))` : i += `z.record(${Object.values(a)})`, i += `.superRefine((value, ctx) => {
`, i += `for (const key in value) {
`, r && (e.properties ? i += `let evaluated = [${Object.keys(e.properties).map((s) => JSON.stringify(s)).join(", ")}].includes(key)
` : i += `let evaluated = false
`);
    for (const s in e.patternProperties)
      i += "if (key.match(new RegExp(" + JSON.stringify(s) + `))) {
`, r && (i += `evaluated = true
`), i += "const result = " + a[s] + `.safeParse(value[key])
`, i += `if (!result.success) {
`, i += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: Key matching regex /\${key}/ must match schema\`,
          params: {
            issues: result.error.issues
          }
        })
`, i += `}
`, i += `}
`;
    r && (i += `if (!evaluated) {
`, i += "const result = " + r + `.safeParse(value[key])
`, i += `if (!result.success) {
`, i += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: must match catchall schema\`,
          params: {
            issues: result.error.issues
          }
        })
`, i += `}
`, i += `}
`), i += `}
`, i += "})";
  }
  let o = n ? i ? n + i : r ? r === "z.never()" ? n + ".strict()" : n + `.catchall(${r})` : n : i || (r ? `z.record(${r})` : "z.record(z.any())");
  return rn.an.anyOf(e) && (o += `.and(${r0(
    J(O({}, e), {
      anyOf: e.anyOf.map(
        (a) => typeof a == "object" && !a.type && (a.properties || a.additionalProperties || a.patternProperties) ? J(O({}, a), { type: "object" }) : a
      )
    }),
    t
  )})`), rn.a.oneOf(e) && (o += `.and(${Uh(
    J(O({}, e), {
      oneOf: e.oneOf.map(
        (a) => typeof a == "object" && !a.type && (a.properties || a.additionalProperties || a.patternProperties) ? J(O({}, a), { type: "object" }) : a
      )
    }),
    t
  )})`), rn.an.allOf(e) && (o += `.and(${ys(
    J(O({}, e), {
      allOf: e.allOf.map(
        (a) => typeof a == "object" && !a.type && (a.properties || a.additionalProperties || a.patternProperties) ? J(O({}, a), { type: "object" }) : a
      )
    }),
    t
  )})`), o;
}
C(i0, "parseObject");
var zT = /* @__PURE__ */ C((e) => {
  var t;
  let n = "z.string()";
  if ((t = e[Et]) != null && t.coerce) {
    if (e.format === "date-time")
      return "z.coerce.date()";
    n = "z.coerce.string()";
  }
  return n += $n(e, "format", ({ value: r }) => {
    switch (r) {
      case "email":
        return [".email(", ")"];
      case "ip":
        return [".ip(", ")"];
      case "ipv4":
        return ['.ip({ version: "v4"', ", message: ", " })"];
      case "ipv6":
        return ['.ip({ version: "v6"', ", message: ", " })"];
      case "uri":
        return [".url(", ")"];
      case "uuid":
        return [".uuid(", ")"];
      case "date-time":
        return [".datetime(", ")"];
    }
  }), n += $n(e, "pattern", ({ json: r }) => [`.regex(new RegExp(${r})`, ", ", ")"]), n += $n(e, "minLength", ({ json: r }) => [`.min(${r}`, ", ", ")"]), n += $n(e, "maxLength", ({ json: r }) => [`.max(${r}`, ", ", ")"]), n;
}, "parseString"), ZT = /* @__PURE__ */ C((e, t) => `${bn(jT(e, "nullable"), t, !0)}.nullable()`, "parseNullable"), VT = /* @__PURE__ */ C((e, t) => {
  var n, r;
  if (e.oneOf.length <= 1 || !((n = e.discriminator) != null && n.propertyName))
    return Uh(e, t);
  const i = e.oneOf.map(
    (o, a) => bn(o, J(O({}, t), {
      path: [...t.path, "oneOf", a]
    }))
  );
  return `z.discriminatedUnion("${(r = e.discriminator) == null ? void 0 : r.propertyName}", [${i.join(", ")}])`;
}, "parseDiscriminator"), bn = /* @__PURE__ */ C((e, t = { seen: /* @__PURE__ */ new Map(), path: [] }, n) => {
  if (typeof e != "object")
    return e ? "z.any()" : "z.never()";
  if (t.parserOverride) {
    const o = t.parserOverride(e, t);
    if (typeof o == "string")
      return o;
  }
  let r = t.seen.get(e);
  if (r) {
    if (r.r !== void 0)
      return r.r;
    if (t.depth === void 0 || r.n >= t.depth)
      return "z.any()";
    r.n += 1;
  } else
    r = { r: void 0, n: 0 }, t.seen.set(e, r);
  let i = KT(e, t);
  return n || (i = HT(e, i), t.withoutDefaults || (i = WT(e, i))), r.r = i, i;
}, "parseSchema"), HT = /* @__PURE__ */ C((e, t) => (e.description && (t += `.describe(${JSON.stringify(e.description)})`), t), "addMeta"), WT = /* @__PURE__ */ C((e, t) => (e.default !== void 0 && (t += `.default(${JSON.stringify(e.default)})`), t), "addDefaults"), KT = /* @__PURE__ */ C((e, t) => rn.a.nullable(e) ? ZT(e, t) : rn.an.object(e) ? i0(e, t) : rn.an.array(e) ? qT(e, t) : rn.an.anyOf(e) ? r0(e, t) : rn.an.allOf(e) ? ys(e, t) : rn.a.discriminator(e) ? VT(e, t) : rn.a.oneOf(e) ? Uh(e, t) : rn.a.not(e) ? $T(e, t) : rn.an.enum(e) ? FT(e) : rn.a.const(e) ? LT(e) : rn.a.multipleType(e) ? PT(e, t) : rn.a.primitive(e, "string") ? zT(e) : rn.a.primitive(e, "number") || rn.a.primitive(e, "integer") ? BT(e) : rn.a.primitive(e, "boolean") ? OT(e) : rn.a.primitive(e, "null") ? DT(e) : rn.a.conditional(e) ? UT(e, t) : IT(e), "selectParser"), rn = {
  an: {
    object: /* @__PURE__ */ C((e) => e.type === "object", "object"),
    array: /* @__PURE__ */ C((e) => e.type === "array", "array"),
    anyOf: /* @__PURE__ */ C((e) => e.anyOf !== void 0, "anyOf"),
    allOf: /* @__PURE__ */ C((e) => e.allOf !== void 0, "allOf"),
    enum: /* @__PURE__ */ C((e) => e.enum !== void 0, "enum")
  },
  a: {
    nullable: /* @__PURE__ */ C((e) => e.nullable === !0, "nullable"),
    multipleType: /* @__PURE__ */ C((e) => Array.isArray(e.type), "multipleType"),
    not: /* @__PURE__ */ C((e) => e.not !== void 0, "not"),
    const: /* @__PURE__ */ C((e) => e.const !== void 0, "const"),
    primitive: /* @__PURE__ */ C((e, t) => e.type === t, "primitive"),
    conditional: /* @__PURE__ */ C((e) => !!("if" in e && e.if && "then" in e && "else" in e && e.then && e.else), "conditional"),
    discriminator: /* @__PURE__ */ C((e) => {
      var t;
      return e.oneOf !== void 0 && ((t = e.discriminator) == null ? void 0 : t.propertyName) !== void 0;
    }, "discriminator"),
    oneOf: /* @__PURE__ */ C((e) => e.oneOf !== void 0, "oneOf")
  }
}, JT = /* @__PURE__ */ C((e) => bn(e, {
  seen: /* @__PURE__ */ new Map(),
  path: []
}), "jsonSchemaToZodStr"), YT = /* @__PURE__ */ C((e) => {
  let t = JT(e);
  return t = t.replaceAll("errors: z.ZodError[]", "errors"), new Function("z", `return ${t}`)(En);
}, "jsonSchemaToZod"), ts = /* @__PURE__ */ C((e, t) => {
  var n, r;
  if (t[Et] && e._def && (e._def[Et] = t[Et]), ((n = e._def) == null ? void 0 : n.typeName) === "ZodObject" && t.type === "object" && t.properties && Object.entries(t.properties).forEach(([i, o]) => {
    const a = typeof e._def.shape == "function" ? e._def.shape() : e._def.shape;
    a[i] && ts(a[i], o);
  }), ((r = e._def) == null ? void 0 : r.typeName) === "ZodRecord" && t.type === "object" && t.additionalProperties && ts(e._def.valueType, t.additionalProperties), t.type === "array" && t.items) {
    const i = t.items;
    if (typeof i == "object" && !Array.isArray(i)) {
      const o = e._def.type;
      o && ts(o, i);
    } else
      Array.isArray(i) && i.forEach((o, a) => {
        const s = e._def;
        s.typeName === En.ZodFirstPartyTypeKind.ZodTuple && ts(s.items[a], o);
      });
  }
}, "applyZuiPropsRecursively"), Gs = /* @__PURE__ */ C((e) => {
  const t = YT(e);
  return ts(t, e), t;
}, "jsonSchemaToZui"), No = Bu(Xt, 1), nu = Bu(Xt, 1), o0 = class extends nu.Component {
  constructor() {
    super(...arguments), this.state = {
      hasError: !1,
      error: null
    };
  }
  static getDerivedStateFromError(t) {
    return { hasError: !0, error: t };
  }
  componentDidCatch(t, n) {
    console.error("Uncaught error:", t, n);
  }
  render() {
    return this.state.hasError && this.props.fallback ? /* @__PURE__ */ nu.default.createElement(this.props.fallback, { error: this.state.error, schema: this.props.fieldSchema }) : this.props.children;
  }
};
C(o0, "ErrorBoundary");
var Qo = o0;
function a0(e, t) {
  return (n) => /* @__PURE__ */ nu.default.createElement(Qo, { fallback: t, fieldSchema: n.fieldSchema, path: n.path }, /* @__PURE__ */ nu.default.createElement(e, O({}, n)));
}
C(a0, "withErrorBoundary");
var fr = Bu(Xt, 1), Vc = /* @__PURE__ */ C((e) => {
  var t = e, {
    components: n,
    fieldSchema: r,
    path: i,
    required: o,
    fallback: a
  } = t, s = Mb(t, [
    "components",
    "fieldSchema",
    "path",
    "required",
    "fallback"
  ]), c, l;
  const { formData: u, disabled: d, hidden: p, handlePropertyChange: f, addArrayItem: h, removeArrayItem: m, formErrors: y, formValid: g } = Bb(r, i), v = (0, fr.useMemo)(() => ro(u, i), [u, i]), b = (0, fr.useMemo)(() => aT(n, r), [r, n]), { discriminator: _, discriminatedSchema: S, discriminatorValue: x } = rT(r, i);
  if (!b || p === !0)
    return null;
  const { Component: A, type: I } = b, P = {
    type: I,
    componentID: b.id,
    scope: i.join("."),
    context: {
      path: i,
      readonly: !1,
      formData: u,
      formErrors: y,
      formValid: g,
      updateForm: f,
      updateFormData: /* @__PURE__ */ C((V) => f([], V), "updateFormData")
    },
    onChange: /* @__PURE__ */ C((V) => f(i, V), "onChange"),
    disabled: d,
    errors: (y == null ? void 0 : y.filter((V) => V.path === i)) || [],
    label: ((c = r[Et]) == null ? void 0 : c.title) || op(((l = i[i.length - 1]) == null ? void 0 : l.toString()) || ""),
    params: b.params,
    schema: r,
    zuiProps: r[Et]
  };
  if (r.type === "array" && I === "array") {
    const V = A, U = P.schema, L = Array.isArray(v) || typeof v == "object" ? v : [], $ = O(J(O({}, P), {
      type: I,
      schema: U,
      data: L,
      addItem: /* @__PURE__ */ C((j) => h(i, j), "addItem"),
      removeItem: /* @__PURE__ */ C((j) => m(i, j), "removeItem")
    }), s);
    return Array.isArray(r.items) ? null : /* @__PURE__ */ fr.default.createElement(V, J(O({ key: P.scope }, $), { isArrayChild: $.isArrayChild }), Array.isArray($.data) ? $.data.map((j, z) => {
      const H = [...i, z.toString()];
      return /* @__PURE__ */ fr.default.createElement(
        Qo,
        {
          key: H.join("."),
          fallback: a,
          fieldSchema: r.items,
          path: H
        },
        /* @__PURE__ */ fr.default.createElement(
          Vc,
          {
            key: H.join("."),
            components: n,
            fieldSchema: r.items,
            path: H,
            required: o,
            isArrayChild: !0,
            index: z,
            removeSelf: () => m(i, z),
            fallback: a
          }
        )
      );
    }) : []);
  }
  if (r.type === "object" && I === "object" && r.properties) {
    const V = A, U = O(J(O({}, P), {
      type: I,
      schema: P.schema,
      data: v || {}
    }), s);
    return /* @__PURE__ */ fr.default.createElement(V, J(O({ key: P.scope }, U), { isArrayChild: U.isArrayChild }), Object.entries(r.properties).map(([L, $]) => {
      var j;
      const z = [...i, L];
      return /* @__PURE__ */ fr.default.createElement(Qo, { key: z.join("."), fallback: a, fieldSchema: $, path: z }, /* @__PURE__ */ fr.default.createElement(
        Vc,
        {
          key: z.join("."),
          components: n,
          fieldSchema: $,
          path: z,
          required: ((j = r.required) == null ? void 0 : j.includes(L)) || !1,
          isArrayChild: !1,
          fallback: a
        }
      ));
    }));
  }
  if (I === "discriminatedUnion") {
    const V = A, U = O(J(O({}, P), {
      type: I,
      schema: P.schema,
      data: v || {},
      discriminatorKey: (_ == null ? void 0 : _.key) || null,
      discriminatorLabel: op((_ == null ? void 0 : _.key) || "Unknown"),
      discriminatorOptions: (_ == null ? void 0 : _.values) || null,
      discriminatorValue: x,
      setDiscriminator: /* @__PURE__ */ C((L) => {
        if (!(_ != null && _.key)) {
          console.warn("No discriminator key found, cannot set discriminator");
          return;
        }
        f(i, { [_.key]: L });
      }, "setDiscriminator")
    }), s);
    return /* @__PURE__ */ fr.default.createElement(V, J(O({ key: P.scope }, U), { isArrayChild: U.isArrayChild }), S && /* @__PURE__ */ fr.default.createElement(Qo, { key: i.join("."), fallback: a, fieldSchema: S, path: i }, /* @__PURE__ */ fr.default.createElement(
      Vc,
      {
        components: n,
        fieldSchema: S,
        path: i,
        required: o,
        isArrayChild: !1,
        fallback: a
      }
    )));
  }
  const R = A, M = O(J(O({}, P), {
    type: I,
    schema: P.schema,
    config: {},
    required: o,
    data: v,
    description: r.description
  }), s);
  return /* @__PURE__ */ fr.default.createElement(R, O({}, M));
}, "FormElementRenderer"), GT = /* @__PURE__ */ C(({
  schema: e,
  components: t,
  onChange: n,
  value: r,
  disableValidation: i,
  fallback: o,
  dataTransform: a,
  onValidation: s
}) => {
  const [c, l] = (0, No.useState)(r);
  return (0, No.useEffect)(() => {
    n(c);
  }, [c]), (0, No.useEffect)(() => {
    const u = Ko(e);
    l((d) => ml(u, d));
  }, [JSON.stringify(e), l]), /* @__PURE__ */ No.default.createElement(
    nT,
    {
      formData: c,
      setFormData: l,
      formSchema: e,
      disableValidation: i || !1,
      dataTransform: a,
      onValidation: s
    },
    /* @__PURE__ */ No.default.createElement(Qo, { fallback: o, fieldSchema: e, path: [] }, /* @__PURE__ */ No.default.createElement(
      Vc,
      {
        components: t,
        fieldSchema: e,
        path: [],
        fallback: o,
        required: !0,
        isArrayChild: !1
      }
    ))
  );
}, "ZuiForm"), XT = {
  string: {},
  number: {
    slider: {
      id: "slider",
      params: Je.object({})
    }
  },
  boolean: {
    switch: {
      id: "switch",
      params: Je.object({})
    }
  },
  array: {},
  object: {},
  discriminatedUnion: {}
}, QT = {
  jsonSchemaToZui: Gs,
  zuiToJsonSchema: rd,
  objectToZui: fa,
  toTypescript: gl
};
const Bh = {}, eR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Bh
}, Symbol.toStringTag, { value: "Module" })), fp = /* @__PURE__ */ vh(eR);
function s0(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: tR } = Object.prototype, { getPrototypeOf: zh } = Object, id = ((e) => (t) => {
  const n = tR.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Pr = (e) => (e = e.toLowerCase(), (t) => id(t) === e), od = (e) => (t) => typeof t === e, { isArray: Ia } = Array, gs = od("undefined");
function nR(e) {
  return e !== null && !gs(e) && e.constructor !== null && !gs(e.constructor) && mr(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const c0 = Pr("ArrayBuffer");
function rR(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && c0(e.buffer), t;
}
const iR = od("string"), mr = od("function"), l0 = od("number"), ad = (e) => e !== null && typeof e == "object", oR = (e) => e === !0 || e === !1, Hc = (e) => {
  if (id(e) !== "object")
    return !1;
  const t = zh(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, aR = Pr("Date"), sR = Pr("File"), cR = Pr("Blob"), lR = Pr("FileList"), uR = (e) => ad(e) && mr(e.pipe), dR = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || mr(e.append) && ((t = id(e)) === "formdata" || // detect form-data instance
  t === "object" && mr(e.toString) && e.toString() === "[object FormData]"));
}, fR = Pr("URLSearchParams"), [pR, hR, mR, yR] = ["ReadableStream", "Request", "Response", "Headers"].map(Pr), gR = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Xs(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), Ia(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e), a = o.length;
    let s;
    for (r = 0; r < a; r++)
      s = o[r], t.call(null, e[s], s, e);
  }
}
function u0(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const d0 = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), f0 = (e) => !gs(e) && e !== d0;
function pp() {
  const { caseless: e } = f0(this) && this || {}, t = {}, n = (r, i) => {
    const o = e && u0(t, i) || i;
    Hc(t[o]) && Hc(r) ? t[o] = pp(t[o], r) : Hc(r) ? t[o] = pp({}, r) : Ia(r) ? t[o] = r.slice() : t[o] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && Xs(arguments[r], n);
  return t;
}
const vR = (e, t, n, { allOwnKeys: r } = {}) => (Xs(t, (i, o) => {
  n && mr(i) ? e[o] = s0(i, n) : e[o] = i;
}, { allOwnKeys: r }), e), bR = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), wR = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, xR = (e, t, n, r) => {
  let i, o, a;
  const s = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (i = Object.getOwnPropertyNames(e), o = i.length; o-- > 0; )
      a = i[o], (!r || r(a, e, t)) && !s[a] && (t[a] = e[a], s[a] = !0);
    e = n !== !1 && zh(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, _R = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, SR = (e) => {
  if (!e)
    return null;
  if (Ia(e))
    return e;
  let t = e.length;
  if (!l0(t))
    return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, kR = ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && zh(Uint8Array)), ER = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const o = i.value;
    t.call(e, o[0], o[1]);
  }
}, CR = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, TR = Pr("HTMLFormElement"), RR = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), Iy = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), AR = Pr("RegExp"), p0 = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  Xs(n, (i, o) => {
    let a;
    (a = t(i, o, e)) !== !1 && (r[o] = a || i);
  }), Object.defineProperties(e, r);
}, OR = (e) => {
  p0(e, (t, n) => {
    if (mr(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (mr(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, IR = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((o) => {
      n[o] = !0;
    });
  };
  return Ia(e) ? r(e) : r(String(e).split(t)), n;
}, PR = () => {
}, $R = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, nf = "abcdefghijklmnopqrstuvwxyz", Py = "0123456789", h0 = {
  DIGIT: Py,
  ALPHA: nf,
  ALPHA_DIGIT: nf + nf.toUpperCase() + Py
}, DR = (e = 16, t = h0.ALPHA_DIGIT) => {
  let n = "";
  const { length: r } = t;
  for (; e--; )
    n += t[Math.random() * r | 0];
  return n;
};
function NR(e) {
  return !!(e && mr(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const jR = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (ad(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const o = Ia(r) ? [] : {};
        return Xs(r, (a, s) => {
          const c = n(a, i + 1);
          !gs(c) && (o[s] = c);
        }), t[i] = void 0, o;
      }
    }
    return r;
  };
  return n(e, 0);
}, MR = Pr("AsyncFunction"), qR = (e) => e && (ad(e) || mr(e)) && mr(e.then) && mr(e.catch), Q = {
  isArray: Ia,
  isArrayBuffer: c0,
  isBuffer: nR,
  isFormData: dR,
  isArrayBufferView: rR,
  isString: iR,
  isNumber: l0,
  isBoolean: oR,
  isObject: ad,
  isPlainObject: Hc,
  isReadableStream: pR,
  isRequest: hR,
  isResponse: mR,
  isHeaders: yR,
  isUndefined: gs,
  isDate: aR,
  isFile: sR,
  isBlob: cR,
  isRegExp: AR,
  isFunction: mr,
  isStream: uR,
  isURLSearchParams: fR,
  isTypedArray: kR,
  isFileList: lR,
  forEach: Xs,
  merge: pp,
  extend: vR,
  trim: gR,
  stripBOM: bR,
  inherits: wR,
  toFlatObject: xR,
  kindOf: id,
  kindOfTest: Pr,
  endsWith: _R,
  toArray: SR,
  forEachEntry: ER,
  matchAll: CR,
  isHTMLForm: TR,
  hasOwnProperty: Iy,
  hasOwnProp: Iy,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: p0,
  freezeMethods: OR,
  toObjectSet: IR,
  toCamelCase: RR,
  noop: PR,
  toFiniteNumber: $R,
  findKey: u0,
  global: d0,
  isContextDefined: f0,
  ALPHABET: h0,
  generateString: DR,
  isSpecCompliantForm: NR,
  toJSONObject: jR,
  isAsyncFn: MR,
  isThenable: qR
};
function dt(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i);
}
Q.inherits(dt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Q.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const m0 = dt.prototype, y0 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  y0[e] = { value: e };
});
Object.defineProperties(dt, y0);
Object.defineProperty(m0, "isAxiosError", { value: !0 });
dt.from = (e, t, n, r, i, o) => {
  const a = Object.create(m0);
  return Q.toFlatObject(e, a, function(c) {
    return c !== Error.prototype;
  }, (s) => s !== "isAxiosError"), dt.call(a, e.message, t, n, r, i), a.cause = e, a.name = e.name, o && Object.assign(a, o), a;
};
const LR = null;
function hp(e) {
  return Q.isPlainObject(e) || Q.isArray(e);
}
function g0(e) {
  return Q.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function $y(e, t, n) {
  return e ? e.concat(t).map(function(i, o) {
    return i = g0(i), !n && o ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function FR(e) {
  return Q.isArray(e) && !e.some(hp);
}
const UR = Q.toFlatObject(Q, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function sd(e, t, n) {
  if (!Q.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = Q.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(m, y) {
    return !Q.isUndefined(y[m]);
  });
  const r = n.metaTokens, i = n.visitor || u, o = n.dots, a = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && Q.isSpecCompliantForm(t);
  if (!Q.isFunction(i))
    throw new TypeError("visitor must be a function");
  function l(h) {
    if (h === null)
      return "";
    if (Q.isDate(h))
      return h.toISOString();
    if (!c && Q.isBlob(h))
      throw new dt("Blob is not supported. Use a Buffer instead.");
    return Q.isArrayBuffer(h) || Q.isTypedArray(h) ? c && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
  }
  function u(h, m, y) {
    let g = h;
    if (h && !y && typeof h == "object") {
      if (Q.endsWith(m, "{}"))
        m = r ? m : m.slice(0, -2), h = JSON.stringify(h);
      else if (Q.isArray(h) && FR(h) || (Q.isFileList(h) || Q.endsWith(m, "[]")) && (g = Q.toArray(h)))
        return m = g0(m), g.forEach(function(b, _) {
          !(Q.isUndefined(b) || b === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            a === !0 ? $y([m], _, o) : a === null ? m : m + "[]",
            l(b)
          );
        }), !1;
    }
    return hp(h) ? !0 : (t.append($y(y, m, o), l(h)), !1);
  }
  const d = [], p = Object.assign(UR, {
    defaultVisitor: u,
    convertValue: l,
    isVisitable: hp
  });
  function f(h, m) {
    if (!Q.isUndefined(h)) {
      if (d.indexOf(h) !== -1)
        throw Error("Circular reference detected in " + m.join("."));
      d.push(h), Q.forEach(h, function(g, v) {
        (!(Q.isUndefined(g) || g === null) && i.call(
          t,
          g,
          Q.isString(v) ? v.trim() : v,
          m,
          p
        )) === !0 && f(g, m ? m.concat(v) : [v]);
      }), d.pop();
    }
  }
  if (!Q.isObject(e))
    throw new TypeError("data must be an object");
  return f(e), t;
}
function Dy(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function Zh(e, t) {
  this._pairs = [], e && sd(e, this, t);
}
const v0 = Zh.prototype;
v0.append = function(t, n) {
  this._pairs.push([t, n]);
};
v0.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, Dy);
  } : Dy;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function BR(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function b0(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || BR, i = n && n.serialize;
  let o;
  if (i ? o = i(t, n) : o = Q.isURLSearchParams(t) ? t.toString() : new Zh(t, n).toString(r), o) {
    const a = e.indexOf("#");
    a !== -1 && (e = e.slice(0, a)), e += (e.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return e;
}
let zR = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    Q.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
};
const Ny = zR, w0 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, ZR = typeof URLSearchParams < "u" ? URLSearchParams : Zh, VR = typeof FormData < "u" ? FormData : null, HR = typeof Blob < "u" ? Blob : null, WR = {
  isBrowser: !0,
  classes: {
    URLSearchParams: ZR,
    FormData: VR,
    Blob: HR
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Vh = typeof window < "u" && typeof document < "u", KR = ((e) => Vh && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product), JR = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), YR = Vh && window.location.href || "http://localhost", GR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Vh,
  hasStandardBrowserEnv: KR,
  hasStandardBrowserWebWorkerEnv: JR,
  origin: YR
}, Symbol.toStringTag, { value: "Module" })), Er = {
  ...GR,
  ...WR
};
function XR(e, t) {
  return sd(e, new Er.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, o) {
      return Er.isNode && Q.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function QR(e) {
  return Q.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function eA(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let o;
  for (r = 0; r < i; r++)
    o = n[r], t[o] = e[o];
  return t;
}
function x0(e) {
  function t(n, r, i, o) {
    let a = n[o++];
    if (a === "__proto__")
      return !0;
    const s = Number.isFinite(+a), c = o >= n.length;
    return a = !a && Q.isArray(i) ? i.length : a, c ? (Q.hasOwnProp(i, a) ? i[a] = [i[a], r] : i[a] = r, !s) : ((!i[a] || !Q.isObject(i[a])) && (i[a] = []), t(n, r, i[a], o) && Q.isArray(i[a]) && (i[a] = eA(i[a])), !s);
  }
  if (Q.isFormData(e) && Q.isFunction(e.entries)) {
    const n = {};
    return Q.forEachEntry(e, (r, i) => {
      t(QR(r), i, n, 0);
    }), n;
  }
  return null;
}
function tA(e, t, n) {
  if (Q.isString(e))
    try {
      return (t || JSON.parse)(e), Q.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const Hh = {
  transitional: w0,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, o = Q.isObject(t);
    if (o && Q.isHTMLForm(t) && (t = new FormData(t)), Q.isFormData(t))
      return i ? JSON.stringify(x0(t)) : t;
    if (Q.isArrayBuffer(t) || Q.isBuffer(t) || Q.isStream(t) || Q.isFile(t) || Q.isBlob(t) || Q.isReadableStream(t))
      return t;
    if (Q.isArrayBufferView(t))
      return t.buffer;
    if (Q.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let s;
    if (o) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return XR(t, this.formSerializer).toString();
      if ((s = Q.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return sd(
          s ? { "files[]": t } : t,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return o || i ? (n.setContentType("application/json", !1), tA(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || Hh.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (Q.isResponse(t) || Q.isReadableStream(t))
      return t;
    if (t && Q.isString(t) && (r && !this.responseType || i)) {
      const a = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (s) {
        if (a)
          throw s.name === "SyntaxError" ? dt.from(s, dt.ERR_BAD_RESPONSE, this, null, this.response) : s;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Er.classes.FormData,
    Blob: Er.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Q.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Hh.headers[e] = {};
});
const Wh = Hh, nA = Q.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), rA = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(a) {
    i = a.indexOf(":"), n = a.substring(0, i).trim().toLowerCase(), r = a.substring(i + 1).trim(), !(!n || t[n] && nA[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, jy = Symbol("internals");
function Ba(e) {
  return e && String(e).trim().toLowerCase();
}
function Wc(e) {
  return e === !1 || e == null ? e : Q.isArray(e) ? e.map(Wc) : String(e);
}
function iA(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const oA = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function rf(e, t, n, r, i) {
  if (Q.isFunction(r))
    return r.call(this, t, n);
  if (i && (t = n), !!Q.isString(t)) {
    if (Q.isString(r))
      return t.indexOf(r) !== -1;
    if (Q.isRegExp(r))
      return r.test(t);
  }
}
function aA(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function sA(e, t) {
  const n = Q.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, o, a) {
        return this[r].call(this, t, i, o, a);
      },
      configurable: !0
    });
  });
}
let cd = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function o(s, c, l) {
      const u = Ba(c);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const d = Q.findKey(i, u);
      (!d || i[d] === void 0 || l === !0 || l === void 0 && i[d] !== !1) && (i[d || c] = Wc(s));
    }
    const a = (s, c) => Q.forEach(s, (l, u) => o(l, u, c));
    if (Q.isPlainObject(t) || t instanceof this.constructor)
      a(t, n);
    else if (Q.isString(t) && (t = t.trim()) && !oA(t))
      a(rA(t), n);
    else if (Q.isHeaders(t))
      for (const [s, c] of t.entries())
        o(c, s, r);
    else
      t != null && o(n, t, r);
    return this;
  }
  get(t, n) {
    if (t = Ba(t), t) {
      const r = Q.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return iA(i);
        if (Q.isFunction(n))
          return n.call(this, i, r);
        if (Q.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = Ba(t), t) {
      const r = Q.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || rf(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function o(a) {
      if (a = Ba(a), a) {
        const s = Q.findKey(r, a);
        s && (!n || rf(r, r[s], s, n)) && (delete r[s], i = !0);
      }
    }
    return Q.isArray(t) ? t.forEach(o) : o(t), i;
  }
  clear(t) {
    const n = Object.keys(this);
    let r = n.length, i = !1;
    for (; r--; ) {
      const o = n[r];
      (!t || rf(this, this[o], o, t, !0)) && (delete this[o], i = !0);
    }
    return i;
  }
  normalize(t) {
    const n = this, r = {};
    return Q.forEach(this, (i, o) => {
      const a = Q.findKey(r, o);
      if (a) {
        n[a] = Wc(i), delete n[o];
        return;
      }
      const s = t ? aA(o) : String(o).trim();
      s !== o && delete n[o], n[s] = Wc(i), r[s] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return Q.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && Q.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[jy] = this[jy] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function o(a) {
      const s = Ba(a);
      r[s] || (sA(i, a), r[s] = !0);
    }
    return Q.isArray(t) ? t.forEach(o) : o(t), this;
  }
};
cd.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Q.reduceDescriptors(cd.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
Q.freezeMethods(cd);
const Cr = cd;
function of(e, t) {
  const n = this || Wh, r = t || n, i = Cr.from(r.headers);
  let o = r.data;
  return Q.forEach(e, function(s) {
    o = s.call(n, o, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), o;
}
function _0(e) {
  return !!(e && e.__CANCEL__);
}
function Pa(e, t, n) {
  dt.call(this, e ?? "canceled", dt.ERR_CANCELED, t, n), this.name = "CanceledError";
}
Q.inherits(Pa, dt, {
  __CANCEL__: !0
});
function S0(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new dt(
    "Request failed with status code " + n.status,
    [dt.ERR_BAD_REQUEST, dt.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function cA(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function lA(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, o = 0, a;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const l = Date.now(), u = r[o];
    a || (a = l), n[i] = c, r[i] = l;
    let d = o, p = 0;
    for (; d !== i; )
      p += n[d++], d = d % e;
    if (i = (i + 1) % e, i === o && (o = (o + 1) % e), l - a < t)
      return;
    const f = u && l - u;
    return f ? Math.round(p * 1e3 / f) : void 0;
  };
}
function uA(e, t) {
  let n = 0;
  const r = 1e3 / t;
  let i = null;
  return function() {
    const a = this === !0, s = Date.now();
    if (a || s - n > r)
      return i && (clearTimeout(i), i = null), n = s, e.apply(null, arguments);
    i || (i = setTimeout(() => (i = null, n = Date.now(), e.apply(null, arguments)), r - (s - n)));
  };
}
const ru = (e, t, n = 3) => {
  let r = 0;
  const i = lA(50, 250);
  return uA((o) => {
    const a = o.loaded, s = o.lengthComputable ? o.total : void 0, c = a - r, l = i(c), u = a <= s;
    r = a;
    const d = {
      loaded: a,
      total: s,
      progress: s ? a / s : void 0,
      bytes: c,
      rate: l || void 0,
      estimated: l && s && u ? (s - a) / l : void 0,
      event: o,
      lengthComputable: s != null
    };
    d[t ? "download" : "upload"] = !0, e(d);
  }, n);
}, dA = Er.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a");
    let r;
    function i(o) {
      let a = o;
      return t && (n.setAttribute("href", a), a = n.href), n.setAttribute("href", a), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return r = i(window.location.href), function(a) {
      const s = Q.isString(a) ? i(a) : a;
      return s.protocol === r.protocol && s.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return !0;
    };
  }()
), fA = Er.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, i, o) {
      const a = [e + "=" + encodeURIComponent(t)];
      Q.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()), Q.isString(r) && a.push("path=" + r), Q.isString(i) && a.push("domain=" + i), o === !0 && a.push("secure"), document.cookie = a.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function pA(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function hA(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function k0(e, t) {
  return e && !pA(t) ? hA(e, t) : t;
}
const My = (e) => e instanceof Cr ? { ...e } : e;
function go(e, t) {
  t = t || {};
  const n = {};
  function r(l, u, d) {
    return Q.isPlainObject(l) && Q.isPlainObject(u) ? Q.merge.call({ caseless: d }, l, u) : Q.isPlainObject(u) ? Q.merge({}, u) : Q.isArray(u) ? u.slice() : u;
  }
  function i(l, u, d) {
    if (Q.isUndefined(u)) {
      if (!Q.isUndefined(l))
        return r(void 0, l, d);
    } else
      return r(l, u, d);
  }
  function o(l, u) {
    if (!Q.isUndefined(u))
      return r(void 0, u);
  }
  function a(l, u) {
    if (Q.isUndefined(u)) {
      if (!Q.isUndefined(l))
        return r(void 0, l);
    } else
      return r(void 0, u);
  }
  function s(l, u, d) {
    if (d in t)
      return r(l, u);
    if (d in e)
      return r(void 0, l);
  }
  const c = {
    url: o,
    method: o,
    data: o,
    baseURL: a,
    transformRequest: a,
    transformResponse: a,
    paramsSerializer: a,
    timeout: a,
    timeoutMessage: a,
    withCredentials: a,
    withXSRFToken: a,
    adapter: a,
    responseType: a,
    xsrfCookieName: a,
    xsrfHeaderName: a,
    onUploadProgress: a,
    onDownloadProgress: a,
    decompress: a,
    maxContentLength: a,
    maxBodyLength: a,
    beforeRedirect: a,
    transport: a,
    httpAgent: a,
    httpsAgent: a,
    cancelToken: a,
    socketPath: a,
    responseEncoding: a,
    validateStatus: s,
    headers: (l, u) => i(My(l), My(u), !0)
  };
  return Q.forEach(Object.keys(Object.assign({}, e, t)), function(u) {
    const d = c[u] || i, p = d(e[u], t[u], u);
    Q.isUndefined(p) && d !== s || (n[u] = p);
  }), n;
}
const E0 = (e) => {
  const t = go({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: o, headers: a, auth: s } = t;
  t.headers = a = Cr.from(a), t.url = b0(k0(t.baseURL, t.url), e.params, e.paramsSerializer), s && a.set(
    "Authorization",
    "Basic " + btoa((s.username || "") + ":" + (s.password ? unescape(encodeURIComponent(s.password)) : ""))
  );
  let c;
  if (Q.isFormData(n)) {
    if (Er.hasStandardBrowserEnv || Er.hasStandardBrowserWebWorkerEnv)
      a.setContentType(void 0);
    else if ((c = a.getContentType()) !== !1) {
      const [l, ...u] = c ? c.split(";").map((d) => d.trim()).filter(Boolean) : [];
      a.setContentType([l || "multipart/form-data", ...u].join("; "));
    }
  }
  if (Er.hasStandardBrowserEnv && (r && Q.isFunction(r) && (r = r(t)), r || r !== !1 && dA(t.url))) {
    const l = i && o && fA.read(o);
    l && a.set(i, l);
  }
  return t;
}, mA = typeof XMLHttpRequest < "u", yA = mA && function(e) {
  return new Promise(function(n, r) {
    const i = E0(e);
    let o = i.data;
    const a = Cr.from(i.headers).normalize();
    let { responseType: s } = i, c;
    function l() {
      i.cancelToken && i.cancelToken.unsubscribe(c), i.signal && i.signal.removeEventListener("abort", c);
    }
    let u = new XMLHttpRequest();
    u.open(i.method.toUpperCase(), i.url, !0), u.timeout = i.timeout;
    function d() {
      if (!u)
        return;
      const f = Cr.from(
        "getAllResponseHeaders" in u && u.getAllResponseHeaders()
      ), m = {
        data: !s || s === "text" || s === "json" ? u.responseText : u.response,
        status: u.status,
        statusText: u.statusText,
        headers: f,
        config: e,
        request: u
      };
      S0(function(g) {
        n(g), l();
      }, function(g) {
        r(g), l();
      }, m), u = null;
    }
    "onloadend" in u ? u.onloadend = d : u.onreadystatechange = function() {
      !u || u.readyState !== 4 || u.status === 0 && !(u.responseURL && u.responseURL.indexOf("file:") === 0) || setTimeout(d);
    }, u.onabort = function() {
      u && (r(new dt("Request aborted", dt.ECONNABORTED, i, u)), u = null);
    }, u.onerror = function() {
      r(new dt("Network Error", dt.ERR_NETWORK, i, u)), u = null;
    }, u.ontimeout = function() {
      let h = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const m = i.transitional || w0;
      i.timeoutErrorMessage && (h = i.timeoutErrorMessage), r(new dt(
        h,
        m.clarifyTimeoutError ? dt.ETIMEDOUT : dt.ECONNABORTED,
        i,
        u
      )), u = null;
    }, o === void 0 && a.setContentType(null), "setRequestHeader" in u && Q.forEach(a.toJSON(), function(h, m) {
      u.setRequestHeader(m, h);
    }), Q.isUndefined(i.withCredentials) || (u.withCredentials = !!i.withCredentials), s && s !== "json" && (u.responseType = i.responseType), typeof i.onDownloadProgress == "function" && u.addEventListener("progress", ru(i.onDownloadProgress, !0)), typeof i.onUploadProgress == "function" && u.upload && u.upload.addEventListener("progress", ru(i.onUploadProgress)), (i.cancelToken || i.signal) && (c = (f) => {
      u && (r(!f || f.type ? new Pa(null, e, u) : f), u.abort(), u = null);
    }, i.cancelToken && i.cancelToken.subscribe(c), i.signal && (i.signal.aborted ? c() : i.signal.addEventListener("abort", c)));
    const p = cA(i.url);
    if (p && Er.protocols.indexOf(p) === -1) {
      r(new dt("Unsupported protocol " + p + ":", dt.ERR_BAD_REQUEST, e));
      return;
    }
    u.send(o || null);
  });
}, gA = (e, t) => {
  let n = new AbortController(), r;
  const i = function(c) {
    if (!r) {
      r = !0, a();
      const l = c instanceof Error ? c : this.reason;
      n.abort(l instanceof dt ? l : new Pa(l instanceof Error ? l.message : l));
    }
  };
  let o = t && setTimeout(() => {
    i(new dt(`timeout ${t} of ms exceeded`, dt.ETIMEDOUT));
  }, t);
  const a = () => {
    e && (o && clearTimeout(o), o = null, e.forEach((c) => {
      c && (c.removeEventListener ? c.removeEventListener("abort", i) : c.unsubscribe(i));
    }), e = null);
  };
  e.forEach((c) => c && c.addEventListener && c.addEventListener("abort", i));
  const { signal: s } = n;
  return s.unsubscribe = a, [s, () => {
    o && clearTimeout(o), o = null;
  }];
}, vA = gA, bA = function* (e, t) {
  let n = e.byteLength;
  if (!t || n < t) {
    yield e;
    return;
  }
  let r = 0, i;
  for (; r < n; )
    i = r + t, yield e.slice(r, i), r = i;
}, wA = async function* (e, t, n) {
  for await (const r of e)
    yield* bA(ArrayBuffer.isView(r) ? r : await n(String(r)), t);
}, qy = (e, t, n, r, i) => {
  const o = wA(e, t, i);
  let a = 0;
  return new ReadableStream({
    type: "bytes",
    async pull(s) {
      const { done: c, value: l } = await o.next();
      if (c) {
        s.close(), r();
        return;
      }
      let u = l.byteLength;
      n && n(a += u), s.enqueue(new Uint8Array(l));
    },
    cancel(s) {
      return r(s), o.return();
    }
  }, {
    highWaterMark: 2
  });
}, Ly = (e, t) => {
  const n = e != null;
  return (r) => setTimeout(() => t({
    lengthComputable: n,
    total: e,
    loaded: r
  }));
}, ld = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", C0 = ld && typeof ReadableStream == "function", mp = ld && (typeof TextEncoder == "function" ? ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), xA = C0 && (() => {
  let e = !1;
  const t = new Request(Er.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
})(), Fy = 64 * 1024, yp = C0 && !!(() => {
  try {
    return Q.isReadableStream(new Response("").body);
  } catch {
  }
})(), iu = {
  stream: yp && ((e) => e.body)
};
ld && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !iu[t] && (iu[t] = Q.isFunction(e[t]) ? (n) => n[t]() : (n, r) => {
      throw new dt(`Response type '${t}' is not supported`, dt.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const _A = async (e) => {
  if (e == null)
    return 0;
  if (Q.isBlob(e))
    return e.size;
  if (Q.isSpecCompliantForm(e))
    return (await new Request(e).arrayBuffer()).byteLength;
  if (Q.isArrayBufferView(e))
    return e.byteLength;
  if (Q.isURLSearchParams(e) && (e = e + ""), Q.isString(e))
    return (await mp(e)).byteLength;
}, SA = async (e, t) => {
  const n = Q.toFiniteNumber(e.getContentLength());
  return n ?? _A(t);
}, kA = ld && (async (e) => {
  let {
    url: t,
    method: n,
    data: r,
    signal: i,
    cancelToken: o,
    timeout: a,
    onDownloadProgress: s,
    onUploadProgress: c,
    responseType: l,
    headers: u,
    withCredentials: d = "same-origin",
    fetchOptions: p
  } = E0(e);
  l = l ? (l + "").toLowerCase() : "text";
  let [f, h] = i || o || a ? vA([i, o], a) : [], m, y;
  const g = () => {
    !m && setTimeout(() => {
      f && f.unsubscribe();
    }), m = !0;
  };
  let v;
  try {
    if (c && xA && n !== "get" && n !== "head" && (v = await SA(u, r)) !== 0) {
      let x = new Request(t, {
        method: "POST",
        body: r,
        duplex: "half"
      }), A;
      Q.isFormData(r) && (A = x.headers.get("content-type")) && u.setContentType(A), x.body && (r = qy(x.body, Fy, Ly(
        v,
        ru(c)
      ), null, mp));
    }
    Q.isString(d) || (d = d ? "cors" : "omit"), y = new Request(t, {
      ...p,
      signal: f,
      method: n.toUpperCase(),
      headers: u.normalize().toJSON(),
      body: r,
      duplex: "half",
      withCredentials: d
    });
    let b = await fetch(y);
    const _ = yp && (l === "stream" || l === "response");
    if (yp && (s || _)) {
      const x = {};
      ["status", "statusText", "headers"].forEach((I) => {
        x[I] = b[I];
      });
      const A = Q.toFiniteNumber(b.headers.get("content-length"));
      b = new Response(
        qy(b.body, Fy, s && Ly(
          A,
          ru(s, !0)
        ), _ && g, mp),
        x
      );
    }
    l = l || "text";
    let S = await iu[Q.findKey(iu, l) || "text"](b, e);
    return !_ && g(), h && h(), await new Promise((x, A) => {
      S0(x, A, {
        data: S,
        headers: Cr.from(b.headers),
        status: b.status,
        statusText: b.statusText,
        config: e,
        request: y
      });
    });
  } catch (b) {
    throw g(), b && b.name === "TypeError" && /fetch/i.test(b.message) ? Object.assign(
      new dt("Network Error", dt.ERR_NETWORK, e, y),
      {
        cause: b.cause || b
      }
    ) : dt.from(b, b && b.code, e, y);
  }
}), gp = {
  http: LR,
  xhr: yA,
  fetch: kA
};
Q.forEach(gp, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const Uy = (e) => `- ${e}`, EA = (e) => Q.isFunction(e) || e === null || e === !1, T0 = {
  getAdapter: (e) => {
    e = Q.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const i = {};
    for (let o = 0; o < t; o++) {
      n = e[o];
      let a;
      if (r = n, !EA(n) && (r = gp[(a = String(n)).toLowerCase()], r === void 0))
        throw new dt(`Unknown adapter '${a}'`);
      if (r)
        break;
      i[a || "#" + o] = r;
    }
    if (!r) {
      const o = Object.entries(i).map(
        ([s, c]) => `adapter ${s} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let a = t ? o.length > 1 ? `since :
` + o.map(Uy).join(`
`) : " " + Uy(o[0]) : "as no adapter specified";
      throw new dt(
        "There is no suitable adapter to dispatch the request " + a,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: gp
};
function af(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Pa(null, e);
}
function By(e) {
  return af(e), e.headers = Cr.from(e.headers), e.data = of.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), T0.getAdapter(e.adapter || Wh.adapter)(e).then(function(r) {
    return af(e), r.data = of.call(
      e,
      e.transformResponse,
      r
    ), r.headers = Cr.from(r.headers), r;
  }, function(r) {
    return _0(r) || (af(e), r && r.response && (r.response.data = of.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = Cr.from(r.response.headers))), Promise.reject(r);
  });
}
const R0 = "1.7.2", Kh = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Kh[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const zy = {};
Kh.transitional = function(t, n, r) {
  function i(o, a) {
    return "[Axios v" + R0 + "] Transitional option '" + o + "'" + a + (r ? ". " + r : "");
  }
  return (o, a, s) => {
    if (t === !1)
      throw new dt(
        i(a, " has been removed" + (n ? " in " + n : "")),
        dt.ERR_DEPRECATED
      );
    return n && !zy[a] && (zy[a] = !0, console.warn(
      i(
        a,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(o, a, s) : !0;
  };
};
function CA(e, t, n) {
  if (typeof e != "object")
    throw new dt("options must be an object", dt.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const o = r[i], a = t[o];
    if (a) {
      const s = e[o], c = s === void 0 || a(s, o, e);
      if (c !== !0)
        throw new dt("option " + o + " must be " + c, dt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new dt("Unknown option " + o, dt.ERR_BAD_OPTION);
  }
}
const vp = {
  assertOptions: CA,
  validators: Kh
}, xi = vp.validators;
let ou = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new Ny(),
      response: new Ny()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (r) {
      if (r instanceof Error) {
        let i;
        Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error();
        const o = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? o && !String(r.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + o) : r.stack = o;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = go(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: o } = n;
    r !== void 0 && vp.assertOptions(r, {
      silentJSONParsing: xi.transitional(xi.boolean),
      forcedJSONParsing: xi.transitional(xi.boolean),
      clarifyTimeoutError: xi.transitional(xi.boolean)
    }, !1), i != null && (Q.isFunction(i) ? n.paramsSerializer = {
      serialize: i
    } : vp.assertOptions(i, {
      encode: xi.function,
      serialize: xi.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let a = o && Q.merge(
      o.common,
      o[n.method]
    );
    o && Q.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (h) => {
        delete o[h];
      }
    ), n.headers = Cr.concat(a, o);
    const s = [];
    let c = !0;
    this.interceptors.request.forEach(function(m) {
      typeof m.runWhen == "function" && m.runWhen(n) === !1 || (c = c && m.synchronous, s.unshift(m.fulfilled, m.rejected));
    });
    const l = [];
    this.interceptors.response.forEach(function(m) {
      l.push(m.fulfilled, m.rejected);
    });
    let u, d = 0, p;
    if (!c) {
      const h = [By.bind(this), void 0];
      for (h.unshift.apply(h, s), h.push.apply(h, l), p = h.length, u = Promise.resolve(n); d < p; )
        u = u.then(h[d++], h[d++]);
      return u;
    }
    p = s.length;
    let f = n;
    for (d = 0; d < p; ) {
      const h = s[d++], m = s[d++];
      try {
        f = h(f);
      } catch (y) {
        m.call(this, y);
        break;
      }
    }
    try {
      u = By.call(this, f);
    } catch (h) {
      return Promise.reject(h);
    }
    for (d = 0, p = l.length; d < p; )
      u = u.then(l[d++], l[d++]);
    return u;
  }
  getUri(t) {
    t = go(this.defaults, t);
    const n = k0(t.baseURL, t.url);
    return b0(n, t.params, t.paramsSerializer);
  }
};
Q.forEach(["delete", "get", "head", "options"], function(t) {
  ou.prototype[t] = function(n, r) {
    return this.request(go(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
Q.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(o, a, s) {
      return this.request(go(s || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: a
      }));
    };
  }
  ou.prototype[t] = n(), ou.prototype[t + "Form"] = n(!0);
});
const Kc = ou;
let TA = class A0 {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(o) {
      n = o;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners)
        return;
      let o = r._listeners.length;
      for (; o-- > 0; )
        r._listeners[o](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let o;
      const a = new Promise((s) => {
        r.subscribe(s), o = s;
      }).then(i);
      return a.cancel = function() {
        r.unsubscribe(o);
      }, a;
    }, t(function(o, a, s) {
      r.reason || (r.reason = new Pa(o, a, s), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new A0(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
};
const RA = TA;
function AA(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function OA(e) {
  return Q.isObject(e) && e.isAxiosError === !0;
}
const bp = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(bp).forEach(([e, t]) => {
  bp[t] = e;
});
const IA = bp;
function O0(e) {
  const t = new Kc(e), n = s0(Kc.prototype.request, t);
  return Q.extend(n, Kc.prototype, t, { allOwnKeys: !0 }), Q.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return O0(go(e, i));
  }, n;
}
const sn = O0(Wh);
sn.Axios = Kc;
sn.CanceledError = Pa;
sn.CancelToken = RA;
sn.isCancel = _0;
sn.VERSION = R0;
sn.toFormData = sd;
sn.AxiosError = dt;
sn.Cancel = sn.CanceledError;
sn.all = function(t) {
  return Promise.all(t);
};
sn.spread = AA;
sn.isAxiosError = OA;
sn.mergeConfig = go;
sn.AxiosHeaders = Cr;
sn.formToJSON = (e) => x0(Q.isHTMLForm(e) ? new FormData(e) : e);
sn.getAdapter = T0.getAdapter;
sn.HttpStatusCode = IA;
sn.default = sn;
const ea = sn, {
  Axios: PA,
  AxiosError: $A,
  CanceledError: DA,
  isCancel: NA,
  CancelToken: jA,
  VERSION: MA,
  all: qA,
  Cancel: LA,
  isAxiosError: FA,
  spread: UA,
  toFormData: BA,
  AxiosHeaders: zA,
  HttpStatusCode: ZA,
  formToJSON: VA,
  getAdapter: HA,
  mergeConfig: WA
} = ea, KA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Axios: PA,
  AxiosError: $A,
  AxiosHeaders: zA,
  Cancel: LA,
  CancelToken: jA,
  CanceledError: DA,
  HttpStatusCode: ZA,
  VERSION: MA,
  all: qA,
  default: ea,
  formToJSON: VA,
  getAdapter: HA,
  isAxiosError: FA,
  isCancel: NA,
  mergeConfig: WA,
  spread: UA,
  toFormData: BA
}, Symbol.toStringTag, { value: "Module" }));
var $a = {};
Object.defineProperty($a, "__esModule", {
  value: !0
});
var JA = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
  return typeof e;
} : function(e) {
  return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
}, YA = typeof window < "u" && typeof window.document < "u", GA = typeof process < "u" && process.versions != null && process.versions.node != null, XA = (typeof self > "u" ? "undefined" : JA(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope", QA = typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), eO = typeof Deno < "u" && typeof Deno.version < "u" && typeof Deno.version.deno < "u", I0 = $a.isBrowser = YA;
$a.isWebWorker = XA;
var wp = $a.isNode = GA;
$a.isJsDom = QA;
$a.isDeno = eO;
var tO = Object.create, Jh = Object.defineProperty, nO = Object.getOwnPropertyDescriptor, rO = Object.getOwnPropertyNames, iO = Object.getPrototypeOf, oO = Object.prototype.hasOwnProperty, cn = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), aO = (e, t) => {
  for (var n in t)
    Jh(e, n, { get: t[n], enumerable: !0 });
}, sO = (e, t, n, r) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of rO(t))
      !oO.call(e, i) && i !== n && Jh(e, i, { get: () => t[i], enumerable: !(r = nO(t, i)) || r.enumerable });
  return e;
}, ud = (e, t, n) => (n = e != null ? tO(iO(e)) : {}, sO(t || !e || !e.__esModule ? Jh(n, "default", { value: e, enumerable: !0 }) : n, e)), cO = cn((e, t) => {
  var n = /* @__PURE__ */ new Set(["ENOTFOUND", "ENETUNREACH", "UNABLE_TO_GET_ISSUER_CERT", "UNABLE_TO_GET_CRL", "UNABLE_TO_DECRYPT_CERT_SIGNATURE", "UNABLE_TO_DECRYPT_CRL_SIGNATURE", "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY", "CERT_SIGNATURE_FAILURE", "CRL_SIGNATURE_FAILURE", "CERT_NOT_YET_VALID", "CERT_HAS_EXPIRED", "CRL_NOT_YET_VALID", "CRL_HAS_EXPIRED", "ERROR_IN_CERT_NOT_BEFORE_FIELD", "ERROR_IN_CERT_NOT_AFTER_FIELD", "ERROR_IN_CRL_LAST_UPDATE_FIELD", "ERROR_IN_CRL_NEXT_UPDATE_FIELD", "OUT_OF_MEM", "DEPTH_ZERO_SELF_SIGNED_CERT", "SELF_SIGNED_CERT_IN_CHAIN", "UNABLE_TO_GET_ISSUER_CERT_LOCALLY", "UNABLE_TO_VERIFY_LEAF_SIGNATURE", "CERT_CHAIN_TOO_LONG", "CERT_REVOKED", "INVALID_CA", "PATH_LENGTH_EXCEEDED", "INVALID_PURPOSE", "CERT_UNTRUSTED", "CERT_REJECTED", "HOSTNAME_MISMATCH"]);
  t.exports = (r) => !n.has(r && r.code);
}), lO = cn(() => {
}), uO = cn(() => {
}), dO = cn((e, t) => {
  t.exports = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var n = {}, r = Symbol("test"), i = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
      return !1;
    var o = 42;
    n[r] = o;
    for (r in n)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(n).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(n).length !== 0)
      return !1;
    var a = Object.getOwnPropertySymbols(n);
    if (a.length !== 1 || a[0] !== r || !Object.prototype.propertyIsEnumerable.call(n, r))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var s = Object.getOwnPropertyDescriptor(n, r);
      if (s.value !== o || s.enumerable !== !0)
        return !1;
    }
    return !0;
  };
}), fO = cn((e, t) => {
  var n = typeof Symbol < "u" && Symbol, r = dO();
  t.exports = function() {
    return typeof n != "function" || typeof Symbol != "function" || typeof n("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : r();
  };
}), pO = cn((e, t) => {
  var n = { foo: {} }, r = Object;
  t.exports = function() {
    return { __proto__: n }.foo === n.foo && !({ __proto__: null } instanceof r);
  };
}), hO = cn((e, t) => {
  var n = "Function.prototype.bind called on incompatible ", r = Array.prototype.slice, i = Object.prototype.toString, o = "[object Function]";
  t.exports = function(a) {
    var s = this;
    if (typeof s != "function" || i.call(s) !== o)
      throw new TypeError(n + s);
    for (var c = r.call(arguments, 1), l, u = function() {
      if (this instanceof l) {
        var m = s.apply(this, c.concat(r.call(arguments)));
        return Object(m) === m ? m : this;
      } else
        return s.apply(a, c.concat(r.call(arguments)));
    }, d = Math.max(0, s.length - c.length), p = [], f = 0; f < d; f++)
      p.push("$" + f);
    if (l = Function("binder", "return function (" + p.join(",") + "){ return binder.apply(this,arguments); }")(u), s.prototype) {
      var h = function() {
      };
      h.prototype = s.prototype, l.prototype = new h(), h.prototype = null;
    }
    return l;
  };
}), Yh = cn((e, t) => {
  var n = hO();
  t.exports = Function.prototype.bind || n;
}), mO = cn((e, t) => {
  var n = Yh();
  t.exports = n.call(Function.call, Object.prototype.hasOwnProperty);
}), Gh = cn((e, t) => {
  var n, r = SyntaxError, i = Function, o = TypeError, a = function(L) {
    try {
      return i('"use strict"; return (' + L + ").constructor;")();
    } catch {
    }
  }, s = Object.getOwnPropertyDescriptor;
  if (s)
    try {
      s({}, "");
    } catch {
      s = null;
    }
  var c = function() {
    throw new o();
  }, l = s ? function() {
    try {
      return arguments.callee, c;
    } catch {
      try {
        return s(arguments, "callee").get;
      } catch {
        return c;
      }
    }
  }() : c, u = fO()(), d = pO()(), p = Object.getPrototypeOf || (d ? function(L) {
    return L.__proto__;
  } : null), f = {}, h = typeof Uint8Array > "u" || !p ? n : p(Uint8Array), m = { "%AggregateError%": typeof AggregateError > "u" ? n : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? n : ArrayBuffer, "%ArrayIteratorPrototype%": u && p ? p([][Symbol.iterator]()) : n, "%AsyncFromSyncIteratorPrototype%": n, "%AsyncFunction%": f, "%AsyncGenerator%": f, "%AsyncGeneratorFunction%": f, "%AsyncIteratorPrototype%": f, "%Atomics%": typeof Atomics > "u" ? n : Atomics, "%BigInt%": typeof BigInt > "u" ? n : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? n : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? n : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? n : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? n : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? n : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? n : FinalizationRegistry, "%Function%": i, "%GeneratorFunction%": f, "%Int8Array%": typeof Int8Array > "u" ? n : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? n : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? n : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": u && p ? p(p([][Symbol.iterator]())) : n, "%JSON%": typeof JSON == "object" ? JSON : n, "%Map%": typeof Map > "u" ? n : Map, "%MapIteratorPrototype%": typeof Map > "u" || !u || !p ? n : p((/* @__PURE__ */ new Map())[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? n : Promise, "%Proxy%": typeof Proxy > "u" ? n : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? n : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? n : Set, "%SetIteratorPrototype%": typeof Set > "u" || !u || !p ? n : p((/* @__PURE__ */ new Set())[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? n : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": u && p ? p(""[Symbol.iterator]()) : n, "%Symbol%": u ? Symbol : n, "%SyntaxError%": r, "%ThrowTypeError%": l, "%TypedArray%": h, "%TypeError%": o, "%Uint8Array%": typeof Uint8Array > "u" ? n : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? n : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? n : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? n : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? n : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? n : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? n : WeakSet };
  if (p)
    try {
      null.error;
    } catch (L) {
      y = p(p(L)), m["%Error.prototype%"] = y;
    }
  var y, g = function L($) {
    var j;
    if ($ === "%AsyncFunction%")
      j = a("async function () {}");
    else if ($ === "%GeneratorFunction%")
      j = a("function* () {}");
    else if ($ === "%AsyncGeneratorFunction%")
      j = a("async function* () {}");
    else if ($ === "%AsyncGenerator%") {
      var z = L("%AsyncGeneratorFunction%");
      z && (j = z.prototype);
    } else if ($ === "%AsyncIteratorPrototype%") {
      var H = L("%AsyncGenerator%");
      H && p && (j = p(H.prototype));
    }
    return m[$] = j, j;
  }, v = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, b = Yh(), _ = mO(), S = b.call(Function.call, Array.prototype.concat), x = b.call(Function.apply, Array.prototype.splice), A = b.call(Function.call, String.prototype.replace), I = b.call(Function.call, String.prototype.slice), P = b.call(Function.call, RegExp.prototype.exec), R = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, M = /\\(\\)?/g, V = function(L) {
    var $ = I(L, 0, 1), j = I(L, -1);
    if ($ === "%" && j !== "%")
      throw new r("invalid intrinsic syntax, expected closing `%`");
    if (j === "%" && $ !== "%")
      throw new r("invalid intrinsic syntax, expected opening `%`");
    var z = [];
    return A(L, R, function(H, X, E, ee) {
      z[z.length] = E ? A(ee, M, "$1") : X || H;
    }), z;
  }, U = function(L, $) {
    var j = L, z;
    if (_(v, j) && (z = v[j], j = "%" + z[0] + "%"), _(m, j)) {
      var H = m[j];
      if (H === f && (H = g(j)), typeof H > "u" && !$)
        throw new o("intrinsic " + L + " exists, but is not available. Please file an issue!");
      return { alias: z, name: j, value: H };
    }
    throw new r("intrinsic " + L + " does not exist!");
  };
  t.exports = function(L, $) {
    if (typeof L != "string" || L.length === 0)
      throw new o("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof $ != "boolean")
      throw new o('"allowMissing" argument must be a boolean');
    if (P(/^%?[^%]*%?$/, L) === null)
      throw new r("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var j = V(L), z = j.length > 0 ? j[0] : "", H = U("%" + z + "%", $), X = H.name, E = H.value, ee = !1, de = H.alias;
    de && (z = de[0], x(j, S([0, 1], de)));
    for (var T = 1, be = !0; T < j.length; T += 1) {
      var ke = j[T], Se = I(ke, 0, 1), Pe = I(ke, -1);
      if ((Se === '"' || Se === "'" || Se === "`" || Pe === '"' || Pe === "'" || Pe === "`") && Se !== Pe)
        throw new r("property names with quotes must have matching quotes");
      if ((ke === "constructor" || !be) && (ee = !0), z += "." + ke, X = "%" + z + "%", _(m, X))
        E = m[X];
      else if (E != null) {
        if (!(ke in E)) {
          if (!$)
            throw new o("base intrinsic for " + L + " exists, but the property is not available.");
          return;
        }
        if (s && T + 1 >= j.length) {
          var Be = s(E, ke);
          be = !!Be, be && "get" in Be && !("originalValue" in Be.get) ? E = Be.get : E = E[ke];
        } else
          be = _(E, ke), E = E[ke];
        be && !ee && (m[X] = E);
      }
    }
    return E;
  };
}), yO = cn((e, t) => {
  var n = Yh(), r = Gh(), i = r("%Function.prototype.apply%"), o = r("%Function.prototype.call%"), a = r("%Reflect.apply%", !0) || n.call(o, i), s = r("%Object.getOwnPropertyDescriptor%", !0), c = r("%Object.defineProperty%", !0), l = r("%Math.max%");
  if (c)
    try {
      c({}, "a", { value: 1 });
    } catch {
      c = null;
    }
  t.exports = function(d) {
    var p = a(n, o, arguments);
    if (s && c) {
      var f = s(p, "length");
      f.configurable && c(p, "length", { value: 1 + l(0, d.length - (arguments.length - 1)) });
    }
    return p;
  };
  var u = function() {
    return a(n, i, arguments);
  };
  c ? c(t.exports, "apply", { value: u }) : t.exports.apply = u;
}), gO = cn((e, t) => {
  var n = Gh(), r = yO(), i = r(n("String.prototype.indexOf"));
  t.exports = function(o, a) {
    var s = n(o, !!a);
    return typeof s == "function" && i(o, ".prototype.") > -1 ? r(s) : s;
  };
}), vO = cn(() => {
}), bO = cn((e, t) => {
  var n = typeof Map == "function" && Map.prototype, r = Object.getOwnPropertyDescriptor && n ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, i = n && r && typeof r.get == "function" ? r.get : null, o = n && Map.prototype.forEach, a = typeof Set == "function" && Set.prototype, s = Object.getOwnPropertyDescriptor && a ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, c = a && s && typeof s.get == "function" ? s.get : null, l = a && Set.prototype.forEach, u = typeof WeakMap == "function" && WeakMap.prototype, d = u ? WeakMap.prototype.has : null, p = typeof WeakSet == "function" && WeakSet.prototype, f = p ? WeakSet.prototype.has : null, h = typeof WeakRef == "function" && WeakRef.prototype, m = h ? WeakRef.prototype.deref : null, y = Boolean.prototype.valueOf, g = Object.prototype.toString, v = Function.prototype.toString, b = String.prototype.match, _ = String.prototype.slice, S = String.prototype.replace, x = String.prototype.toUpperCase, A = String.prototype.toLowerCase, I = RegExp.prototype.test, P = Array.prototype.concat, R = Array.prototype.join, M = Array.prototype.slice, V = Math.floor, U = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, L = Object.getOwnPropertySymbols, $ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, j = typeof Symbol == "function" && typeof Symbol.iterator == "object", z = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === j || "symbol") ? Symbol.toStringTag : null, H = Object.prototype.propertyIsEnumerable, X = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(B) {
    return B.__proto__;
  } : null);
  function E(B, K) {
    if (B === 1 / 0 || B === -1 / 0 || B !== B || B && B > -1e3 && B < 1e3 || I.call(/e/, K))
      return K;
    var tt = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof B == "number") {
      var at = B < 0 ? -V(-B) : V(B);
      if (at !== B) {
        var It = String(at), Qe = _.call(K, It.length + 1);
        return S.call(It, tt, "$&_") + "." + S.call(S.call(Qe, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return S.call(K, tt, "$&_");
  }
  var ee = vO(), de = ee.custom, T = fe(de) ? de : null;
  t.exports = function B(K, tt, at, It) {
    var Qe = tt || {};
    if (q(Qe, "quoteStyle") && Qe.quoteStyle !== "single" && Qe.quoteStyle !== "double")
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (q(Qe, "maxStringLength") && (typeof Qe.maxStringLength == "number" ? Qe.maxStringLength < 0 && Qe.maxStringLength !== 1 / 0 : Qe.maxStringLength !== null))
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var ln = q(Qe, "customInspect") ? Qe.customInspect : !0;
    if (typeof ln != "boolean" && ln !== "symbol")
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (q(Qe, "indent") && Qe.indent !== null && Qe.indent !== "	" && !(parseInt(Qe.indent, 10) === Qe.indent && Qe.indent > 0))
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (q(Qe, "numericSeparator") && typeof Qe.numericSeparator != "boolean")
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var Un = Qe.numericSeparator;
    if (typeof K > "u")
      return "undefined";
    if (K === null)
      return "null";
    if (typeof K == "boolean")
      return K ? "true" : "false";
    if (typeof K == "string")
      return re(K, Qe);
    if (typeof K == "number") {
      if (K === 0)
        return 1 / 0 / K > 0 ? "0" : "-0";
      var Wt = String(K);
      return Un ? E(K, Wt) : Wt;
    }
    if (typeof K == "bigint") {
      var wn = String(K) + "n";
      return Un ? E(K, wn) : wn;
    }
    var er = typeof Qe.depth > "u" ? 5 : Qe.depth;
    if (typeof at > "u" && (at = 0), at >= er && er > 0 && typeof K == "object")
      return Se(K) ? "[Array]" : "[Object]";
    var $t = Ct(Qe, at);
    if (typeof It > "u")
      It = [];
    else if (le(It, K) >= 0)
      return "[Circular]";
    function St(ct, Yt, Ut) {
      if (Yt && (It = M.call(It), It.push(Yt)), Ut) {
        var Bt = { depth: Qe.depth };
        return q(Qe, "quoteStyle") && (Bt.quoteStyle = Qe.quoteStyle), B(ct, Bt, at + 1, It);
      }
      return B(ct, Qe, at + 1, It);
    }
    if (typeof K == "function" && !Be(K)) {
      var Kt = se(K), Zt = Qt(K, St);
      return "[Function" + (Kt ? ": " + Kt : " (anonymous)") + "]" + (Zt.length > 0 ? " { " + R.call(Zt, ", ") + " }" : "");
    }
    if (fe(K)) {
      var Jt = j ? S.call(String(K), /^(Symbol\(.*\))_[^)]*$/, "$1") : $.call(K);
      return typeof K == "object" && !j ? Te(Jt) : Jt;
    }
    if (W(K)) {
      for (var Nt = "<" + A.call(String(K.nodeName)), hn = K.attributes || [], mn = 0; mn < hn.length; mn++)
        Nt += " " + hn[mn].name + "=" + be(ke(hn[mn].value), "double", Qe);
      return Nt += ">", K.childNodes && K.childNodes.length && (Nt += "..."), Nt += "</" + A.call(String(K.nodeName)) + ">", Nt;
    }
    if (Se(K)) {
      if (K.length === 0)
        return "[]";
      var An = Qt(K, St);
      return $t && !Pt(An) ? "[" + jt(An, $t) + "]" : "[ " + R.call(An, ", ") + " ]";
    }
    if (Ae(K)) {
      var Gi = Qt(K, St);
      return !("cause" in Error.prototype) && "cause" in K && !H.call(K, "cause") ? "{ [" + String(K) + "] " + R.call(P.call("[cause]: " + St(K.cause), Gi), ", ") + " }" : Gi.length === 0 ? "[" + String(K) + "]" : "{ [" + String(K) + "] " + R.call(Gi, ", ") + " }";
    }
    if (typeof K == "object" && ln) {
      if (T && typeof K[T] == "function" && ee)
        return ee(K, { depth: er - at });
      if (ln !== "symbol" && typeof K.inspect == "function")
        return K.inspect();
    }
    if (De(K)) {
      var Xi = [];
      return o && o.call(K, function(ct, Yt) {
        Xi.push(St(Yt, K, !0) + " => " + St(ct, K));
      }), Lt("Map", i.call(K), Xi, $t);
    }
    if (yt(K)) {
      var N = [];
      return l && l.call(K, function(ct) {
        N.push(St(ct, K));
      }), Lt("Set", c.call(K), N, $t);
    }
    if (_e(K))
      return Xe("WeakMap");
    if (et(K))
      return Xe("WeakSet");
    if (Ze(K))
      return Xe("WeakRef");
    if (ue(K))
      return Te(St(Number(K)));
    if ($e(K))
      return Te(St(U.call(K)));
    if (xe(K))
      return Te(y.call(K));
    if (pe(K))
      return Te(St(String(K)));
    if (!Pe(K) && !Be(K)) {
      var ce = Qt(K, St), ye = X ? X(K) === Object.prototype : K instanceof Object || K.constructor === Object, ze = K instanceof Object ? "" : "null prototype", wt = !ye && z && Object(K) === K && z in K ? _.call(ie(K), 8, -1) : ze ? "Object" : "", kt = ye || typeof K.constructor != "function" ? "" : K.constructor.name ? K.constructor.name + " " : "", pt = kt + (wt || ze ? "[" + R.call(P.call([], wt || [], ze || []), ": ") + "] " : "");
      return ce.length === 0 ? pt + "{}" : $t ? pt + "{" + jt(ce, $t) + "}" : pt + "{ " + R.call(ce, ", ") + " }";
    }
    return String(K);
  };
  function be(B, K, tt) {
    var at = (tt.quoteStyle || K) === "double" ? '"' : "'";
    return at + B + at;
  }
  function ke(B) {
    return S.call(String(B), /"/g, "&quot;");
  }
  function Se(B) {
    return ie(B) === "[object Array]" && (!z || !(typeof B == "object" && z in B));
  }
  function Pe(B) {
    return ie(B) === "[object Date]" && (!z || !(typeof B == "object" && z in B));
  }
  function Be(B) {
    return ie(B) === "[object RegExp]" && (!z || !(typeof B == "object" && z in B));
  }
  function Ae(B) {
    return ie(B) === "[object Error]" && (!z || !(typeof B == "object" && z in B));
  }
  function pe(B) {
    return ie(B) === "[object String]" && (!z || !(typeof B == "object" && z in B));
  }
  function ue(B) {
    return ie(B) === "[object Number]" && (!z || !(typeof B == "object" && z in B));
  }
  function xe(B) {
    return ie(B) === "[object Boolean]" && (!z || !(typeof B == "object" && z in B));
  }
  function fe(B) {
    if (j)
      return B && typeof B == "object" && B instanceof Symbol;
    if (typeof B == "symbol")
      return !0;
    if (!B || typeof B != "object" || !$)
      return !1;
    try {
      return $.call(B), !0;
    } catch {
    }
    return !1;
  }
  function $e(B) {
    if (!B || typeof B != "object" || !U)
      return !1;
    try {
      return U.call(B), !0;
    } catch {
    }
    return !1;
  }
  var nt = Object.prototype.hasOwnProperty || function(B) {
    return B in this;
  };
  function q(B, K) {
    return nt.call(B, K);
  }
  function ie(B) {
    return g.call(B);
  }
  function se(B) {
    if (B.name)
      return B.name;
    var K = b.call(v.call(B), /^function\s*([\w$]+)/);
    return K ? K[1] : null;
  }
  function le(B, K) {
    if (B.indexOf)
      return B.indexOf(K);
    for (var tt = 0, at = B.length; tt < at; tt++)
      if (B[tt] === K)
        return tt;
    return -1;
  }
  function De(B) {
    if (!i || !B || typeof B != "object")
      return !1;
    try {
      i.call(B);
      try {
        c.call(B);
      } catch {
        return !0;
      }
      return B instanceof Map;
    } catch {
    }
    return !1;
  }
  function _e(B) {
    if (!d || !B || typeof B != "object")
      return !1;
    try {
      d.call(B, d);
      try {
        f.call(B, f);
      } catch {
        return !0;
      }
      return B instanceof WeakMap;
    } catch {
    }
    return !1;
  }
  function Ze(B) {
    if (!m || !B || typeof B != "object")
      return !1;
    try {
      return m.call(B), !0;
    } catch {
    }
    return !1;
  }
  function yt(B) {
    if (!c || !B || typeof B != "object")
      return !1;
    try {
      c.call(B);
      try {
        i.call(B);
      } catch {
        return !0;
      }
      return B instanceof Set;
    } catch {
    }
    return !1;
  }
  function et(B) {
    if (!f || !B || typeof B != "object")
      return !1;
    try {
      f.call(B, f);
      try {
        d.call(B, d);
      } catch {
        return !0;
      }
      return B instanceof WeakSet;
    } catch {
    }
    return !1;
  }
  function W(B) {
    return !B || typeof B != "object" ? !1 : typeof HTMLElement < "u" && B instanceof HTMLElement ? !0 : typeof B.nodeName == "string" && typeof B.getAttribute == "function";
  }
  function re(B, K) {
    if (B.length > K.maxStringLength) {
      var tt = B.length - K.maxStringLength, at = "... " + tt + " more character" + (tt > 1 ? "s" : "");
      return re(_.call(B, 0, K.maxStringLength), K) + at;
    }
    var It = S.call(S.call(B, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, ae);
    return be(It, "single", K);
  }
  function ae(B) {
    var K = B.charCodeAt(0), tt = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[K];
    return tt ? "\\" + tt : "\\x" + (K < 16 ? "0" : "") + x.call(K.toString(16));
  }
  function Te(B) {
    return "Object(" + B + ")";
  }
  function Xe(B) {
    return B + " { ? }";
  }
  function Lt(B, K, tt, at) {
    var It = at ? jt(tt, at) : R.call(tt, ", ");
    return B + " (" + K + ") {" + It + "}";
  }
  function Pt(B) {
    for (var K = 0; K < B.length; K++)
      if (le(B[K], `
`) >= 0)
        return !1;
    return !0;
  }
  function Ct(B, K) {
    var tt;
    if (B.indent === "	")
      tt = "	";
    else if (typeof B.indent == "number" && B.indent > 0)
      tt = R.call(Array(B.indent + 1), " ");
    else
      return null;
    return { base: tt, prev: R.call(Array(K + 1), tt) };
  }
  function jt(B, K) {
    if (B.length === 0)
      return "";
    var tt = `
` + K.prev + K.base;
    return tt + R.call(B, "," + tt) + `
` + K.prev;
  }
  function Qt(B, K) {
    var tt = Se(B), at = [];
    if (tt) {
      at.length = B.length;
      for (var It = 0; It < B.length; It++)
        at[It] = q(B, It) ? K(B[It], B) : "";
    }
    var Qe = typeof L == "function" ? L(B) : [], ln;
    if (j) {
      ln = {};
      for (var Un = 0; Un < Qe.length; Un++)
        ln["$" + Qe[Un]] = Qe[Un];
    }
    for (var Wt in B)
      q(B, Wt) && (tt && String(Number(Wt)) === Wt && Wt < B.length || j && ln["$" + Wt] instanceof Symbol || (I.call(/[^\w$]/, Wt) ? at.push(K(Wt, B) + ": " + K(B[Wt], B)) : at.push(Wt + ": " + K(B[Wt], B))));
    if (typeof L == "function")
      for (var wn = 0; wn < Qe.length; wn++)
        H.call(B, Qe[wn]) && at.push("[" + K(Qe[wn]) + "]: " + K(B[Qe[wn]], B));
    return at;
  }
}), wO = cn((e, t) => {
  var n = Gh(), r = gO(), i = bO(), o = n("%TypeError%"), a = n("%WeakMap%", !0), s = n("%Map%", !0), c = r("WeakMap.prototype.get", !0), l = r("WeakMap.prototype.set", !0), u = r("WeakMap.prototype.has", !0), d = r("Map.prototype.get", !0), p = r("Map.prototype.set", !0), f = r("Map.prototype.has", !0), h = function(v, b) {
    for (var _ = v, S; (S = _.next) !== null; _ = S)
      if (S.key === b)
        return _.next = S.next, S.next = v.next, v.next = S, S;
  }, m = function(v, b) {
    var _ = h(v, b);
    return _ && _.value;
  }, y = function(v, b, _) {
    var S = h(v, b);
    S ? S.value = _ : v.next = { key: b, next: v.next, value: _ };
  }, g = function(v, b) {
    return !!h(v, b);
  };
  t.exports = function() {
    var v, b, _, S = { assert: function(x) {
      if (!S.has(x))
        throw new o("Side channel does not contain " + i(x));
    }, get: function(x) {
      if (a && x && (typeof x == "object" || typeof x == "function")) {
        if (v)
          return c(v, x);
      } else if (s) {
        if (b)
          return d(b, x);
      } else if (_)
        return m(_, x);
    }, has: function(x) {
      if (a && x && (typeof x == "object" || typeof x == "function")) {
        if (v)
          return u(v, x);
      } else if (s) {
        if (b)
          return f(b, x);
      } else if (_)
        return g(_, x);
      return !1;
    }, set: function(x, A) {
      a && x && (typeof x == "object" || typeof x == "function") ? (v || (v = new a()), l(v, x, A)) : s ? (b || (b = new s()), p(b, x, A)) : (_ || (_ = { key: {}, next: null }), y(_, x, A));
    } };
    return S;
  };
}), Xh = cn((e, t) => {
  var n = String.prototype.replace, r = /%20/g, i = { RFC1738: "RFC1738", RFC3986: "RFC3986" };
  t.exports = { default: i.RFC3986, formatters: { RFC1738: function(o) {
    return n.call(o, r, "+");
  }, RFC3986: function(o) {
    return String(o);
  } }, RFC1738: i.RFC1738, RFC3986: i.RFC3986 };
}), P0 = cn((e, t) => {
  var n = Xh(), r = Object.prototype.hasOwnProperty, i = Array.isArray, o = function() {
    for (var g = [], v = 0; v < 256; ++v)
      g.push("%" + ((v < 16 ? "0" : "") + v.toString(16)).toUpperCase());
    return g;
  }(), a = function(g) {
    for (; g.length > 1; ) {
      var v = g.pop(), b = v.obj[v.prop];
      if (i(b)) {
        for (var _ = [], S = 0; S < b.length; ++S)
          typeof b[S] < "u" && _.push(b[S]);
        v.obj[v.prop] = _;
      }
    }
  }, s = function(g, v) {
    for (var b = v && v.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, _ = 0; _ < g.length; ++_)
      typeof g[_] < "u" && (b[_] = g[_]);
    return b;
  }, c = function g(v, b, _) {
    if (!b)
      return v;
    if (typeof b != "object") {
      if (i(v))
        v.push(b);
      else if (v && typeof v == "object")
        (_ && (_.plainObjects || _.allowPrototypes) || !r.call(Object.prototype, b)) && (v[b] = !0);
      else
        return [v, b];
      return v;
    }
    if (!v || typeof v != "object")
      return [v].concat(b);
    var S = v;
    return i(v) && !i(b) && (S = s(v, _)), i(v) && i(b) ? (b.forEach(function(x, A) {
      if (r.call(v, A)) {
        var I = v[A];
        I && typeof I == "object" && x && typeof x == "object" ? v[A] = g(I, x, _) : v.push(x);
      } else
        v[A] = x;
    }), v) : Object.keys(b).reduce(function(x, A) {
      var I = b[A];
      return r.call(x, A) ? x[A] = g(x[A], I, _) : x[A] = I, x;
    }, S);
  }, l = function(g, v) {
    return Object.keys(v).reduce(function(b, _) {
      return b[_] = v[_], b;
    }, g);
  }, u = function(g, v, b) {
    var _ = g.replace(/\+/g, " ");
    if (b === "iso-8859-1")
      return _.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(_);
    } catch {
      return _;
    }
  }, d = function(g, v, b, _, S) {
    if (g.length === 0)
      return g;
    var x = g;
    if (typeof g == "symbol" ? x = Symbol.prototype.toString.call(g) : typeof g != "string" && (x = String(g)), b === "iso-8859-1")
      return escape(x).replace(/%u[0-9a-f]{4}/gi, function(R) {
        return "%26%23" + parseInt(R.slice(2), 16) + "%3B";
      });
    for (var A = "", I = 0; I < x.length; ++I) {
      var P = x.charCodeAt(I);
      if (P === 45 || P === 46 || P === 95 || P === 126 || P >= 48 && P <= 57 || P >= 65 && P <= 90 || P >= 97 && P <= 122 || S === n.RFC1738 && (P === 40 || P === 41)) {
        A += x.charAt(I);
        continue;
      }
      if (P < 128) {
        A = A + o[P];
        continue;
      }
      if (P < 2048) {
        A = A + (o[192 | P >> 6] + o[128 | P & 63]);
        continue;
      }
      if (P < 55296 || P >= 57344) {
        A = A + (o[224 | P >> 12] + o[128 | P >> 6 & 63] + o[128 | P & 63]);
        continue;
      }
      I += 1, P = 65536 + ((P & 1023) << 10 | x.charCodeAt(I) & 1023), A += o[240 | P >> 18] + o[128 | P >> 12 & 63] + o[128 | P >> 6 & 63] + o[128 | P & 63];
    }
    return A;
  }, p = function(g) {
    for (var v = [{ obj: { o: g }, prop: "o" }], b = [], _ = 0; _ < v.length; ++_)
      for (var S = v[_], x = S.obj[S.prop], A = Object.keys(x), I = 0; I < A.length; ++I) {
        var P = A[I], R = x[P];
        typeof R == "object" && R !== null && b.indexOf(R) === -1 && (v.push({ obj: x, prop: P }), b.push(R));
      }
    return a(v), g;
  }, f = function(g) {
    return Object.prototype.toString.call(g) === "[object RegExp]";
  }, h = function(g) {
    return !g || typeof g != "object" ? !1 : !!(g.constructor && g.constructor.isBuffer && g.constructor.isBuffer(g));
  }, m = function(g, v) {
    return [].concat(g, v);
  }, y = function(g, v) {
    if (i(g)) {
      for (var b = [], _ = 0; _ < g.length; _ += 1)
        b.push(v(g[_]));
      return b;
    }
    return v(g);
  };
  t.exports = { arrayToObject: s, assign: l, combine: m, compact: p, decode: u, encode: d, isBuffer: h, isRegExp: f, maybeMap: y, merge: c };
}), xO = cn((e, t) => {
  var n = wO(), r = P0(), i = Xh(), o = Object.prototype.hasOwnProperty, a = { brackets: function(v) {
    return v + "[]";
  }, comma: "comma", indices: function(v, b) {
    return v + "[" + b + "]";
  }, repeat: function(v) {
    return v;
  } }, s = Array.isArray, c = String.prototype.split, l = Array.prototype.push, u = function(v, b) {
    l.apply(v, s(b) ? b : [b]);
  }, d = Date.prototype.toISOString, p = i.default, f = { addQueryPrefix: !1, allowDots: !1, charset: "utf-8", charsetSentinel: !1, delimiter: "&", encode: !0, encoder: r.encode, encodeValuesOnly: !1, format: p, formatter: i.formatters[p], indices: !1, serializeDate: function(v) {
    return d.call(v);
  }, skipNulls: !1, strictNullHandling: !1 }, h = function(v) {
    return typeof v == "string" || typeof v == "number" || typeof v == "boolean" || typeof v == "symbol" || typeof v == "bigint";
  }, m = {}, y = function v(b, _, S, x, A, I, P, R, M, V, U, L, $, j, z, H) {
    for (var X = b, E = H, ee = 0, de = !1; (E = E.get(m)) !== void 0 && !de; ) {
      var T = E.get(b);
      if (ee += 1, typeof T < "u") {
        if (T === ee)
          throw new RangeError("Cyclic object value");
        de = !0;
      }
      typeof E.get(m) > "u" && (ee = 0);
    }
    if (typeof R == "function" ? X = R(_, X) : X instanceof Date ? X = U(X) : S === "comma" && s(X) && (X = r.maybeMap(X, function(ie) {
      return ie instanceof Date ? U(ie) : ie;
    })), X === null) {
      if (A)
        return P && !j ? P(_, f.encoder, z, "key", L) : _;
      X = "";
    }
    if (h(X) || r.isBuffer(X)) {
      if (P) {
        var be = j ? _ : P(_, f.encoder, z, "key", L);
        if (S === "comma" && j) {
          for (var ke = c.call(String(X), ","), Se = "", Pe = 0; Pe < ke.length; ++Pe)
            Se += (Pe === 0 ? "" : ",") + $(P(ke[Pe], f.encoder, z, "value", L));
          return [$(be) + (x && s(X) && ke.length === 1 ? "[]" : "") + "=" + Se];
        }
        return [$(be) + "=" + $(P(X, f.encoder, z, "value", L))];
      }
      return [$(_) + "=" + $(String(X))];
    }
    var Be = [];
    if (typeof X > "u")
      return Be;
    var Ae;
    if (S === "comma" && s(X))
      Ae = [{ value: X.length > 0 ? X.join(",") || null : void 0 }];
    else if (s(R))
      Ae = R;
    else {
      var pe = Object.keys(X);
      Ae = M ? pe.sort(M) : pe;
    }
    for (var ue = x && s(X) && X.length === 1 ? _ + "[]" : _, xe = 0; xe < Ae.length; ++xe) {
      var fe = Ae[xe], $e = typeof fe == "object" && typeof fe.value < "u" ? fe.value : X[fe];
      if (!(I && $e === null)) {
        var nt = s(X) ? typeof S == "function" ? S(ue, fe) : ue : ue + (V ? "." + fe : "[" + fe + "]");
        H.set(b, ee);
        var q = n();
        q.set(m, H), u(Be, v($e, nt, S, x, A, I, P, R, M, V, U, L, $, j, z, q));
      }
    }
    return Be;
  }, g = function(v) {
    if (!v)
      return f;
    if (v.encoder !== null && typeof v.encoder < "u" && typeof v.encoder != "function")
      throw new TypeError("Encoder has to be a function.");
    var b = v.charset || f.charset;
    if (typeof v.charset < "u" && v.charset !== "utf-8" && v.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var _ = i.default;
    if (typeof v.format < "u") {
      if (!o.call(i.formatters, v.format))
        throw new TypeError("Unknown format option provided.");
      _ = v.format;
    }
    var S = i.formatters[_], x = f.filter;
    return (typeof v.filter == "function" || s(v.filter)) && (x = v.filter), { addQueryPrefix: typeof v.addQueryPrefix == "boolean" ? v.addQueryPrefix : f.addQueryPrefix, allowDots: typeof v.allowDots > "u" ? f.allowDots : !!v.allowDots, charset: b, charsetSentinel: typeof v.charsetSentinel == "boolean" ? v.charsetSentinel : f.charsetSentinel, delimiter: typeof v.delimiter > "u" ? f.delimiter : v.delimiter, encode: typeof v.encode == "boolean" ? v.encode : f.encode, encoder: typeof v.encoder == "function" ? v.encoder : f.encoder, encodeValuesOnly: typeof v.encodeValuesOnly == "boolean" ? v.encodeValuesOnly : f.encodeValuesOnly, filter: x, format: _, formatter: S, serializeDate: typeof v.serializeDate == "function" ? v.serializeDate : f.serializeDate, skipNulls: typeof v.skipNulls == "boolean" ? v.skipNulls : f.skipNulls, sort: typeof v.sort == "function" ? v.sort : null, strictNullHandling: typeof v.strictNullHandling == "boolean" ? v.strictNullHandling : f.strictNullHandling };
  };
  t.exports = function(v, b) {
    var _ = v, S = g(b), x, A;
    typeof S.filter == "function" ? (A = S.filter, _ = A("", _)) : s(S.filter) && (A = S.filter, x = A);
    var I = [];
    if (typeof _ != "object" || _ === null)
      return "";
    var P;
    b && b.arrayFormat in a ? P = b.arrayFormat : b && "indices" in b ? P = b.indices ? "indices" : "repeat" : P = "indices";
    var R = a[P];
    if (b && "commaRoundTrip" in b && typeof b.commaRoundTrip != "boolean")
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var M = R === "comma" && b && b.commaRoundTrip;
    x || (x = Object.keys(_)), S.sort && x.sort(S.sort);
    for (var V = n(), U = 0; U < x.length; ++U) {
      var L = x[U];
      S.skipNulls && _[L] === null || u(I, y(_[L], L, R, M, S.strictNullHandling, S.skipNulls, S.encode ? S.encoder : null, S.filter, S.sort, S.allowDots, S.serializeDate, S.format, S.formatter, S.encodeValuesOnly, S.charset, V));
    }
    var $ = I.join(S.delimiter), j = S.addQueryPrefix === !0 ? "?" : "";
    return S.charsetSentinel && (S.charset === "iso-8859-1" ? j += "utf8=%26%2310003%3B&" : j += "utf8=%E2%9C%93&"), $.length > 0 ? j + $ : "";
  };
}), _O = cn((e, t) => {
  var n = P0(), r = Object.prototype.hasOwnProperty, i = Array.isArray, o = { allowDots: !1, allowPrototypes: !1, allowSparse: !1, arrayLimit: 20, charset: "utf-8", charsetSentinel: !1, comma: !1, decoder: n.decode, delimiter: "&", depth: 5, ignoreQueryPrefix: !1, interpretNumericEntities: !1, parameterLimit: 1e3, parseArrays: !0, plainObjects: !1, strictNullHandling: !1 }, a = function(h) {
    return h.replace(/&#(\d+);/g, function(m, y) {
      return String.fromCharCode(parseInt(y, 10));
    });
  }, s = function(h, m) {
    return h && typeof h == "string" && m.comma && h.indexOf(",") > -1 ? h.split(",") : h;
  }, c = "utf8=%26%2310003%3B", l = "utf8=%E2%9C%93", u = function(h, m) {
    var y = {}, g = m.ignoreQueryPrefix ? h.replace(/^\?/, "") : h, v = m.parameterLimit === 1 / 0 ? void 0 : m.parameterLimit, b = g.split(m.delimiter, v), _ = -1, S, x = m.charset;
    if (m.charsetSentinel)
      for (S = 0; S < b.length; ++S)
        b[S].indexOf("utf8=") === 0 && (b[S] === l ? x = "utf-8" : b[S] === c && (x = "iso-8859-1"), _ = S, S = b.length);
    for (S = 0; S < b.length; ++S)
      if (S !== _) {
        var A = b[S], I = A.indexOf("]="), P = I === -1 ? A.indexOf("=") : I + 1, R, M;
        P === -1 ? (R = m.decoder(A, o.decoder, x, "key"), M = m.strictNullHandling ? null : "") : (R = m.decoder(A.slice(0, P), o.decoder, x, "key"), M = n.maybeMap(s(A.slice(P + 1), m), function(V) {
          return m.decoder(V, o.decoder, x, "value");
        })), M && m.interpretNumericEntities && x === "iso-8859-1" && (M = a(M)), A.indexOf("[]=") > -1 && (M = i(M) ? [M] : M), r.call(y, R) ? y[R] = n.combine(y[R], M) : y[R] = M;
      }
    return y;
  }, d = function(h, m, y, g) {
    for (var v = g ? m : s(m, y), b = h.length - 1; b >= 0; --b) {
      var _, S = h[b];
      if (S === "[]" && y.parseArrays)
        _ = [].concat(v);
      else {
        _ = y.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var x = S.charAt(0) === "[" && S.charAt(S.length - 1) === "]" ? S.slice(1, -1) : S, A = parseInt(x, 10);
        !y.parseArrays && x === "" ? _ = { 0: v } : !isNaN(A) && S !== x && String(A) === x && A >= 0 && y.parseArrays && A <= y.arrayLimit ? (_ = [], _[A] = v) : x !== "__proto__" && (_[x] = v);
      }
      v = _;
    }
    return v;
  }, p = function(h, m, y, g) {
    if (h) {
      var v = y.allowDots ? h.replace(/\.([^.[]+)/g, "[$1]") : h, b = /(\[[^[\]]*])/, _ = /(\[[^[\]]*])/g, S = y.depth > 0 && b.exec(v), x = S ? v.slice(0, S.index) : v, A = [];
      if (x) {
        if (!y.plainObjects && r.call(Object.prototype, x) && !y.allowPrototypes)
          return;
        A.push(x);
      }
      for (var I = 0; y.depth > 0 && (S = _.exec(v)) !== null && I < y.depth; ) {
        if (I += 1, !y.plainObjects && r.call(Object.prototype, S[1].slice(1, -1)) && !y.allowPrototypes)
          return;
        A.push(S[1]);
      }
      return S && A.push("[" + v.slice(S.index) + "]"), d(A, m, y, g);
    }
  }, f = function(h) {
    if (!h)
      return o;
    if (h.decoder !== null && h.decoder !== void 0 && typeof h.decoder != "function")
      throw new TypeError("Decoder has to be a function.");
    if (typeof h.charset < "u" && h.charset !== "utf-8" && h.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var m = typeof h.charset > "u" ? o.charset : h.charset;
    return { allowDots: typeof h.allowDots > "u" ? o.allowDots : !!h.allowDots, allowPrototypes: typeof h.allowPrototypes == "boolean" ? h.allowPrototypes : o.allowPrototypes, allowSparse: typeof h.allowSparse == "boolean" ? h.allowSparse : o.allowSparse, arrayLimit: typeof h.arrayLimit == "number" ? h.arrayLimit : o.arrayLimit, charset: m, charsetSentinel: typeof h.charsetSentinel == "boolean" ? h.charsetSentinel : o.charsetSentinel, comma: typeof h.comma == "boolean" ? h.comma : o.comma, decoder: typeof h.decoder == "function" ? h.decoder : o.decoder, delimiter: typeof h.delimiter == "string" || n.isRegExp(h.delimiter) ? h.delimiter : o.delimiter, depth: typeof h.depth == "number" || h.depth === !1 ? +h.depth : o.depth, ignoreQueryPrefix: h.ignoreQueryPrefix === !0, interpretNumericEntities: typeof h.interpretNumericEntities == "boolean" ? h.interpretNumericEntities : o.interpretNumericEntities, parameterLimit: typeof h.parameterLimit == "number" ? h.parameterLimit : o.parameterLimit, parseArrays: h.parseArrays !== !1, plainObjects: typeof h.plainObjects == "boolean" ? h.plainObjects : o.plainObjects, strictNullHandling: typeof h.strictNullHandling == "boolean" ? h.strictNullHandling : o.strictNullHandling };
  };
  t.exports = function(h, m) {
    var y = f(m);
    if (h === "" || h === null || typeof h > "u")
      return y.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    for (var g = typeof h == "string" ? u(h, y) : h, v = y.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, b = Object.keys(g), _ = 0; _ < b.length; ++_) {
      var S = b[_], x = p(S, g[S], y, typeof h == "string");
      v = n.merge(v, x, y);
    }
    return y.allowSparse === !0 ? v : n.compact(v);
  };
}), SO = cn((e, t) => {
  var n = xO(), r = _O(), i = Xh();
  t.exports = { formats: i, parse: r, stringify: n };
}), $0 = {};
aO($0, { DEFAULT_OPTIONS: () => q0, default: () => L0, exponentialDelay: () => j0, isIdempotentRequestError: () => em, isNetworkError: () => Qh, isNetworkOrIdempotentRequestError: () => tm, isRetryableError: () => fd, isSafeRequestError: () => N0, linearDelay: () => M0, namespace: () => dd, retryAfter: () => pd });
var kO = ud(cO(), 1), dd = "axios-retry";
function Qh(e) {
  let t = ["ERR_CANCELED", "ECONNABORTED"];
  return e.response || !e.code || t.includes(e.code) ? !1 : (0, kO.default)(e);
}
var D0 = ["get", "head", "options"], EO = D0.concat(["put", "delete"]);
function fd(e) {
  return e.code !== "ECONNABORTED" && (!e.response || e.response.status === 429 || e.response.status >= 500 && e.response.status <= 599);
}
function N0(e) {
  var t;
  return (t = e.config) != null && t.method ? fd(e) && D0.indexOf(e.config.method) !== -1 : !1;
}
function em(e) {
  var t;
  return (t = e.config) != null && t.method ? fd(e) && EO.indexOf(e.config.method) !== -1 : !1;
}
function tm(e) {
  return Qh(e) || em(e);
}
function pd(e = void 0) {
  var r;
  let t = (r = e == null ? void 0 : e.response) == null ? void 0 : r.headers["retry-after"];
  if (!t)
    return 0;
  let n = (Number(t) || 0) * 1e3;
  return n === 0 && (n = (new Date(t).valueOf() || 0) - Date.now()), Math.max(0, n);
}
function CO(e = 0, t = void 0) {
  return Math.max(0, pd(t));
}
function j0(e = 0, t = void 0, n = 100) {
  let r = 2 ** e * n, i = Math.max(r, pd(t)), o = i * 0.2 * Math.random();
  return i + o;
}
function M0(e = 100) {
  return (t = 0, n = void 0) => {
    let r = t * e;
    return Math.max(r, pd(n));
  };
}
var q0 = { retries: 3, retryCondition: tm, retryDelay: CO, shouldResetTimeout: !1, onRetry: () => {
}, onMaxRetryTimesExceeded: () => {
}, validateResponse: null };
function TO(e, t) {
  return { ...q0, ...t, ...e[dd] };
}
function Zy(e, t, n = !1) {
  let r = TO(e, t || {});
  return r.retryCount = r.retryCount || 0, (!r.lastRequestTime || n) && (r.lastRequestTime = Date.now()), e[dd] = r, r;
}
function RO(e, t) {
  e.defaults.agent === t.agent && delete t.agent, e.defaults.httpAgent === t.httpAgent && delete t.httpAgent, e.defaults.httpsAgent === t.httpsAgent && delete t.httpsAgent;
}
async function AO(e, t) {
  let { retries: n, retryCondition: r } = e, i = (e.retryCount || 0) < n && r(t);
  if (typeof i == "object")
    try {
      return await i !== !1;
    } catch {
      return !1;
    }
  return i;
}
async function OO(e, t, n, r) {
  var c;
  t.retryCount += 1;
  let { retryDelay: i, shouldResetTimeout: o, onRetry: a } = t, s = i(t.retryCount, n);
  if (RO(e, r), !o && r.timeout && t.lastRequestTime) {
    let l = Date.now() - t.lastRequestTime, u = r.timeout - l - s;
    if (u <= 0)
      return Promise.reject(n);
    r.timeout = u;
  }
  return r.transformRequest = [(l) => l], await a(t.retryCount, n, r), (c = r.signal) != null && c.aborted ? Promise.resolve(e(r)) : new Promise((l) => {
    var p;
    let u = () => {
      clearTimeout(d), l(e(r));
    }, d = setTimeout(() => {
      var f;
      l(e(r)), (f = r.signal) != null && f.removeEventListener && r.signal.removeEventListener("abort", u);
    }, s);
    (p = r.signal) != null && p.addEventListener && r.signal.addEventListener("abort", u, { once: !0 });
  });
}
async function IO(e, t) {
  e.retryCount >= e.retries && await e.onMaxRetryTimesExceeded(t, e.retryCount);
}
var Hi = (e, t) => {
  let n = e.interceptors.request.use((i) => {
    var o;
    return Zy(i, t, !0), (o = i[dd]) != null && o.validateResponse && (i.validateStatus = () => !1), i;
  }), r = e.interceptors.response.use(null, async (i) => {
    var s;
    let { config: o } = i;
    if (!o)
      return Promise.reject(i);
    let a = Zy(o, t);
    return i.response && ((s = a.validateResponse) != null && s.call(a, i.response)) ? i.response : await AO(a, i) ? OO(e, a, i, o) : (await IO(a, i), Promise.reject(i));
  });
  return { requestInterceptorId: n, responseInterceptorId: r };
};
Hi.isNetworkError = Qh;
Hi.isSafeRequestError = N0;
Hi.isIdempotentRequestError = em;
Hi.isNetworkOrIdempotentRequestError = tm;
Hi.exponentialDelay = j0;
Hi.linearDelay = M0;
Hi.isRetryableError = fd;
var L0 = Hi, PO = { getRandomValues: (e) => new Uint8Array(e.map(() => Math.floor(Math.random() * 256))) }, xp = typeof window < "u" && typeof window.document < "u" ? window.crypto : Bh;
xp.getRandomValues || (xp = PO);
var Ft = class extends Error {
  constructor(t, n, r, i, o, a) {
    super(i);
    k(this, "isApiError", !0);
    this.code = t, this.description = n, this.type = r, this.message = i, this.error = o, this.id = a, this.id || (this.id = Ft.generateId());
  }
  format() {
    return `[${this.type}] ${this.message} (Error ID: ${this.id})`;
  }
  toJSON() {
    return { id: this.id, code: this.code, type: this.type, message: this.message };
  }
  static generateId() {
    let t = this.getPrefix(), n = (/* @__PURE__ */ new Date()).toISOString().replace(/[\-:TZ]/g, "").split(".")[0], r = 4, i = Array.from(xp.getRandomValues(new Uint8Array(r))).map((o) => o.toString(16).padStart(2, "0")).join("").toUpperCase();
    return `${t}_${n}x${i}`;
  }
  static getPrefix() {
    return typeof window < "u" && typeof window.document < "u" ? "err_bwsr" : "err";
  }
}, $O = (e) => typeof e == "object" && !Array.isArray(e) && e !== null, F0 = (e) => e instanceof Ft || $O(e) && e.isApiError === !0, pa = class extends Ft {
  constructor(e, t, n) {
    super(500, "An unknown error occurred", "Unknown", e, t, n);
  }
}, U0 = class extends Ft {
  constructor(t, n, r) {
    super(500, "An internal error occurred", "Internal", t, n, r);
  }
}, B0 = class extends Ft {
  constructor(e, t, n) {
    super(401, "The request requires to be authenticated.", "Unauthorized", e, t, n);
  }
}, z0 = class extends Ft {
  constructor(e, t, n) {
    super(403, "The requested action can't be peform by this resource.", "Forbidden", e, t, n);
  }
}, Z0 = class extends Ft {
  constructor(e, t, n) {
    super(413, "The request payload is too large.", "PayloadTooLarge", e, t, n);
  }
}, V0 = class extends Ft {
  constructor(e, t, n) {
    super(400, "The request payload is invalid.", "InvalidPayload", e, t, n);
  }
}, H0 = class extends Ft {
  constructor(t, n, r) {
    super(415, "The request is invalid because the content-type is not supported.", "UnsupportedMediaType", t, n, r);
  }
}, W0 = class extends Ft {
  constructor(e, t, n) {
    super(405, "The requested method does not exist.", "MethodNotFound", e, t, n);
  }
}, K0 = class extends Ft {
  constructor(e, t, n) {
    super(404, "The requested resource does not exist.", "ResourceNotFound", e, t, n);
  }
}, J0 = class extends Ft {
  constructor(e, t, n) {
    super(400, "The provided JSON schema is invalid.", "InvalidJsonSchema", e, t, n);
  }
}, Y0 = class extends Ft {
  constructor(e, t, n) {
    super(400, "The provided data doesn't respect the provided JSON schema.", "InvalidDataFormat", e, t, n);
  }
}, G0 = class extends Ft {
  constructor(e, t, n) {
    super(400, "The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.", "InvalidIdentifier", e, t, n);
  }
}, X0 = class extends Ft {
  constructor(e, t, n) {
    super(409, "The resource is related with a different resource that the one referenced in the request. This is usually caused when providing two resource identifiers that aren't linked together.", "RelationConflict", e, t, n);
  }
}, Q0 = class extends Ft {
  constructor(t, n, r) {
    super(409, "The resource cannot be deleted because it's referenced by another resource", "ReferenceConstraint", t, n, r);
  }
}, e_ = class extends Ft {
  constructor(e, t, n) {
    super(409, "The resource is current locked and cannot be operated on until the lock is released.", "ResourceLockedConflict", e, t, n);
  }
}, t_ = class extends Ft {
  constructor(e, t, n) {
    super(400, "The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.", "ReferenceNotFound", e, t, n);
  }
}, n_ = class extends Ft {
  constructor(e, t, n) {
    super(400, "The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.", "InvalidQuery", e, t, n);
  }
}, r_ = class extends Ft {
  constructor(e, t, n) {
    super(400, "An error happened during the execution of a runtime (bot or integration).", "Runtime", e, t, n);
  }
}, i_ = class extends Ft {
  constructor(e, t, n) {
    super(409, "The record attempted to be created already exists.", "AlreadyExists", e, t, n);
  }
}, o_ = class extends Ft {
  constructor(e, t, n) {
    super(429, "The request has been rate limited.", "RateLimited", e, t, n);
  }
}, a_ = class extends Ft {
  constructor(e, t, n) {
    super(402, "A payment is required to perform this request.", "PaymentRequired", e, t, n);
  }
}, s_ = class extends Ft {
  constructor(e, t, n) {
    super(403, "The request exceeds the allowed quota. Quotas are a soft limit that can be increased.", "QuotaExceeded", e, t, n);
  }
}, c_ = class extends Ft {
  constructor(e, t, n) {
    super(413, "The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.", "LimitExceeded", e, t, n);
  }
}, l_ = class extends Ft {
  constructor(e, t, n) {
    super(400, "Request payload contains breaking changes which is not allowed for this resource without a version increment.", "BreakingChanges", e, t, n);
  }
}, DO = { Unknown: pa, Internal: U0, Unauthorized: B0, Forbidden: z0, PayloadTooLarge: Z0, InvalidPayload: V0, UnsupportedMediaType: H0, MethodNotFound: W0, ResourceNotFound: K0, InvalidJsonSchema: J0, InvalidDataFormat: Y0, InvalidIdentifier: G0, RelationConflict: X0, ReferenceConstraint: Q0, ResourceLockedConflict: e_, ReferenceNotFound: t_, InvalidQuery: n_, Runtime: r_, AlreadyExists: i_, RateLimited: o_, PaymentRequired: a_, QuotaExceeded: s_, LimitExceeded: c_, BreakingChanges: l_ }, _p = (e) => F0(e) ? e : e instanceof Error ? new pa(e.message, e) : typeof e == "string" ? new pa(e) : NO(e);
function NO(e) {
  if (typeof e == "object" && "code" in e && "type" in e && "id" in e && "message" in e && typeof e.type == "string" && typeof e.message == "string") {
    let t = DO[e.type];
    return t ? new t(e.message, void 0, e.id || "UNKNOWN") : new pa(`An unclassified API error occurred: ${e.message} (Type: ${e.type}, Code: ${e.code})`);
  }
  return new pa("An invalid error occurred: " + JSON.stringify(e));
}
var zo = class extends Error {
  constructor(t, n, r) {
    super(t), this.innerError = n, this.file = r, this.name = "FileUploadError";
  }
}, jO = ud(lO()), MO = ud(uO()), qO = "https://api.botpress.cloud", LO = 6e4, FO = "BP_API_URL", UO = "BP_BOT_ID", BO = "BP_INTEGRATION_ID", zO = "BP_WORKSPACE_ID", ZO = "BP_TOKEN";
function VO(e) {
  let t = HO(e), n = {};
  t.workspaceId && (n["x-workspace-id"] = t.workspaceId), t.botId && (n["x-bot-id"] = t.botId), t.integrationId && (n["x-integration-id"] = t.integrationId), t.token && (n.Authorization = `Bearer ${t.token}`), n = { ...n, ...t.headers };
  let r = t.apiUrl ?? qO, i = t.timeout ?? LO;
  return { apiUrl: r, timeout: i, withCredentials: I0, headers: n };
}
function HO(e) {
  return I0 ? e : wp ? WO(e) : e;
}
function WO(e) {
  let t = { ...e, apiUrl: e.apiUrl ?? process.env[FO], botId: e.botId ?? process.env[UO], integrationId: e.integrationId ?? process.env[BO], workspaceId: e.workspaceId ?? process.env[zO] }, n = t.token ?? process.env[ZO];
  return n && (t.token = n), t;
}
var KO = ud(SO()), JO = (e) => e[1] !== void 0, Y = (e) => {
  let { method: t, path: n, query: r, headers: i, body: o } = e, a = Object.entries(i).filter(JO), s = Object.fromEntries(a), c = KO.default.stringify(r, { encode: !0, arrayFormat: "repeat", allowDots: !0 }), l = c ? [n, c].join("?") : n;
  return { method: t, url: l, headers: s, data: o };
}, YO = (e) => ({ path: "/v1/chat/conversations", headers: {}, query: {}, params: {}, body: { channel: e.channel, tags: e.tags, integrationName: e.integrationName } }), GO = (e) => ({ path: `/v1/chat/conversations/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), XO = (e) => ({ path: "/v1/chat/conversations", headers: {}, query: { nextToken: e.nextToken, sortField: e.sortField, sortDirection: e.sortDirection, tags: e.tags, participantIds: e.participantIds, integrationName: e.integrationName }, params: {}, body: {} }), QO = (e) => ({ path: "/v1/chat/conversations/get-or-create", headers: {}, query: {}, params: {}, body: { channel: e.channel, tags: e.tags, integrationName: e.integrationName } }), eI = (e) => ({ path: `/v1/chat/conversations/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: { currentTaskId: e.currentTaskId, tags: e.tags } }), tI = (e) => ({ path: `/v1/chat/conversations/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), nI = (e) => ({ path: `/v1/chat/conversations/${encodeURIComponent(e.id)}/participants`, headers: {}, query: { nextToken: e.nextToken }, params: { id: e.id }, body: {} }), rI = (e) => ({ path: `/v1/chat/conversations/${encodeURIComponent(e.id)}/participants`, headers: {}, query: {}, params: { id: e.id }, body: { userId: e.userId } }), iI = (e) => ({ path: `/v1/chat/conversations/${encodeURIComponent(e.id)}/participants/${encodeURIComponent(e.userId)}`, headers: {}, query: {}, params: { id: e.id, userId: e.userId }, body: {} }), oI = (e) => ({ path: `/v1/chat/conversations/${encodeURIComponent(e.id)}/participants/${encodeURIComponent(e.userId)}`, headers: {}, query: {}, params: { id: e.id, userId: e.userId }, body: {} }), aI = (e) => ({ path: "/v1/chat/events", headers: {}, query: {}, params: {}, body: { type: e.type, payload: e.payload, schedule: e.schedule, conversationId: e.conversationId, userId: e.userId, messageId: e.messageId } }), sI = (e) => ({ path: `/v1/chat/events/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), cI = (e) => ({ path: "/v1/chat/events", headers: {}, query: { nextToken: e.nextToken, type: e.type, conversationId: e.conversationId, userId: e.userId, messageId: e.messageId, status: e.status }, params: {}, body: {} }), lI = (e) => ({ path: "/v1/chat/messages", headers: {}, query: {}, params: {}, body: { payload: e.payload, userId: e.userId, conversationId: e.conversationId, type: e.type, tags: e.tags, schedule: e.schedule } }), uI = (e) => ({ path: "/v1/chat/messages/get-or-create", headers: {}, query: {}, params: {}, body: { payload: e.payload, userId: e.userId, conversationId: e.conversationId, type: e.type, tags: e.tags, schedule: e.schedule } }), dI = (e) => ({ path: `/v1/chat/messages/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), fI = (e) => ({ path: `/v1/chat/messages/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: { tags: e.tags } }), pI = (e) => ({ path: "/v1/chat/messages", headers: {}, query: { nextToken: e.nextToken, conversationId: e.conversationId, tags: e.tags }, params: {}, body: {} }), hI = (e) => ({ path: `/v1/chat/messages/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), mI = (e) => ({ path: "/v1/chat/users", headers: {}, query: {}, params: {}, body: { tags: e.tags, integrationName: e.integrationName, name: e.name, pictureUrl: e.pictureUrl } }), yI = (e) => ({ path: `/v1/chat/users/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), gI = (e) => ({ path: "/v1/chat/users", headers: {}, query: { nextToken: e.nextToken, conversationId: e.conversationId, tags: e.tags }, params: {}, body: {} }), vI = (e) => ({ path: "/v1/chat/users/get-or-create", headers: {}, query: {}, params: {}, body: { tags: e.tags, integrationName: e.integrationName, name: e.name, pictureUrl: e.pictureUrl } }), bI = (e) => ({ path: `/v1/chat/users/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: { tags: e.tags, name: e.name, pictureUrl: e.pictureUrl } }), wI = (e) => ({ path: `/v1/chat/users/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), xI = (e) => ({ path: `/v1/chat/states/${encodeURIComponent(e.type)}/${encodeURIComponent(e.id)}/${encodeURIComponent(e.name)}`, headers: {}, query: {}, params: { type: e.type, id: e.id, name: e.name }, body: {} }), _I = (e) => ({ path: `/v1/chat/states/${encodeURIComponent(e.type)}/${encodeURIComponent(e.id)}/${encodeURIComponent(e.name)}`, headers: {}, query: {}, params: { type: e.type, id: e.id, name: e.name }, body: { payload: e.payload, expiry: e.expiry } }), SI = (e) => ({ path: `/v1/chat/states/${encodeURIComponent(e.type)}/${encodeURIComponent(e.id)}/${encodeURIComponent(e.name)}/get-or-set`, headers: {}, query: {}, params: { type: e.type, id: e.id, name: e.name }, body: { payload: e.payload, expiry: e.expiry } }), kI = (e) => ({ path: `/v1/chat/states/${encodeURIComponent(e.type)}/${encodeURIComponent(e.id)}/${encodeURIComponent(e.name)}`, headers: {}, query: {}, params: { type: e.type, id: e.id, name: e.name }, body: { payload: e.payload } }), EI = (e) => ({ path: "/v1/chat/actions", headers: {}, query: {}, params: {}, body: { type: e.type, input: e.input } }), CI = (e) => ({ path: "/v1/chat/integrations/configure", headers: {}, query: {}, params: {}, body: { identifier: e.identifier } }), TI = (e) => ({ path: `/v1/chat/tasks/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), RI = (e) => ({ path: "/v1/chat/tasks", headers: {}, query: {}, params: {}, body: { title: e.title, description: e.description, type: e.type, data: e.data, parentTaskId: e.parentTaskId, conversationId: e.conversationId, userId: e.userId, timeoutAt: e.timeoutAt, tags: e.tags } }), AI = (e) => ({ path: `/v1/chat/tasks/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: { title: e.title, description: e.description, data: e.data, timeoutAt: e.timeoutAt, status: e.status, tags: e.tags } }), OI = (e) => ({ path: `/v1/chat/tasks/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), II = (e) => ({ path: "/v1/chat/tasks", headers: {}, query: { nextToken: e.nextToken, tags: e.tags, conversationId: e.conversationId, userId: e.userId, parentTaskId: e.parentTaskId, status: e.status, type: e.type }, params: {}, body: {} }), PI = (e) => ({ path: "/v1/chat/analytics", headers: {}, query: {}, params: {}, body: { name: e.name, count: e.count } }), $I = (e) => ({ path: "/v1/admin/helper/vrl", headers: {}, query: {}, params: {}, body: { data: e.data, script: e.script } }), DI = (e) => ({ path: "/v1/admin/account/me", headers: {}, query: {}, params: {}, body: {} }), NI = (e) => ({ path: "/v1/admin/account/me", headers: {}, query: {}, params: {}, body: { displayName: e.displayName, profilePicture: e.profilePicture, refresh: e.refresh } }), jI = (e) => ({ path: "/v1/admin/account/pats", headers: {}, query: {}, params: {}, body: {} }), MI = (e) => ({ path: "/v1/admin/account/pats", headers: {}, query: {}, params: {}, body: { note: e.note } }), qI = (e) => ({ path: `/v1/admin/account/pats/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), LI = (e) => ({ path: `/v1/admin/account/preferences/${encodeURIComponent(e.key)}`, headers: {}, query: {}, params: { key: e.key }, body: { value: e.value } }), FI = (e) => ({ path: `/v1/admin/account/preferences/${encodeURIComponent(e.key)}`, headers: {}, query: {}, params: { key: e.key }, body: {} }), UI = (e) => ({ path: "/v1/admin/hub/integrations", headers: {}, query: { nextToken: e.nextToken, name: e.name, version: e.version }, params: {}, body: {} }), BI = (e) => ({ path: `/v1/admin/hub/integrations/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), zI = (e) => ({ path: `/v1/admin/hub/integrations/${encodeURIComponent(e.name)}/${encodeURIComponent(e.version)}`, headers: {}, query: {}, params: { name: e.name, version: e.version }, body: {} }), ZI = (e) => ({ path: "/v1/admin/bots", headers: {}, query: {}, params: {}, body: { states: e.states, events: e.events, recurringEvents: e.recurringEvents, subscriptions: e.subscriptions, actions: e.actions, configuration: e.configuration, user: e.user, conversation: e.conversation, message: e.message, code: e.code, name: e.name, medias: e.medias, url: e.url, dev: e.dev } }), VI = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: { url: e.url, authentication: e.authentication, configuration: e.configuration, blocked: e.blocked, alwaysAlive: e.alwaysAlive, user: e.user, message: e.message, conversation: e.conversation, events: e.events, actions: e.actions, states: e.states, recurringEvents: e.recurringEvents, integrations: e.integrations, subscriptions: e.subscriptions, code: e.code, name: e.name, medias: e.medias } }), HI = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}/transfer`, headers: {}, query: {}, params: { id: e.id }, body: { targetWorkspaceId: e.targetWorkspaceId } }), WI = (e) => ({ path: "/v1/admin/bots", headers: {}, query: { dev: e.dev, nextToken: e.nextToken, sortField: e.sortField, sortDirection: e.sortDirection }, params: {}, body: {} }), KI = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), JI = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), YI = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}/logs`, headers: {}, query: { timeStart: e.timeStart, timeEnd: e.timeEnd, nextToken: e.nextToken }, params: { id: e.id }, body: {} }), GI = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}/webchat`, headers: {}, query: { type: e.type }, params: { id: e.id }, body: {} }), XI = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}/analytics`, headers: {}, query: { startDate: e.startDate, endDate: e.endDate }, params: { id: e.id }, body: {} }), QI = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}/issues/${encodeURIComponent(e.issueId)}`, headers: {}, query: {}, params: { id: e.id, issueId: e.issueId }, body: {} }), eP = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}/issues`, headers: {}, query: { nextToken: e.nextToken }, params: { id: e.id }, body: {} }), tP = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}/issues/${encodeURIComponent(e.issueId)}`, headers: {}, query: {}, params: { id: e.id, issueId: e.issueId }, body: {} }), nP = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}/issues/${encodeURIComponent(e.issueId)}/events`, headers: {}, query: {}, params: { id: e.id, issueId: e.issueId }, body: {} }), rP = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}/versions`, headers: {}, query: {}, params: { id: e.id }, body: {} }), iP = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}/versions/${encodeURIComponent(e.versionId)}`, headers: {}, query: {}, params: { id: e.id, versionId: e.versionId }, body: {} }), oP = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}/versions`, headers: {}, query: {}, params: { id: e.id }, body: { name: e.name, description: e.description } }), aP = (e) => ({ path: `/v1/admin/bots/${encodeURIComponent(e.id)}/versions/deploy`, headers: {}, query: {}, params: { id: e.id }, body: { versionId: e.versionId } }), sP = (e) => ({ path: `/v1/admin/workspaces/${encodeURIComponent(e.id)}/billing/payment-method`, headers: {}, query: {}, params: { id: e.id }, body: { stripePaymentMethodId: e.stripePaymentMethodId } }), cP = (e) => ({ path: `/v1/admin/workspaces/${encodeURIComponent(e.id)}/billing/invoices`, headers: {}, query: {}, params: { id: e.id }, body: {} }), lP = (e) => ({ path: `/v1/admin/workspaces/${encodeURIComponent(e.id)}/billing/upcoming-invoice`, headers: {}, query: {}, params: { id: e.id }, body: {} }), uP = (e) => ({ path: `/v1/admin/workspaces/${encodeURIComponent(e.id)}/billing/invoices/charge-unpaid`, headers: {}, query: {}, params: { id: e.id }, body: { invoiceIds: e.invoiceIds } }), dP = (e) => ({ path: "/v1/admin/workspaces", headers: {}, query: {}, params: {}, body: { name: e.name } }), fP = (e) => ({ path: `/v1/admin/workspaces/${encodeURIComponent(e.id)}/public`, headers: {}, query: {}, params: { id: e.id }, body: {} }), pP = (e) => ({ path: `/v1/admin/workspaces/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), hP = (e) => ({ path: `/v1/admin/workspaces/${encodeURIComponent(e.id)}/usages`, headers: {}, query: { type: e.type, period: e.period }, params: { id: e.id }, body: {} }), mP = (e) => ({ path: `/v1/admin/workspaces/${encodeURIComponent(e.id)}/usages/by-bot`, headers: {}, query: { type: e.type, period: e.period }, params: { id: e.id }, body: {} }), yP = (e) => ({ path: "/v1/admin/workspaces/usages/quota-completion", headers: {}, query: {}, params: {}, body: {} }), gP = (e) => ({ path: `/v1/admin/workspaces/${encodeURIComponent(e.id)}/quota`, headers: {}, query: { type: e.type, period: e.period }, params: { id: e.id }, body: {} }), vP = (e) => ({ path: `/v1/admin/workspaces/${encodeURIComponent(e.id)}/quotas`, headers: {}, query: { period: e.period }, params: { id: e.id }, body: {} }), bP = (e) => ({ path: `/v1/admin/workspaces/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: { name: e.name, spendingLimit: e.spendingLimit, about: e.about, profilePicture: e.profilePicture, contactEmail: e.contactEmail, website: e.website, socialAccounts: e.socialAccounts, isPublic: e.isPublic, handle: e.handle } }), wP = (e) => ({ path: "/v1/admin/workspaces/handle-availability", headers: {}, query: {}, params: {}, body: { handle: e.handle } }), xP = (e) => ({ path: "/v1/admin/workspaces", headers: {}, query: { nextToken: e.nextToken }, params: {}, body: {} }), _P = (e) => ({ path: "/v1/admin/workspaces/public", headers: {}, query: { nextToken: e.nextToken, workspaceIds: e.workspaceIds, search: e.search }, params: {}, body: {} }), SP = (e) => ({ path: `/v1/admin/workspaces/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), kP = (e) => ({ path: `/v1/admin/workspaces/${encodeURIComponent(e.id)}/audit-records`, headers: {}, query: { nextToken: e.nextToken }, params: { id: e.id }, body: {} }), EP = (e) => ({ path: "/v1/admin/workspace-members", headers: {}, query: { nextToken: e.nextToken }, params: {}, body: {} }), CP = (e) => ({ path: "/v1/admin/workspace-members/me", headers: {}, query: {}, params: {}, body: {} }), TP = (e) => ({ path: `/v1/admin/workspace-members/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), RP = (e) => ({ path: "/v1/admin/workspace-members", headers: {}, query: {}, params: {}, body: { email: e.email, role: e.role } }), AP = (e) => ({ path: `/v1/admin/workspace-members/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: { role: e.role } }), OP = (e) => ({ path: "/v1/admin/integrations/iaks", headers: {}, query: { integrationId: e.integrationId }, params: {}, body: {} }), IP = (e) => ({ path: "/v1/admin/integrations/iaks", headers: {}, query: {}, params: {}, body: { integrationId: e.integrationId, note: e.note } }), PP = (e) => ({ path: `/v1/admin/integrations/iaks/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), $P = (e) => ({ path: "/v1/admin/integrations", headers: {}, query: {}, params: {}, body: { name: e.name, version: e.version, interfaces: e.interfaces, configuration: e.configuration, states: e.states, events: e.events, actions: e.actions, entities: e.entities, identifier: e.identifier, channels: e.channels, user: e.user, secrets: e.secrets, code: e.code, url: e.url, dev: e.dev, icon: e.icon, readme: e.readme, title: e.title, description: e.description, public: e.public } }), DP = (e) => ({ path: `/v1/admin/integrations/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: { configuration: e.configuration, channels: e.channels, identifier: e.identifier, actions: e.actions, events: e.events, states: e.states, user: e.user, entities: e.entities, interfaces: e.interfaces, secrets: e.secrets, code: e.code, icon: e.icon, readme: e.readme, title: e.title, description: e.description, url: e.url, public: e.public } }), NP = (e) => ({ path: "/v1/admin/integrations", headers: {}, query: { nextToken: e.nextToken, name: e.name, version: e.version, dev: e.dev }, params: {}, body: {} }), jP = (e) => ({ path: `/v1/admin/integrations/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), MP = (e) => ({ path: `/v1/admin/integrations/${encodeURIComponent(e.id)}/logs`, headers: {}, query: { timeStart: e.timeStart, timeEnd: e.timeEnd, nextToken: e.nextToken }, params: { id: e.id }, body: {} }), qP = (e) => ({ path: `/v1/admin/integrations/${encodeURIComponent(e.name)}/${encodeURIComponent(e.version)}`, headers: {}, query: {}, params: { name: e.name, version: e.version }, body: {} }), LP = (e) => ({ path: `/v1/admin/integrations/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), FP = (e) => ({ path: "/v1/admin/integrations/request-verification", headers: {}, query: {}, params: {}, body: { integrationId: e.integrationId } }), UP = (e) => ({ path: "/v1/admin/interfaces", headers: {}, query: {}, params: {}, body: { name: e.name, version: e.version, events: e.events, actions: e.actions, entities: e.entities } }), BP = (e) => ({ path: `/v1/admin/interfaces/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), zP = (e) => ({ path: `/v1/admin/interfaces/${encodeURIComponent(e.name)}/${encodeURIComponent(e.version)}`, headers: {}, query: {}, params: { name: e.name, version: e.version }, body: {} }), ZP = (e) => ({ path: `/v1/admin/interfaces/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: { events: e.events, actions: e.actions, entities: e.entities } }), VP = (e) => ({ path: `/v1/admin/interfaces/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), HP = (e) => ({ path: "/v1/admin/interfaces", headers: {}, query: { nextToken: e.nextToken }, params: {}, body: {} }), WP = (e) => ({ path: `/v1/admin/usages/${encodeURIComponent(e.id)}`, headers: {}, query: { type: e.type, period: e.period }, params: { id: e.id }, body: {} }), KP = (e) => ({ path: "/v1/admin/usages/multiple", headers: {}, query: { types: e.types, ids: e.ids, period: e.period }, params: {}, body: {} }), JP = (e) => ({ path: `/v1/admin/usages/${encodeURIComponent(e.id)}/history`, headers: {}, query: { type: e.type }, params: { id: e.id }, body: {} }), YP = (e) => ({ path: "/v1/admin/quotas/ai-spend", headers: {}, query: {}, params: {}, body: { monthlySpendingLimit: e.monthlySpendingLimit } }), GP = (e) => ({ path: "/v1/admin/activities", headers: {}, query: { nextToken: e.nextToken, taskId: e.taskId, botId: e.botId }, params: {}, body: {} }), XP = (e) => ({ path: "/v1/admin/introspect", headers: {}, query: {}, params: {}, body: { botId: e.botId } }), QP = (e) => ({ path: "/v1/files", headers: {}, query: {}, params: {}, body: { key: e.key, tags: e.tags, size: e.size, index: e.index, accessPolicies: e.accessPolicies, contentType: e.contentType, expiresAt: e.expiresAt } }), e$ = (e) => ({ path: `/v1/files/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), t$ = (e) => ({ path: "/v1/files", headers: {}, query: { nextToken: e.nextToken, tags: e.tags }, params: {}, body: {} }), n$ = (e) => ({ path: `/v1/files/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: {} }), r$ = (e) => ({ path: `/v1/files/${encodeURIComponent(e.id)}`, headers: {}, query: {}, params: { id: e.id }, body: { tags: e.tags, accessPolicies: e.accessPolicies, expiresAt: e.expiresAt } }), i$ = (e) => ({ path: "/v1/files/search", headers: {}, query: { tags: e.tags, query: e.query, contextDepth: e.contextDepth, limit: e.limit, includeBreadcrumb: e.includeBreadcrumb }, params: {}, body: {} }), o$ = (e) => ({ path: `/v1/files/${encodeURIComponent(e.fileId)}/passages`, headers: {}, query: { nextToken: e.nextToken, limit: e.limit }, params: { fileId: e.fileId }, body: {} }), a$ = (e) => ({ path: "/v1/tables", headers: {}, query: { tags: e.tags }, params: {}, body: {} }), s$ = (e) => ({ path: `/v1/tables/${encodeURIComponent(e.table)}`, headers: {}, query: {}, params: { table: e.table }, body: {} }), c$ = (e) => ({ path: `/v1/tables/${encodeURIComponent(e.table)}`, headers: {}, query: {}, params: { table: e.table }, body: { factor: e.factor, frozen: e.frozen, schema: e.schema, tags: e.tags, isComputeEnabled: e.isComputeEnabled } }), l$ = (e) => ({ path: "/v1/tables", headers: {}, query: {}, params: {}, body: { name: e.name, factor: e.factor, frozen: e.frozen, schema: e.schema, tags: e.tags, isComputeEnabled: e.isComputeEnabled } }), u$ = (e) => ({ path: `/v1/tables/${encodeURIComponent(e.sourceTableId)}/duplicate`, headers: {}, query: {}, params: { sourceTableId: e.sourceTableId }, body: { tableName: e.tableName, schemaOnly: e.schemaOnly, factor: e.factor } }), d$ = (e) => ({ path: `/v1/tables/${encodeURIComponent(e.table)}`, headers: {}, query: {}, params: { table: e.table }, body: { name: e.name, frozen: e.frozen, schema: e.schema, tags: e.tags, isComputeEnabled: e.isComputeEnabled } }), f$ = (e) => ({ path: `/v1/tables/${encodeURIComponent(e.table)}/column`, headers: {}, query: {}, params: { table: e.table }, body: { name: e.name, newName: e.newName } }), p$ = (e) => ({ path: `/v1/tables/${encodeURIComponent(e.table)}`, headers: {}, query: {}, params: { table: e.table }, body: {} }), h$ = (e) => ({ path: `/v1/tables/${encodeURIComponent(e.table)}/row`, headers: {}, query: { id: e.id }, params: { table: e.table }, body: {} }), m$ = (e) => ({ path: `/v1/tables/${encodeURIComponent(e.table)}/rows/find`, headers: {}, query: {}, params: { table: e.table }, body: { limit: e.limit, offset: e.offset, filter: e.filter, group: e.group, search: e.search, orderBy: e.orderBy, orderDirection: e.orderDirection } }), y$ = (e) => ({ path: `/v1/tables/${encodeURIComponent(e.table)}/rows`, headers: {}, query: {}, params: { table: e.table }, body: { rows: e.rows, waitComputed: e.waitComputed } }), g$ = (e) => ({ path: `/v1/tables/${encodeURIComponent(e.table)}/rows/delete`, headers: {}, query: {}, params: { table: e.table }, body: { ids: e.ids, filter: e.filter, deleteAllRows: e.deleteAllRows } }), v$ = (e) => ({ path: `/v1/tables/${encodeURIComponent(e.table)}/rows`, headers: {}, query: {}, params: { table: e.table }, body: { rows: e.rows, waitComputed: e.waitComputed } }), b$ = (e) => ({ path: `/v1/tables/${encodeURIComponent(e.table)}/rows/upsert`, headers: {}, query: {}, params: { table: e.table }, body: { rows: e.rows, keyColumn: e.keyColumn, waitComputed: e.waitComputed } }), w$ = class {
  constructor(e, t = {}) {
    k(this, "createConversation", async (e) => {
      let { path: t, headers: n, query: r, body: i } = YO(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getConversation", async (e) => {
      let { path: t, headers: n, query: r, body: i } = GO(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listConversations", async (e) => {
      let { path: t, headers: n, query: r, body: i } = XO(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getOrCreateConversation", async (e) => {
      let { path: t, headers: n, query: r, body: i } = QO(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "updateConversation", async (e) => {
      let { path: t, headers: n, query: r, body: i } = eI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteConversation", async (e) => {
      let { path: t, headers: n, query: r, body: i } = tI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listParticipants", async (e) => {
      let { path: t, headers: n, query: r, body: i } = nI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "addParticipant", async (e) => {
      let { path: t, headers: n, query: r, body: i } = rI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getParticipant", async (e) => {
      let { path: t, headers: n, query: r, body: i } = iI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "removeParticipant", async (e) => {
      let { path: t, headers: n, query: r, body: i } = oI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createEvent", async (e) => {
      let { path: t, headers: n, query: r, body: i } = aI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getEvent", async (e) => {
      let { path: t, headers: n, query: r, body: i } = sI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listEvents", async (e) => {
      let { path: t, headers: n, query: r, body: i } = cI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createMessage", async (e) => {
      let { path: t, headers: n, query: r, body: i } = lI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getOrCreateMessage", async (e) => {
      let { path: t, headers: n, query: r, body: i } = uI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getMessage", async (e) => {
      let { path: t, headers: n, query: r, body: i } = dI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "updateMessage", async (e) => {
      let { path: t, headers: n, query: r, body: i } = fI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listMessages", async (e) => {
      let { path: t, headers: n, query: r, body: i } = pI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteMessage", async (e) => {
      let { path: t, headers: n, query: r, body: i } = hI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createUser", async (e) => {
      let { path: t, headers: n, query: r, body: i } = mI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getUser", async (e) => {
      let { path: t, headers: n, query: r, body: i } = yI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listUsers", async (e) => {
      let { path: t, headers: n, query: r, body: i } = gI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getOrCreateUser", async (e) => {
      let { path: t, headers: n, query: r, body: i } = vI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "updateUser", async (e) => {
      let { path: t, headers: n, query: r, body: i } = bI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteUser", async (e) => {
      let { path: t, headers: n, query: r, body: i } = wI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getState", async (e) => {
      let { path: t, headers: n, query: r, body: i } = xI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "setState", async (e) => {
      let { path: t, headers: n, query: r, body: i } = _I(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getOrSetState", async (e) => {
      let { path: t, headers: n, query: r, body: i } = SI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "patchState", async (e) => {
      let { path: t, headers: n, query: r, body: i } = kI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "patch", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "callAction", async (e) => {
      let { path: t, headers: n, query: r, body: i } = EI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "configureIntegration", async (e) => {
      let { path: t, headers: n, query: r, body: i } = CI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getTask", async (e) => {
      let { path: t, headers: n, query: r, body: i } = TI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createTask", async (e) => {
      let { path: t, headers: n, query: r, body: i } = RI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "updateTask", async (e) => {
      let { path: t, headers: n, query: r, body: i } = AI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteTask", async (e) => {
      let { path: t, headers: n, query: r, body: i } = OI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listTasks", async (e) => {
      let { path: t, headers: n, query: r, body: i } = II(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "trackAnalytics", async (e) => {
      let { path: t, headers: n, query: r, body: i } = PI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "runVrl", async (e) => {
      let { path: t, headers: n, query: r, body: i } = $I(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getAccount", async (e) => {
      let { path: t, headers: n, query: r, body: i } = DI(), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "updateAccount", async (e) => {
      let { path: t, headers: n, query: r, body: i } = NI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listPersonalAccessTokens", async (e) => {
      let { path: t, headers: n, query: r, body: i } = jI(), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createPersonalAccessToken", async (e) => {
      let { path: t, headers: n, query: r, body: i } = MI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deletePersonalAccessToken", async (e) => {
      let { path: t, headers: n, query: r, body: i } = qI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "setAccountPreference", async (e) => {
      let { path: t, headers: n, query: r, body: i } = LI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getAccountPreference", async (e) => {
      let { path: t, headers: n, query: r, body: i } = FI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listPublicIntegrations", async (e) => {
      let { path: t, headers: n, query: r, body: i } = UI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getPublicIntegrationById", async (e) => {
      let { path: t, headers: n, query: r, body: i } = BI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getPublicIntegration", async (e) => {
      let { path: t, headers: n, query: r, body: i } = zI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createBot", async (e) => {
      let { path: t, headers: n, query: r, body: i } = ZI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "updateBot", async (e) => {
      let { path: t, headers: n, query: r, body: i } = VI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "transferBot", async (e) => {
      let { path: t, headers: n, query: r, body: i } = HI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listBots", async (e) => {
      let { path: t, headers: n, query: r, body: i } = WI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getBot", async (e) => {
      let { path: t, headers: n, query: r, body: i } = KI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteBot", async (e) => {
      let { path: t, headers: n, query: r, body: i } = JI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getBotLogs", async (e) => {
      let { path: t, headers: n, query: r, body: i } = YI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getBotWebchat", async (e) => {
      let { path: t, headers: n, query: r, body: i } = GI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getBotAnalytics", async (e) => {
      let { path: t, headers: n, query: r, body: i } = XI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getBotIssue", async (e) => {
      let { path: t, headers: n, query: r, body: i } = QI(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listBotIssues", async (e) => {
      let { path: t, headers: n, query: r, body: i } = eP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteBotIssue", async (e) => {
      let { path: t, headers: n, query: r, body: i } = tP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listBotIssueEvents", async (e) => {
      let { path: t, headers: n, query: r, body: i } = nP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listBotVersions", async (e) => {
      let { path: t, headers: n, query: r, body: i } = rP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getBotVersion", async (e) => {
      let { path: t, headers: n, query: r, body: i } = iP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createBotVersion", async (e) => {
      let { path: t, headers: n, query: r, body: i } = oP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deployBotVersion", async (e) => {
      let { path: t, headers: n, query: r, body: i } = aP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "setWorkspacePaymentMethod", async (e) => {
      let { path: t, headers: n, query: r, body: i } = sP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listWorkspaceInvoices", async (e) => {
      let { path: t, headers: n, query: r, body: i } = cP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getUpcomingInvoice", async (e) => {
      let { path: t, headers: n, query: r, body: i } = lP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "chargeWorkspaceUnpaidInvoices", async (e) => {
      let { path: t, headers: n, query: r, body: i } = uP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createWorkspace", async (e) => {
      let { path: t, headers: n, query: r, body: i } = dP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getPublicWorkspace", async (e) => {
      let { path: t, headers: n, query: r, body: i } = fP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getWorkspace", async (e) => {
      let { path: t, headers: n, query: r, body: i } = pP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listWorkspaceUsages", async (e) => {
      let { path: t, headers: n, query: r, body: i } = hP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "breakDownWorkspaceUsageByBot", async (e) => {
      let { path: t, headers: n, query: r, body: i } = mP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getAllWorkspaceQuotaCompletion", async (e) => {
      let { path: t, headers: n, query: r, body: i } = yP(), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getWorkspaceQuota", async (e) => {
      let { path: t, headers: n, query: r, body: i } = gP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listWorkspaceQuotas", async (e) => {
      let { path: t, headers: n, query: r, body: i } = vP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "updateWorkspace", async (e) => {
      let { path: t, headers: n, query: r, body: i } = bP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "checkHandleAvailability", async (e) => {
      let { path: t, headers: n, query: r, body: i } = wP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listWorkspaces", async (e) => {
      let { path: t, headers: n, query: r, body: i } = xP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listPublicWorkspaces", async (e) => {
      let { path: t, headers: n, query: r, body: i } = _P(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteWorkspace", async (e) => {
      let { path: t, headers: n, query: r, body: i } = SP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getAuditRecords", async (e) => {
      let { path: t, headers: n, query: r, body: i } = kP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listWorkspaceMembers", async (e) => {
      let { path: t, headers: n, query: r, body: i } = EP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getWorkspaceMember", async (e) => {
      let { path: t, headers: n, query: r, body: i } = CP(), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteWorkspaceMember", async (e) => {
      let { path: t, headers: n, query: r, body: i } = TP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createWorkspaceMember", async (e) => {
      let { path: t, headers: n, query: r, body: i } = RP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "updateWorkspaceMember", async (e) => {
      let { path: t, headers: n, query: r, body: i } = AP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listIntegrationApiKeys", async (e) => {
      let { path: t, headers: n, query: r, body: i } = OP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createIntegrationApiKey", async (e) => {
      let { path: t, headers: n, query: r, body: i } = IP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteIntegrationApiKey", async (e) => {
      let { path: t, headers: n, query: r, body: i } = PP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createIntegration", async (e) => {
      let { path: t, headers: n, query: r, body: i } = $P(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "updateIntegration", async (e) => {
      let { path: t, headers: n, query: r, body: i } = DP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listIntegrations", async (e) => {
      let { path: t, headers: n, query: r, body: i } = NP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getIntegration", async (e) => {
      let { path: t, headers: n, query: r, body: i } = jP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getIntegrationLogs", async (e) => {
      let { path: t, headers: n, query: r, body: i } = MP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getIntegrationByName", async (e) => {
      let { path: t, headers: n, query: r, body: i } = qP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteIntegration", async (e) => {
      let { path: t, headers: n, query: r, body: i } = LP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "requestIntegrationVerification", async (e) => {
      let { path: t, headers: n, query: r, body: i } = FP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createInterface", async (e) => {
      let { path: t, headers: n, query: r, body: i } = UP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getInterface", async (e) => {
      let { path: t, headers: n, query: r, body: i } = BP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getInterfaceByName", async (e) => {
      let { path: t, headers: n, query: r, body: i } = zP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "updateInterface", async (e) => {
      let { path: t, headers: n, query: r, body: i } = ZP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteInterface", async (e) => {
      let { path: t, headers: n, query: r, body: i } = VP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listInterfaces", async (e) => {
      let { path: t, headers: n, query: r, body: i } = HP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getUsage", async (e) => {
      let { path: t, headers: n, query: r, body: i } = WP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getMultipleUsages", async (e) => {
      let { path: t, headers: n, query: r, body: i } = KP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listUsageHistory", async (e) => {
      let { path: t, headers: n, query: r, body: i } = JP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "changeAISpendQuota", async (e) => {
      let { path: t, headers: n, query: r, body: i } = YP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listActivities", async (e) => {
      let { path: t, headers: n, query: r, body: i } = GP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "introspect", async (e) => {
      let { path: t, headers: n, query: r, body: i } = XP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "upsertFile", async (e) => {
      let { path: t, headers: n, query: r, body: i } = QP(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteFile", async (e) => {
      let { path: t, headers: n, query: r, body: i } = e$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listFiles", async (e) => {
      let { path: t, headers: n, query: r, body: i } = t$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getFile", async (e) => {
      let { path: t, headers: n, query: r, body: i } = n$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "updateFileMetadata", async (e) => {
      let { path: t, headers: n, query: r, body: i } = r$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "searchFiles", async (e) => {
      let { path: t, headers: n, query: r, body: i } = i$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listFilePassages", async (e) => {
      let { path: t, headers: n, query: r, body: i } = o$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "listTables", async (e) => {
      let { path: t, headers: n, query: r, body: i } = a$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getTable", async (e) => {
      let { path: t, headers: n, query: r, body: i } = s$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getOrCreateTable", async (e) => {
      let { path: t, headers: n, query: r, body: i } = c$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createTable", async (e) => {
      let { path: t, headers: n, query: r, body: i } = l$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "duplicateTable", async (e) => {
      let { path: t, headers: n, query: r, body: i } = u$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "updateTable", async (e) => {
      let { path: t, headers: n, query: r, body: i } = d$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "renameTableColumn", async (e) => {
      let { path: t, headers: n, query: r, body: i } = f$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteTable", async (e) => {
      let { path: t, headers: n, query: r, body: i } = p$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "delete", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "getTableRow", async (e) => {
      let { path: t, headers: n, query: r, body: i } = h$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "get", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "findTableRows", async (e) => {
      let { path: t, headers: n, query: r, body: i } = m$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "createTableRows", async (e) => {
      let { path: t, headers: n, query: r, body: i } = y$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "deleteTableRows", async (e) => {
      let { path: t, headers: n, query: r, body: i } = g$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "updateTableRows", async (e) => {
      let { path: t, headers: n, query: r, body: i } = v$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "put", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    k(this, "upsertTableRows", async (e) => {
      let { path: t, headers: n, query: r, body: i } = b$(e), o = (this.props.toAxiosRequest ?? Y)({ method: "post", path: t, headers: { ...n }, query: { ...r }, body: i });
      return this.axiosInstance.request(o).then((a) => a.data).catch((a) => {
        throw G(a);
      });
    });
    this.axiosInstance = e, this.props = t;
  }
};
function G(e) {
  var t;
  return ea.isAxiosError(e) && ((t = e.response) != null && t.data) ? _p(e.response.data) : _p(e);
}
var _n = class {
  constructor(e) {
    this._list = e;
  }
  async *[Symbol.asyncIterator]() {
    let e;
    do {
      let { items: t, meta: n } = await this._list({ nextToken: e });
      e = n.nextToken;
      for (let r of t)
        yield r;
    } while (e);
  }
  async collect(e = {}) {
    let t = e.limit ?? Number.POSITIVE_INFINITY, n = [], r = 0;
    for await (let i of this)
      if (n.push(i), r++, r >= t)
        break;
    return n;
  }
}, x$ = class {
  constructor(e) {
    k(this, "conversations", (e) => new _n(({ nextToken: t }) => this.client.listConversations({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.conversations }))));
    k(this, "participants", (e) => new _n(({ nextToken: t }) => this.client.listParticipants({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.participants }))));
    k(this, "events", (e) => new _n(({ nextToken: t }) => this.client.listEvents({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.events }))));
    k(this, "messages", (e) => new _n(({ nextToken: t }) => this.client.listMessages({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.messages }))));
    k(this, "users", (e) => new _n(({ nextToken: t }) => this.client.listUsers({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.users }))));
    k(this, "tasks", (e) => new _n(({ nextToken: t }) => this.client.listTasks({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.tasks }))));
    k(this, "publicIntegrations", (e) => new _n(({ nextToken: t }) => this.client.listPublicIntegrations({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.integrations }))));
    k(this, "bots", (e) => new _n(({ nextToken: t }) => this.client.listBots({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.bots }))));
    k(this, "botIssues", (e) => new _n(({ nextToken: t }) => this.client.listBotIssues({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.issues }))));
    k(this, "workspaces", (e) => new _n(({ nextToken: t }) => this.client.listWorkspaces({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.workspaces }))));
    k(this, "publicWorkspaces", (e) => new _n(({ nextToken: t }) => this.client.listPublicWorkspaces({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.workspaces }))));
    k(this, "workspaceMembers", (e) => new _n(({ nextToken: t }) => this.client.listWorkspaceMembers({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.members }))));
    k(this, "integrations", (e) => new _n(({ nextToken: t }) => this.client.listIntegrations({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.integrations }))));
    k(this, "interfaces", (e) => new _n(({ nextToken: t }) => this.client.listInterfaces({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.interfaces }))));
    k(this, "activities", (e) => new _n(({ nextToken: t }) => this.client.listActivities({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.activities }))));
    k(this, "files", (e) => new _n(({ nextToken: t }) => this.client.listFiles({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.files }))));
    k(this, "filePassages", (e) => new _n(({ nextToken: t }) => this.client.listFilePassages({ nextToken: t, ...e }).then((n) => ({ ...n, items: n.passages }))));
    this.client = e;
  }
}, u_ = 100 * 1024 * 1024, _$ = u_, S$ = u_, k$ = class extends w$ {
  constructor(t = {}) {
    let n = VO(t), { apiUrl: r, headers: i, withCredentials: o, timeout: a } = n, s = ea.create({ baseURL: r, headers: i, withCredentials: o, timeout: a, maxBodyLength: _$, maxContentLength: S$, httpAgent: wp ? new jO.default.Agent({ keepAlive: !0 }) : void 0, httpsAgent: wp ? new MO.default.Agent({ keepAlive: !0 }) : void 0 });
    super(s);
    k(this, "config");
    k(this, "uploadFile", async ({ key: t, index: n, tags: r, contentType: i, accessPolicies: o, content: a, url: s, expiresAt: c }) => {
      if (s && a)
        throw new zo("Cannot provide both content and URL, please provide only one of them");
      if (s && (a = await ea.get(s, { responseType: "arraybuffer" }).then((p) => p.data).catch((p) => {
        throw new zo(`Failed to download file from provided URL: ${p.message}`, p);
      })), !a)
        throw new zo("No content was provided for the file");
      let l, u;
      if (typeof a == "string") {
        let p = new TextEncoder().encode(a);
        l = p, u = p.byteLength;
      } else if (a instanceof Uint8Array)
        l = a, u = l.byteLength;
      else if (a instanceof ArrayBuffer)
        l = a, u = l.byteLength;
      else if (a instanceof Blob)
        l = a, u = a.size;
      else
        throw new zo("The provided content is not supported");
      let { file: d } = await this.upsertFile({ key: t, tags: r, index: n, accessPolicies: o, contentType: i, size: u, expiresAt: c });
      try {
        await ea.put(d.uploadUrl, l, { maxBodyLength: 1 / 0, headers: { "Content-Type": d.contentType } });
      } catch (p) {
        throw new zo(`Failed to upload file: ${p.message}`, p, d);
      }
      return { file: d };
    });
    t.retry && L0(s, t.retry), this.config = n;
  }
  get list() {
    return new x$(this);
  }
};
const E$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AlreadyExistsError: i_,
  BreakingChangesError: l_,
  Client: k$,
  ForbiddenError: z0,
  InternalError: U0,
  InvalidDataFormatError: Y0,
  InvalidIdentifierError: G0,
  InvalidJsonSchemaError: J0,
  InvalidPayloadError: V0,
  InvalidQueryError: n_,
  LimitExceededError: c_,
  MethodNotFoundError: W0,
  PayloadTooLargeError: Z0,
  PaymentRequiredError: a_,
  QuotaExceededError: s_,
  RateLimitedError: o_,
  ReferenceConstraintError: Q0,
  ReferenceNotFoundError: t_,
  RelationConflictError: X0,
  ResourceLockedConflictError: e_,
  ResourceNotFoundError: K0,
  RuntimeError: r_,
  UnauthorizedError: B0,
  UnknownError: pa,
  UnsupportedMediaTypeError: H0,
  UploadFileError: zo,
  axios: KA,
  axiosRetry: $0,
  errorFrom: _p,
  isApiError: F0
}, Symbol.toStringTag, { value: "Module" })), wc = /* @__PURE__ */ vh(E$);
(function(e) {
  var t = Object.create, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = Object.getOwnPropertyNames, o = Object.getPrototypeOf, a = Object.prototype.hasOwnProperty, s = (w, te) => {
    for (var ge in te)
      n(w, ge, { get: te[ge], enumerable: !0 });
  }, c = (w, te, ge, qe) => {
    if (te && typeof te == "object" || typeof te == "function")
      for (let Le of i(te))
        !a.call(w, Le) && Le !== ge && n(w, Le, { get: () => te[Le], enumerable: !(qe = r(te, Le)) || qe.enumerable });
    return w;
  }, l = (w, te, ge) => (c(w, te, "default"), ge && c(ge, te, "default")), u = (w, te, ge) => (ge = w != null ? t(o(w)) : {}, c(te || !w || !w.__esModule ? n(ge, "default", { value: w, enumerable: !0 }) : ge, w)), d = (w) => c(n({}, "__esModule", { value: !0 }), w), p = {};
  s(p, { Bot: () => UC, BotSpecificClient: () => by, Integration: () => Wt, IntegrationDefinition: () => ie, IntegrationSpecificClient: () => Lt, InterfaceDeclaration: () => se, RuntimeError: () => vy.RuntimeError, botIdHeader: () => E, botUserIdHeader: () => ee, configurationHeader: () => be, integrationIdHeader: () => de, interfaces: () => $, isApiError: () => vy.isApiError, messages: () => f, operationHeader: () => ke, parseBody: () => _e, serve: () => Ze, typeHeader: () => Se, webhookIdHeader: () => T }), e.exports = d(p);
  var f = {};
  s(f, { defaults: () => L });
  var h = {};
  s(h, { default: () => y });
  var m = vc;
  l(h, vc);
  var y = m.z, g = h.z.string().min(1), v = h.z.object({ text: g }), b = h.z.object({ markdown: g }), _ = h.z.object({ imageUrl: g }), S = h.z.object({ audioUrl: g }), x = h.z.object({ videoUrl: g }), A = h.z.object({ fileUrl: g, title: g.optional() }), I = h.z.object({ latitude: h.z.number(), longitude: h.z.number(), address: h.z.string().optional(), title: h.z.string().optional() }), P = h.z.object({ title: g, subtitle: g.optional(), imageUrl: g.optional(), actions: h.z.array(h.z.object({ action: h.z.enum(["postback", "url", "say"]), label: g, value: g })) }), R = h.z.object({ text: g, options: h.z.array(h.z.object({ label: g, value: g })) }), M = h.z.object({ items: h.z.array(P) }), V = h.z.discriminatedUnion("type", [h.z.object({ type: h.z.literal("text"), payload: v }), h.z.object({ type: h.z.literal("markdown"), payload: b }), h.z.object({ type: h.z.literal("image"), payload: _ }), h.z.object({ type: h.z.literal("audio"), payload: S }), h.z.object({ type: h.z.literal("video"), payload: x }), h.z.object({ type: h.z.literal("file"), payload: A }), h.z.object({ type: h.z.literal("location"), payload: I })]), U = h.z.object({ items: h.z.array(V) }), L = { text: { schema: v }, markdown: { schema: b }, image: { schema: _ }, audio: { schema: S }, video: { schema: x }, file: { schema: A }, location: { schema: I }, carousel: { schema: M }, card: { schema: P }, dropdown: { schema: R }, choice: { schema: R }, bloc: { schema: U } }, $ = {};
  s($, { creatable: () => Yt, deletable: () => Wn, hitl: () => er, listable: () => ct, llm: () => mn, readable: () => Ut, schemas: () => j, speechToText: () => ce, textToImage: () => OC, typingIndicator: () => IC, updatable: () => Bt });
  var j = {};
  s(j, { speechToText: () => z });
  var z = {};
  s(z, { OpenAITranscribeAudioOutputSchema: () => H });
  var H = y.object({ language: y.string().describe("Detected language of the audio"), duration: y.number().describe("Duration of the audio file, in seconds"), segments: y.array(y.object({ text: y.string().describe("Text content of the segment."), id: y.number().describe("Unique identifier of the segment"), seek: y.number().describe("Seek offset of the segment"), start: y.number().describe("Start time of the segment in seconds."), end: y.number().describe("End time of the segment in seconds."), tokens: y.array(y.number()).describe("Array of token IDs for the text content."), temperature: y.number().describe("Temperature parameter used for generating the segment."), avg_logprob: y.number().describe("Average logprob of the segment. If the value is lower than -1, consider the logprobs failed."), compression_ratio: y.number().describe("Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed."), no_speech_prob: y.number().describe("Probability of no speech in the segment. If the value is higher than 1.0 and the avg_logprob is below -1, consider this segment silent.") })) }), X = vc, E = "x-bot-id", ee = "x-bot-user-id", de = "x-integration-id", T = "x-webhook-id", be = "x-bp-configuration", ke = "x-bp-operation", Se = "x-bp-type", Pe = X.z.enum(["webhook_received", "message_created", "action_triggered", "register", "unregister", "ping", "create_user", "create_conversation"]), Be = (w) => {
    let te = w[E], ge = w[ee], qe = w[de], Le = w[T], je = w[be], Fe = Pe.parse(w[ke]);
    if (!te)
      throw new Error("Missing bot headers");
    if (!ge)
      throw new Error("Missing bot user headers");
    if (!qe)
      throw new Error("Missing integration headers");
    if (!Le)
      throw new Error("Missing webhook headers");
    if (!je)
      throw new Error("Missing configuration headers");
    if (!Fe)
      throw new Error("Missing operation headers");
    return { botId: te, botUserId: ge, integrationId: qe, webhookId: Le, operation: Fe, configuration: je ? JSON.parse(Buffer.from(je, "base64").toString("utf-8")) : {} };
  }, Ae = (w) => Array.from(new Set(w)), pe = (w) => Object.entries(w), ue = (w, te) => Object.fromEntries(pe(w).map(([ge, qe]) => [ge, te(qe, ge)])), xe = (w, te, ge) => {
    let qe = Ae([...Object.keys(w), ...Object.keys(te)]), Le = {};
    for (let je of qe) {
      let Fe = w[je], ut = te[je];
      Fe && ut ? Le[je] = ge(Fe, ut) : Fe ? Le[je] = Fe : ut && (Le[je] = ut);
    }
    return Le;
  }, fe = Symbol("schemaName"), $e = (w) => w ? ue(w, (te, ge) => ({ ...te, [fe]: ge })) : {}, nt = (w) => w[fe] !== void 0, q = (w) => w[fe], ie = class {
    constructor(w) {
      k(this, "name");
      k(this, "version");
      k(this, "title");
      k(this, "description");
      k(this, "icon");
      k(this, "readme");
      k(this, "configuration");
      k(this, "events");
      k(this, "actions");
      k(this, "channels");
      k(this, "states");
      k(this, "user");
      k(this, "secrets");
      k(this, "identifier");
      k(this, "entities");
      k(this, "interfaces", {});
      k(this, "_mergeActions", (w, te) => ({ title: te.title ?? w.title, description: te.description ?? w.description, input: { schema: w.input.schema.merge(te.input.schema) }, output: { schema: w.output.schema.merge(te.output.schema) } }));
      k(this, "_mergeEvents", (w, te) => ({ title: te.title ?? w.title, description: te.description ?? w.description, schema: w.schema.merge(te.schema) }));
      k(this, "_mergeChannels", (w, te) => {
        let ge = xe(w.messages, te.messages, this._mergeMessage);
        return { title: te.title ?? w.title, description: te.description ?? w.description, conversation: te.conversation ?? w.conversation, message: te.message ?? w.message, messages: ge };
      });
      k(this, "_mergeMessage", (w, te) => ({ schema: w.schema.merge(te.schema) }));
      this.props = w, this.name = w.name, this.version = w.version, this.icon = w.icon, this.readme = w.readme, this.title = w.title, this.identifier = w.identifier, this.description = w.description, this.configuration = w.configuration, this.events = w.events, this.actions = w.actions, this.channels = w.channels, this.states = w.states, this.user = w.user, this.secrets = w.secrets, this.entities = w.entities;
    }
    clone(w) {
      let te = new ie({ ...this, ...w });
      for (let [ge, qe] of Object.entries(this.interfaces))
        te.interfaces[ge] = qe;
      return te;
    }
    extend(w, te) {
      let ge = te($e(this.entities)), qe = pe(ge).find(([tr, Do]) => !nt(Do));
      if (qe)
        throw new Error(`Cannot extend interface "${w.name}" with entity "${qe[0]}"; the provided schema is not part of the integration's entities.`);
      let Le = ue(ge, (tr) => ({ name: q(tr), schema: tr.schema })), { resolved: je, implementStatement: Fe } = w.resolve({ entities: Le }), ut = this;
      ut.actions = xe(ut.actions ?? {}, je.actions, this._mergeActions), ut.channels = xe(ut.channels ?? {}, je.channels, this._mergeChannels), ut.events = xe(ut.events ?? {}, je.events, this._mergeEvents);
      let yn = Object.values(Le).map((tr) => tr.name), xn = `${w.name}<${yn.join(",")}>`;
      return this.interfaces[xn] = Fe, this;
    }
  }, se = class {
    constructor(w) {
      k(this, "name");
      k(this, "version");
      k(this, "entities");
      k(this, "events");
      k(this, "actions");
      k(this, "channels");
      k(this, "templateName");
      this.props = w, this.name = w.name, this.version = w.version, this.entities = w.entities ?? {}, this.events = w.events ?? {}, this.actions = w.actions ?? {}, this.channels = w.channels ?? {}, this.templateName = w.templateName;
    }
    resolve(w) {
      let { entities: te } = w, ge = { name: this.name, version: this.version, entities: ue(te, (Fe) => ({ name: Fe.name })), actions: {}, events: {} }, qe = {}, Le = {}, je = {};
      for (let [Fe, ut] of pe(this.actions)) {
        let yn = this._dereference(ut.input.schema, te), xn = this._dereference(ut.output.schema, te), tr = this._rename(te, Fe);
        qe[tr] = { input: { schema: yn }, output: { schema: xn } }, ge.actions[Fe] = { name: tr };
      }
      for (let [Fe, ut] of pe(this.events)) {
        let yn = this._dereference(ut.schema, te), xn = this._rename(te, Fe);
        Le[xn] = { schema: yn }, ge.events[Fe] = { name: xn };
      }
      for (let [Fe, ut] of pe(this.channels)) {
        let yn = {};
        for (let [xn, tr] of pe(ut.messages)) {
          let Do = this._dereference(tr.schema, te);
          yn[xn] = { schema: Do };
        }
        je[Fe] = { messages: yn };
      }
      return { resolved: { actions: qe, events: Le, channels: je }, implementStatement: ge };
    }
    _dereference(w, te) {
      let ge = {}, qe = {};
      for (let [Le, je] of pe(te))
        ge[Le] = je.schema, qe[Le] = y.ref(Le);
      return w(qe).dereference(ge);
    }
    _rename(w, te) {
      if (!this.templateName)
        return te;
      let ge = ue(w, (qe) => qe.name);
      return this.templateName(te, ge);
    }
  }, le = fp, De = console;
  function _e(w) {
    if (!w.body)
      throw new Error("Missing body");
    return JSON.parse(w.body);
  }
  async function Ze(w, te = 8072, ge = re) {
    let qe = (0, le.createServer)(async (Le, je) => {
      try {
        let Fe = await yt(Le);
        if (Fe.path === "/health") {
          je.writeHead(200).end("ok");
          return;
        }
        let ut = await w(Fe);
        je.writeHead((ut == null ? void 0 : ut.status) ?? 200, (ut == null ? void 0 : ut.headers) ?? {}).end((ut == null ? void 0 : ut.body) ?? "{}");
      } catch (Fe) {
        De.error("Error while handling request", { error: (Fe == null ? void 0 : Fe.message) ?? "Internal error occured" }), je.writeHead(500).end(JSON.stringify({ error: (Fe == null ? void 0 : Fe.message) ?? "Internal error occured" }));
      }
    });
    return qe.listen(te, () => ge(te)), qe;
  }
  async function yt(w) {
    var Le;
    let te = await W(w), ge = {};
    for (let je = 0; je < w.rawHeaders.length; je += 2) {
      let Fe = w.rawHeaders[je].toLowerCase(), ut = w.rawHeaders[je + 1];
      ge[Fe] = ut;
    }
    let qe = new URL(w.url ?? "", w.headers.host ? `http://${w.headers.host}` : "http://botpress.cloud");
    return { body: te, path: qe.pathname, query: et(qe.search, "?"), headers: ge, method: ((Le = w.method) == null ? void 0 : Le.toUpperCase()) ?? "GET" };
  }
  function et(w, te) {
    return w.indexOf(te) === 0 ? w.slice(te.length) : w;
  }
  async function W(w) {
    return new Promise((te, ge) => {
      if (w.method !== "POST" && w.method !== "PUT" && w.method !== "PATCH")
        return te(void 0);
      let qe = "";
      w.on("data", (Le) => qe += Le.toString()), w.on("error", (Le) => ge(Le)), w.on("end", () => te(qe));
    });
  }
  function re(w) {
    De.info(`Listening on port ${w}`);
  }
  var ae = wc, Te = wc, Xe = { retries: 3, retryCondition: (w) => {
    var te;
    return Te.axiosRetry.isNetworkOrIdempotentRequestError(w) || [429, 502].includes(((te = w.response) == null ? void 0 : te.status) ?? 0);
  }, retryDelay: (w) => w * 1e3 }, Lt = class {
    constructor(w) {
      k(this, "createConversation", (w) => this.client.createConversation(w));
      k(this, "getConversation", (w) => this.client.getConversation(w));
      k(this, "listConversations", (w) => this.client.listConversations(w));
      k(this, "getOrCreateConversation", (w) => this.client.getOrCreateConversation(w));
      k(this, "updateConversation", (w) => this.client.updateConversation(w));
      k(this, "deleteConversation", (w) => this.client.deleteConversation(w));
      k(this, "listParticipants", (w) => this.client.listParticipants(w));
      k(this, "addParticipant", (w) => this.client.addParticipant(w));
      k(this, "getParticipant", (w) => this.client.getParticipant(w));
      k(this, "removeParticipant", (w) => this.client.removeParticipant(w));
      k(this, "createEvent", (w) => this.client.createEvent(w));
      k(this, "getEvent", (w) => this.client.getEvent(w));
      k(this, "listEvents", (w) => this.client.listEvents(w));
      k(this, "createMessage", (w) => this.client.createMessage(w));
      k(this, "getOrCreateMessage", (w) => this.client.getOrCreateMessage(w));
      k(this, "getMessage", (w) => this.client.getMessage(w));
      k(this, "updateMessage", (w) => this.client.updateMessage(w));
      k(this, "listMessages", (w) => this.client.listMessages(w));
      k(this, "deleteMessage", (w) => this.client.deleteMessage(w));
      k(this, "createUser", (w) => this.client.createUser(w));
      k(this, "getUser", (w) => this.client.getUser(w));
      k(this, "listUsers", (w) => this.client.listUsers(w));
      k(this, "getOrCreateUser", (w) => this.client.getOrCreateUser(w));
      k(this, "updateUser", (w) => this.client.updateUser(w));
      k(this, "deleteUser", (w) => this.client.deleteUser(w));
      k(this, "getState", (w) => this.client.getState(w));
      k(this, "setState", (w) => this.client.setState(w));
      k(this, "getOrSetState", (w) => this.client.getOrSetState(w));
      k(this, "patchState", (w) => this.client.patchState(w));
      k(this, "configureIntegration", (w) => this.client.configureIntegration(w));
      k(this, "uploadFile", (w) => this.client.uploadFile(w));
      k(this, "upsertFile", (w) => this.client.upsertFile(w));
      k(this, "deleteFile", (w) => this.client.deleteFile(w));
      k(this, "listFiles", (w) => this.client.listFiles(w));
      k(this, "getFile", (w) => this.client.getFile(w));
      k(this, "updateFileMetadata", (w) => this.client.updateFileMetadata(w));
      this.client = w;
    }
  }, Pt = u(fp), Ct = (w) => {
    if (process.env.BP_LOG_FORMAT === "json")
      return JSON.stringify({ msg: Pt.default.format(...w), visible_to_bot_owner: !0 });
    {
      let [te, ...ge] = w;
      return Pt.default.format(`[For Bot Owner] ${te}`, ...ge);
    }
  }, jt = { forBot: () => ({ info: (...w) => {
    console.info(Ct(w));
  }, warn: (...w) => {
    console.warn(Ct(w));
  }, error: (...w) => {
    console.error(Ct(w));
  }, debug: (...w) => {
    console.debug(Ct(w));
  } }) }, Qt = (w) => async (te) => {
    let ge = Be(te.headers), qe = new ae.Client({ botId: ge.botId, integrationId: ge.integrationId, retry: Xe }), Le = new Lt(qe), je = { ctx: ge, req: te, client: Le, logger: jt, instance: w };
    try {
      let Fe;
      switch (ge.operation) {
        case "webhook_received":
          Fe = await K(je);
          break;
        case "register":
          Fe = await tt(je);
          break;
        case "unregister":
          Fe = await at(je);
          break;
        case "message_created":
          Fe = await ln(je);
          break;
        case "action_triggered":
          Fe = await Un(je);
          break;
        case "ping":
          Fe = await B(je);
          break;
        case "create_user":
          Fe = await It(je);
          break;
        case "create_conversation":
          Fe = await Qe(je);
          break;
        default:
          throw new Error(`Unknown operation ${ge.operation}`);
      }
      return Fe ? { ...Fe, status: Fe.status ?? 200 } : { status: 200 };
    } catch (Fe) {
      if ((0, ae.isApiError)(Fe)) {
        let yn = new ae.RuntimeError(Fe.message, Fe);
        return jt.forBot().error(yn.message), { status: yn.code, body: JSON.stringify(yn.toJSON()) };
      }
      console.error(Fe);
      let ut = new ae.RuntimeError("An unexpected error occurred in the integration. Bot owners: Check logs for more informations. Integration owners: throw a RuntimeError to return a custom error message instead.");
      return jt.forBot().error(ut.message), { status: ut.code, body: JSON.stringify(ut.toJSON()) };
    }
  }, B = async (w) => {
  }, K = async ({ client: w, ctx: te, req: ge, logger: qe, instance: Le }) => {
    let { req: je } = _e(ge);
    return Le.webhook({ client: w, ctx: te, req: je, logger: qe });
  }, tt = async ({ client: w, ctx: te, req: ge, logger: qe, instance: Le }) => {
    if (!Le.register)
      return;
    let { webhookUrl: je } = _e(ge);
    await Le.register({ client: w, ctx: te, webhookUrl: je, logger: qe });
  }, at = async ({ client: w, ctx: te, req: ge, logger: qe, instance: Le }) => {
    if (!Le.unregister)
      return;
    let { webhookUrl: je } = _e(ge);
    await Le.unregister({ ctx: te, webhookUrl: je, client: w, logger: qe });
  }, It = async ({ client: w, ctx: te, req: ge, logger: qe, instance: Le }) => {
    if (!Le.createUser)
      return;
    let { tags: je } = _e(ge);
    return await Le.createUser({ ctx: te, client: w, tags: je, logger: qe });
  }, Qe = async ({ client: w, ctx: te, req: ge, logger: qe, instance: Le }) => {
    if (!Le.createConversation)
      return;
    let { channel: je, tags: Fe } = _e(ge);
    return await Le.createConversation({ ctx: te, client: w, channel: je, tags: Fe, logger: qe });
  }, ln = async ({ ctx: w, req: te, client: ge, logger: qe, instance: Le }) => {
    let { conversation: je, user: Fe, type: ut, payload: yn, message: xn } = _e(te), tr = Le.channels[je.channel];
    if (!tr)
      throw new Error(`Channel ${je.channel} not found`);
    let Do = tr.messages[ut];
    if (!Do)
      throw new Error(`Message of type ${ut} not found in channel ${je.channel}`);
    await Do({ ctx: w, conversation: je, message: xn, user: Fe, type: ut, client: ge, payload: yn, ack: async ({ tags: BC }) => {
      await ge.updateMessage({ id: xn.id, tags: BC });
    }, logger: qe });
  }, Un = async ({ req: w, ctx: te, client: ge, logger: qe, instance: Le }) => {
    let { input: je, type: Fe } = _e(w);
    if (!Fe)
      throw new Error("Missing action type");
    let ut = Le.actions[Fe];
    if (!ut)
      throw new Error(`Action ${Fe} not found`);
    let yn = await ut({ ctx: te, input: je, client: ge, type: Fe, logger: qe });
    return { body: JSON.stringify({ output: yn }) };
  }, Wt = class {
    constructor(w) {
      k(this, "props");
      k(this, "actions");
      k(this, "channels");
      k(this, "register");
      k(this, "unregister");
      k(this, "createUser");
      k(this, "createConversation");
      k(this, "webhook");
      k(this, "handler", Qt(this));
      k(this, "start", (w) => Ze(this.handler, w));
      this.props = w, this.actions = w.actions, this.channels = w.channels, this.register = w.register, this.unregister = w.unregister, this.createUser = w.createUser, this.createConversation = w.createConversation, this.webhook = w.handler;
    }
  }, wn = (w) => ({ ...w, schema: () => w.schema.extend({ userId: y.string().optional().describe("Allows sending a message pretending to be a certain user") }) }), er = new se({ name: "hitl", version: "0.2.0", entities: {}, events: { hitlAssigned: { schema: () => y.object({ conversationId: y.string(), userId: y.string() }) }, hitlStopped: { schema: () => y.object({ conversationId: y.string() }) } }, actions: { createUser: { input: { schema: () => y.object({ name: y.string().optional(), pictureUrl: y.string().optional(), email: y.string().optional() }) }, output: { schema: () => y.object({ userId: y.string() }) } }, startHitl: { input: { schema: () => y.object({ userId: y.string(), title: y.string(), description: y.string().optional() }) }, output: { schema: () => y.object({ conversationId: y.string() }) } }, stopHitl: { input: { schema: () => y.object({ conversationId: y.string(), reason: y.enum(["timeout", "cancel"]).optional() }) }, output: { schema: () => y.object({}) } } }, channels: { hitl: { messages: { text: wn(L.text) } } } }), $t = y.object({ id: y.string(), type: y.enum(["function"]), function: y.object({ name: y.string(), arguments: y.record(y.any()).nullable().describe("Some LLMs may generate invalid JSON for a tool call, so this will be `null` when it happens.") }) }), St = y.object({ type: y.enum(["auto", "specific", "any", "none", ""]).optional(), functionName: y.string().optional().describe('Required if `type` is "specific"') }), Kt = y.object({ role: y.enum(["user", "assistant"]), type: y.enum(["text", "tool_calls", "tool_result", "multipart"]).default("text"), toolCalls: y.array($t).optional().describe('Required if `type` is "tool_calls"'), toolResultCallId: y.string().optional().describe('Required if `type` is "tool_result"'), content: y.string().or(y.array(y.object({ type: y.enum(["text", "image"]), mimeType: y.string().optional().describe("Indicates the MIME type of the content. If not provided it will be detected from the content-type header of the provided URL."), text: y.string().optional().describe('Required if part type is "text" '), url: y.string().optional().describe('Required if part type is "image"') }))).optional().nullable().describe('Required unless `type` is "tool_call". If `type` is "multipart", this field must be an array of content objects. If `type` is "tool_result" then this field should be the result of the tool call (a plain string or a JSON-encoded array or object). If `type` is "tool_call" then the `toolCalls` field should be used instead.') }), Zt = y.object({ id: y.string() }), Jt = Zt.extend({ name: y.string(), description: y.string(), tags: y.array(y.enum(["recommended", "deprecated", "general-purpose", "low-cost", "vision", "coding", "agents", "function-calling", "roleplay", "storytelling"])), input: y.object({ maxTokens: y.number().int(), costPer1MTokens: y.number().describe("Cost per 1 million tokens, in U.S. dollars") }), output: y.object({ maxTokens: y.number().int(), costPer1MTokens: y.number().describe("Cost per 1 million tokens, in U.S. dollars") }) }), Nt = (w) => y.object({ model: w.describe("Model to use for content generation").optional(), systemPrompt: y.string().optional().describe("Optional system prompt to guide the model"), messages: y.array(Kt).describe("Array of messages for the model to process"), responseFormat: y.enum(["text", "json_object"]).optional().describe('Response format expected from the model. If "json_object" is chosen, you must instruct the model to generate JSON either via the system prompt or a user message.'), maxTokens: y.number().optional().describe("Maximum number of tokens allowed in the generated response"), temperature: y.number().min(0).max(2).displayAs({ id: "slider", params: { stepSize: 0.01, horizontal: !0 } }).default(1).describe("Sampling temperature for the model. Higher values result in more random outputs."), topP: y.number().min(0).max(1).default(1).displayAs({ id: "slider", params: { stepSize: 0.01, horizontal: !0 } }).describe("Top-p sampling parameter. Limits sampling to the smallest set of tokens with a cumulative probability above the threshold."), stopSequences: y.array(y.string()).max(4).optional().describe("Sequences where the model should stop generating further tokens."), tools: y.array(y.object({ type: y.literal("function"), function: y.object({ name: y.string().describe("Function name"), description: y.string().optional(), argumentsSchema: y.object({}).passthrough().optional().describe("JSON schema of the function arguments") }) })).optional(), toolChoice: St.optional(), userId: y.string().optional(), debug: y.boolean().optional().describe("Set to `true` to output debug information to the bot logs") });
  Nt(Zt);
  var hn = y.object({ id: y.string().describe("Response ID from LLM provider"), provider: y.string().describe("LLM provider name"), model: y.string().describe("Model name"), choices: y.array(Kt.omit({ role: !0 }).extend({ role: y.literal("assistant"), index: y.number().int(), stopReason: y.enum(["stop", "max_tokens", "tool_calls", "content_filter", "other"]) })), usage: y.object({ inputTokens: y.number().int().describe("Number of input tokens used by the model"), inputCost: y.number().describe("Cost of the input tokens received by the model, in U.S. dollars"), outputTokens: y.number().int().describe("Number of output tokens used by the model"), outputCost: y.number().describe("Cost of the output tokens generated by the model, in U.S. dollars") }) }), mn = new se({ name: "llm", version: "4.0.0", entities: { modelRef: { schema: Zt } }, events: {}, actions: { generateContent: { input: { schema: ({ modelRef: w }) => Nt(w) }, output: { schema: () => hn } }, listLanguageModels: { input: { schema: () => y.object({}) }, output: { schema: ({ modelRef: w }) => y.object({ models: y.array(y.intersection(Jt, w)) }) } } } }), An = y.object({ id: y.string() }), Gi = An.extend({ name: y.string(), costPerMinute: y.number().describe("Cost per minute of speech transcription, in U.S. dollars") }), Xi = (w) => y.object({ model: w.optional().describe("Model to use for speech-to-text transcription (optional)"), fileUrl: y.string().url().describe("URL of the audio file to transcribe. The URL should return a content-type header in order to detect the audio format. Supported audio formats supported are: mp3, mp4, mpeg, mpga, m4a, wav, webm"), language: y.string().optional().describe("The language of the input audio (optional). Supplying the input language in ISO-639-1 format will improve accuracy and latency."), prompt: y.string().optional().describe("An optional text to guide the model's style or continue a previous audio segment. The prompt should match the audio language."), temperature: y.number().default(0).optional().describe("The sampling temperature (optional), between 0 and 1. Defaults to 0 (automatic). Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.") });
  Xi(An);
  var N = H.extend({ model: y.string().describe("Model name used"), cost: y.number().describe("Total cost of this transcription, in U.S. dollars") }), ce = new se({ name: "speechToText", version: "1.0.0", entities: { speechToTextModelRef: { schema: An } }, actions: { transcribeAudio: { input: { schema: ({ speechToTextModelRef: w }) => Xi(w) }, output: { schema: () => N } }, listSpeechToTextModels: { input: { schema: () => y.object({}) }, output: { schema: ({ speechToTextModelRef: w }) => y.object({ models: y.array(y.intersection(Gi, w)) }) } } } }), ye = y.object({ id: y.string() }), ze = (w) => y.intersection(w, ye), wt = (w) => w[0].toUpperCase() + w.slice(1), kt = (...w) => {
    let [te, ...ge] = w.filter((qe) => qe.length > 0).map((qe) => qe.toLowerCase());
    return te ? [te, ...ge.map(wt)].join("") : "";
  }, pt = y.string().optional(), ct = new se({ name: "listable", version: "0.0.1", entities: { item: { schema: ye } }, events: {}, actions: { list: { input: { schema: () => y.object({ nextToken: pt }) }, output: { schema: (w) => y.object({ items: y.array(ze(w.item)), meta: y.object({ nextToken: pt }) }) } } }, templateName: (w, te) => kt(te.item, w) }), Yt = new se({ name: "creatable", version: "0.0.1", entities: { item: { schema: ye } }, events: { created: { schema: (w) => y.object({ item: ze(w.item) }) } }, actions: { create: { input: { schema: (w) => y.object({ item: w.item }) }, output: { schema: (w) => y.object({ item: ze(w.item) }) } } }, templateName: (w, te) => kt(te.item, w) }), Ut = new se({ name: "readable", version: "0.0.1", entities: { item: { schema: ye } }, events: {}, actions: { read: { input: { schema: () => ye }, output: { schema: (w) => y.object({ item: ze(w.item) }) } } }, templateName: (w, te) => kt(te.item, w) }), Bt = new se({ name: "updatable", version: "0.0.1", entities: { item: { schema: ye } }, events: { updated: { schema: (w) => y.object({ item: ze(w.item) }) } }, actions: { update: { input: { schema: (w) => ye.extend({ item: w.item }) }, output: { schema: (w) => y.object({ item: ze(w.item) }) } } }, templateName: (w, te) => kt(te.item, w) }), Wn = new se({ name: "deletable", version: "0.0.1", entities: { item: { schema: ye } }, events: { deleted: { schema: () => ye } }, actions: { delete: { input: { schema: () => ye }, output: { schema: () => y.object({}) } } }, templateName: (w, te) => kt(te.item, w) }), Nr = y.object({ id: y.string() }), gc = Nr.extend({ name: y.string(), costPerImage: y.number().describe("Cost per image generation, in U.S. dollars"), sizes: y.array(y.string()).describe("Available image sizes"), defaultSize: y.string().describe("Default image size generated by model") }), dr = y.object({}).describe("Model-specific parameters for image generation"), gy = (w, te) => y.object({ model: w.optional().describe("Model to use for image generation"), prompt: y.string(), size: y.string().optional(), expiration: y.number().int().min(30).max(90).optional().describe("Expiration of the generated image in days, after which the image will be automatically deleted to free up storage space in your account. The default is to keep the image indefinitely (no expiration). The minimum is 30 days and the maximum is 90 days."), params: te.optional() });
  gy(Nr, dr);
  var AC = y.object({ model: y.string().describe("Model name used"), imageUrl: y.string().describe("Temporary URL of generated image"), cost: y.number().describe("Cost of the image generation, in U.S. dollars") }), OC = new se({ name: "textToImage", version: "1.1.0", entities: { imageModelRef: { schema: Nr }, imageGenerationParams: { schema: dr } }, actions: { generateImage: { input: { schema: ({ imageModelRef: w, imageGenerationParams: te }) => gy(w, te) }, output: { schema: () => AC } }, listImageModels: { input: { schema: () => y.object({}) }, output: { schema: ({ imageModelRef: w }) => y.object({ models: y.array(y.intersection(gc, w)) }) } } } }), IC = new se({ name: "typingIndicator", version: "0.0.1", entities: {}, events: {}, actions: { startTypingIndicator: { input: { schema: () => y.object({ conversationId: y.string(), messageId: y.string().describe("The message ID to which the typing indicator should be attached"), timeout: y.number().optional().describe("The timeout in milliseconds after which the typing indicator should stop") }) }, output: { schema: () => y.object({}) } }, stopTypingIndicator: { input: { schema: () => y.object({ conversationId: y.string(), messageId: y.string().describe("The message ID from which the typing indicator should be removed") }) }, output: { schema: () => y.object({}) } } } });
  l(p, h, e.exports);
  var vy = wc, PC = u(wc), by = class {
    constructor(w) {
      k(this, "getConversation", (w) => this.client.getConversation(w));
      k(this, "listConversations", (w) => this.client.listConversations(w));
      k(this, "updateConversation", (w) => this.client.updateConversation(w));
      k(this, "deleteConversation", (w) => this.client.deleteConversation(w));
      k(this, "listParticipants", (w) => this.client.listParticipants(w));
      k(this, "addParticipant", (w) => this.client.addParticipant(w));
      k(this, "getParticipant", (w) => this.client.getParticipant(w));
      k(this, "removeParticipant", (w) => this.client.removeParticipant(w));
      k(this, "getEvent", (w) => this.client.getEvent(w));
      k(this, "listEvents", (w) => this.client.listEvents(w));
      k(this, "createMessage", (w) => this.client.createMessage(w));
      k(this, "getOrCreateMessage", (w) => this.client.getOrCreateMessage(w));
      k(this, "getMessage", (w) => this.client.getMessage(w));
      k(this, "updateMessage", (w) => this.client.updateMessage(w));
      k(this, "listMessages", (w) => this.client.listMessages(w));
      k(this, "deleteMessage", (w) => this.client.deleteMessage(w));
      k(this, "getUser", (w) => this.client.getUser(w));
      k(this, "listUsers", (w) => this.client.listUsers(w));
      k(this, "updateUser", (w) => this.client.updateUser(w));
      k(this, "deleteUser", (w) => this.client.deleteUser(w));
      k(this, "getState", (w) => this.client.getState(w).then((te) => ({ state: { ...te.state, payload: te.state.payload } })));
      k(this, "setState", (w) => this.client.setState(w).then((te) => ({ state: { ...te.state, payload: te.state.payload } })));
      k(this, "getOrSetState", (w) => this.client.getOrSetState(w).then((te) => ({ state: { ...te.state, payload: te.state.payload } })));
      k(this, "patchState", (w) => this.client.patchState(w).then((te) => ({ state: { ...te.state, payload: te.state.payload } })));
      k(this, "callAction", (w) => this.client.callAction(w));
      k(this, "uploadFile", (w) => this.client.uploadFile(w));
      k(this, "upsertFile", (w) => this.client.upsertFile(w));
      k(this, "deleteFile", (w) => this.client.deleteFile(w));
      k(this, "listFiles", (w) => this.client.listFiles(w));
      k(this, "getFile", (w) => this.client.getFile(w));
      k(this, "updateFileMetadata", (w) => this.client.updateFileMetadata(w));
      k(this, "searchFiles", (w) => this.client.searchFiles(w));
      k(this, "createConversation", (w) => this.client.createConversation(w));
      k(this, "getOrCreateConversation", (w) => this.client.getOrCreateConversation(w));
      k(this, "createUser", (w) => this.client.createUser(w));
      k(this, "getOrCreateUser", (w) => this.client.getOrCreateUser(w));
      this.client = w;
    }
  }, $C = vc, DC = $C.z.enum(["event_received", "register", "unregister", "ping", "action_triggered"]), NC = (w) => {
    let te = w[E], ge = w[be], qe = w[Se], Le = DC.parse(w[ke]);
    if (!te)
      throw new Error("Missing bot headers");
    if (!qe)
      throw new Error("Missing type headers");
    if (!ge)
      throw new Error("Missing configuration headers");
    if (!Le)
      throw new Error("Missing operation headers");
    return { botId: te, operation: Le, type: qe, configuration: ge ? JSON.parse(Buffer.from(ge, "base64").toString("utf-8")) : {} };
  }, jC = (w) => async (te) => {
    let ge = NC(te.headers);
    ge.operation !== "ping" && De.info(`Received ${ge.operation} operation for bot ${ge.botId} of type ${ge.type}`);
    let qe = new PC.Client({ botId: ge.botId, retry: Xe }), Le = new by(qe), je = { req: te, ctx: ge, client: Le, instance: w };
    switch (ge.operation) {
      case "action_triggered":
        throw new Error(`Operation ${ge.operation} not supported yet`);
      case "event_received":
        await FC(je);
        break;
      case "register":
        await qC();
        break;
      case "unregister":
        await LC();
        break;
      case "ping":
        await MC();
        break;
      default:
        throw new Error(`Unknown operation ${ge.operation}`);
    }
    return { status: 200 };
  }, MC = async (w) => {
  }, qC = async (w) => {
  }, LC = async (w) => {
  }, FC = async ({ ctx: w, req: te, client: ge, instance: qe }) => {
    De.debug(`Received event ${w.type}`);
    let Le = _e(te), je = Le.event;
    switch (w.type) {
      case "message_created":
        let Fe = { user: je.payload.user, conversation: je.payload.conversation, message: je.payload.message, states: je.payload.states, event: je };
        await Promise.all(qe.messageHandlers.map((xn) => xn({ client: ge, ctx: w, ...Fe })));
        break;
      case "state_expired":
        let ut = { state: je.payload.state };
        await Promise.all(qe.stateExpiredHandlers.map((xn) => xn({ client: ge, ctx: w, ...ut })));
        break;
      default:
        let yn = { event: Le.event };
        await Promise.all(qe.eventHandlers.map((xn) => xn({ client: ge, ctx: w, ...yn })));
    }
  }, UC = class {
    constructor(w) {
      k(this, "_state", { messageHandlers: [], eventHandlers: [], stateExpiredHandlers: [] });
      k(this, "props");
      k(this, "message", (w) => {
        this._state.messageHandlers.push(w);
      });
      k(this, "event", (w) => {
        this._state.eventHandlers.push(w);
      });
      k(this, "stateExpired", (w) => {
        this._state.stateExpiredHandlers.push(w);
      });
      k(this, "handler", jC(this._state));
      k(this, "start", (w) => Ze(this.handler, w));
      this.props = w;
    }
  };
})(Nb);
var ne = Nb.exports;
const { defaults: Jr } = ne.messages, $r = { className: ne.z.string().describe("CSS className to apply to the message").optional() }, d_ = Jr.audio.schema.extend({ ...$r, type: ne.z.literal("audio") }), nm = Jr.card.schema.extend({
  type: ne.z.literal("card"),
  subtitle: ne.z.string().optional(),
  imageUrl: ne.z.string().optional(),
  ...$r
}), C$ = nm.omit({ type: !0 }), f_ = ne.z.object({
  items: ne.z.array(C$),
  ...$r,
  type: ne.z.literal("carousel")
}), p_ = Jr.choice.schema.extend({
  text: ne.z.string(),
  ...$r,
  type: ne.z.literal("choice"),
  disableFreeText: ne.z.boolean().optional()
}), h_ = Jr.dropdown.schema.extend({
  text: ne.z.string(),
  ...$r,
  type: ne.z.literal("dropdown")
}), m_ = Jr.file.schema.extend({ ...$r, type: ne.z.literal("file") }), y_ = Jr.image.schema.extend({ ...$r, type: ne.z.literal("image") }), g_ = Jr.location.schema.extend({ ...$r, type: ne.z.literal("location") }), v_ = Jr.markdown.schema.extend({ ...$r, type: ne.z.literal("markdown") }), b_ = Jr.text.schema.extend({ ...$r, type: ne.z.literal("text") }), w_ = Jr.video.schema.extend({ ...$r, type: ne.z.literal("video") }), x_ = ne.z.union([
  d_,
  nm,
  f_,
  p_,
  h_,
  m_,
  y_,
  g_,
  v_,
  b_,
  w_
]), __ = ne.z.object({
  type: ne.z.literal("webchat_visibility"),
  data: ne.z.object({
    visibility: ne.z.union([ne.z.literal("show"), ne.z.literal("hide"), ne.z.literal("toggle")])
  })
}), S_ = ne.z.object({
  type: ne.z.literal("webchat_config"),
  data: ne.z.object({
    config: ne.z.record(ne.z.any())
  })
}), k_ = ne.z.object({
  type: ne.z.literal("custom"),
  data: ne.z.object({
    event: ne.z.record(ne.z.any())
  })
}), E_ = ne.z.union([__, S_, k_]), T$ = E_, R$ = ne.z.object({
  type: ne.z.literal("message_created"),
  data: x_
}), C_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audioSchema: d_,
  cardSchema: nm,
  carouselSchema: f_,
  choiceSchema: p_,
  customSchema: k_,
  dropdownSchema: h_,
  fileSchema: m_,
  imageSchema: y_,
  locationSchema: g_,
  markdownSchema: v_,
  messageCreatedSchema: R$,
  messageSchema: x_,
  textSchema: b_,
  triggerSchema: E_,
  triggerSignalSchema: T$,
  videoSchema: w_,
  webchatConfigSchema: S_,
  webchatVisibilitySchema: __
}, Symbol.toStringTag, { value: "Module" })), Yr = ne.z.object({ className: ne.z.string().optional(), avatarUrl: ne.z.string().url().optional() }), T_ = Yr.extend({
  type: ne.z.literal("audio"),
  audio: ne.z.string(),
  title: ne.z.string().optional()
}), A$ = ne.z.union([
  ne.z.object({
    title: ne.z.string(),
    action: ne.z.literal("Say something"),
    text: ne.z.string()
  }),
  ne.z.object({
    title: ne.z.string(),
    action: ne.z.literal("Open URL"),
    url: ne.z.string()
  }),
  ne.z.object({
    title: ne.z.string(),
    action: ne.z.literal("Postback"),
    payload: ne.z.string()
  })
]), rm = Yr.extend({
  type: ne.z.literal("card"),
  title: ne.z.string(),
  subtitle: ne.z.string().optional(),
  image: ne.z.string().optional(),
  actions: ne.z.array(A$)
  // not sure if this is optional - fleur
}), R_ = Yr.extend({
  type: ne.z.literal("carousel"),
  items: ne.z.array(rm)
}), A_ = Yr.extend({
  type: ne.z.literal("dropdown"),
  message: ne.z.string().optional(),
  options: ne.z.array(ne.z.object({ label: ne.z.string(), value: ne.z.string() })),
  allowCreation: ne.z.boolean().optional(),
  placeholderText: ne.z.string().optional(),
  allowMultiple: ne.z.boolean().optional(),
  buttonText: ne.z.string().optional(),
  width: ne.z.number().optional(),
  displayInKeyboard: ne.z.boolean().optional(),
  markdown: ne.z.boolean().optional(),
  text: ne.z.string().optional()
}), O_ = Yr.extend({
  type: ne.z.literal("file"),
  file: ne.z.string(),
  title: ne.z.string().optional()
}), I_ = Yr.extend({
  type: ne.z.literal("image"),
  image: ne.z.string()
}), P_ = Yr.extend({
  type: ne.z.literal("location"),
  latitude: ne.z.number(),
  longitude: ne.z.number(),
  address: ne.z.string().optional(),
  title: ne.z.string().optional()
}), $_ = Yr.extend({
  type: ne.z.literal("single-choice"),
  text: ne.z.string(),
  disableFreeText: ne.z.boolean().optional(),
  choices: ne.z.array(ne.z.object({ title: ne.z.string(), value: ne.z.string() }))
}), D_ = Yr.extend({
  type: ne.z.literal("text"),
  text: ne.z.string(),
  markdown: ne.z.boolean().optional()
}), N_ = Yr.extend({
  type: ne.z.literal("video"),
  video: ne.z.string(),
  title: ne.z.string().optional()
}), j_ = ne.z.object({
  type: ne.z.literal("quick_reply"),
  text: ne.z.string(),
  payload: ne.z.string().optional()
}), au = ne.z.union([
  T_,
  rm,
  R_,
  A_,
  O_,
  I_,
  P_,
  $_,
  D_,
  N_,
  j_
]), M_ = ne.z.object({
  type: ne.z.literal("webchat-visibility"),
  visibility: ne.z.union([ne.z.literal("show"), ne.z.literal("hide"), ne.z.literal("toggle")])
}), q_ = ne.z.object({
  type: ne.z.literal("webchat-config"),
  config: ne.z.record(ne.z.any())
}), L_ = ne.z.object({
  type: ne.z.literal("custom-event"),
  event: ne.z.record(ne.z.any())
}), F_ = ne.z.union([M_, q_, L_]), O$ = ne.z.object({
  type: ne.z.literal("trigger"),
  trigger: F_
}), I$ = au, U_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audioSchema: T_,
  cardSchema: rm,
  carouselSchame: R_,
  customEventSchema: L_,
  dropdownSchema: A_,
  fileSchema: O_,
  imageSchema: I_,
  locationSchema: P_,
  messageSchema: au,
  messageSignalSchema: I$,
  quickReplySchema: j_,
  singleChoiceSchema: $_,
  textSchema: D_,
  triggerSchema: F_,
  triggerSignalSchema: O$,
  videoSchema: N_,
  webchatConfigSchema: q_,
  webchatVisibilitySchema: M_
}, Symbol.toStringTag, { value: "Module" })), B_ = (e) => ({
  type: "card",
  title: e.title,
  subtitle: e.subtitle,
  image: e.imageUrl,
  actions: e.actions.map(P$)
}), P$ = (e) => {
  switch (e.action) {
    case "postback":
      return { title: e.label, action: "Postback", payload: e.value };
    case "url":
      return { title: e.label, action: "Open URL", url: e.value };
    case "say":
      return { title: e.label, action: "Say something", text: e.value };
    default:
      throw new Error(`Unknown action type ${e.action}`);
  }
}, z_ = (e) => ({
  ...e,
  type: "audio",
  audio: e.audioUrl
}), Z_ = (e) => B_(e), V_ = (e) => ({
  ...e,
  type: "carousel",
  items: e.items.map(B_)
}), H_ = (e) => ({
  ...e,
  type: "single-choice",
  text: e.text,
  choices: e.options.map((t) => ({ title: t.label, value: t.value })),
  disableFreeText: e.disableFreeText
}), W_ = (e) => ({
  ...e,
  type: "dropdown",
  message: e.text,
  options: e.options.map((t) => ({ label: t.label, value: t.value }))
}), K_ = (e) => ({
  ...e,
  type: "file",
  file: e.fileUrl,
  title: e.title
}), J_ = (e) => ({
  ...e,
  type: "image",
  image: e.imageUrl
}), Y_ = (e) => ({
  ...e,
  type: "location",
  latitude: e.latitude,
  longitude: e.longitude
}), G_ = (e) => ({
  ...e,
  type: "text",
  text: e.markdown,
  markdown: !0
}), X_ = (e) => ({
  ...e,
  type: "text",
  text: e.text,
  markdown: !0
}), Q_ = (e) => ({
  ...e,
  type: "video",
  video: e.videoUrl
}), $$ = (e) => {
  switch (e.type) {
    case "audio":
      return z_(e);
    case "card":
      return Z_(e);
    case "carousel":
      return V_(e);
    case "choice":
      return H_(e);
    case "dropdown":
      return W_(e);
    case "file":
      return K_(e);
    case "image":
      return J_(e);
    case "location":
      return Y_(e);
    case "markdown":
      return G_(e);
    case "text":
      return X_(e);
    case "video":
      return Q_(e);
    default:
      throw new Error("Unsuported message type");
  }
}, e1 = (e) => ({
  type: "webchat-visibility",
  visibility: e.data.visibility
}), t1 = (e) => ({
  type: "webchat-config",
  config: e.data.config
}), n1 = (e) => ({
  type: "custom-event",
  event: e.data.event
}), D$ = (e) => {
  switch (e.type) {
    case "webchat_visibility":
      return e1(e);
    case "webchat_config":
      return t1(e);
    case "custom":
      return n1(e);
    default:
      throw new Error("unknown trigger type");
  }
}, r1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audioAdapter: z_,
  cardAdapter: Z_,
  carouselAdapter: V_,
  choiceAdapter: H_,
  customAdapter: n1,
  dropdownAdapter: W_,
  fileAdapter: K_,
  imageAdapter: J_,
  locationAdapter: Y_,
  markdownAdapter: G_,
  messageAdapter: $$,
  textAdapter: X_,
  triggerAdapter: D$,
  videoAdapter: Q_,
  webchatConfigAdapter: t1,
  webchatVisibilityAdapter: e1
}, Symbol.toStringTag, { value: "Module" })), i1 = (e) => ({
  type: "card",
  title: e.title,
  subtitle: e.subtitle,
  imageUrl: e.image,
  actions: e.actions.map(N$)
}), N$ = (e) => {
  switch (e.action) {
    case "Postback":
      return { label: e.title, action: "postback", value: e.payload };
    case "Open URL":
      return { label: e.title, action: "url", value: e.url };
    case "Say something":
      return { label: e.title, action: "say", value: e.text };
    default:
      throw new Error("Unknown action type");
  }
}, j$ = (e) => ({
  ...e,
  type: "audio",
  audioUrl: e.audio
}), M$ = (e) => i1(e), q$ = (e) => ({
  ...e,
  type: "carousel",
  items: e.items.map(i1)
}), L$ = (e) => ({
  ...e,
  type: "dropdown",
  text: e.message ?? "",
  options: e.options.map((t) => ({ label: t.label, value: t.value }))
}), F$ = (e) => ({
  ...e,
  type: "file",
  fileUrl: e.file,
  title: e.title
}), U$ = (e) => ({
  ...e,
  type: "image",
  imageUrl: e.image
}), B$ = (e) => ({
  ...e,
  type: "location",
  latitude: e.latitude,
  longitude: e.longitude
}), z$ = (e) => ({
  ...e,
  type: "choice",
  text: e.text,
  options: e.choices.map((t) => ({ label: t.title, value: t.value })),
  disableFreeText: e.disableFreeText
}), Z$ = (e) => ({
  ...e,
  type: "text",
  text: e.text
}), V$ = (e) => ({
  ...e,
  type: "video",
  videoUrl: e.video
}), H$ = (e) => ({
  ...e,
  type: "text",
  text: e.text ?? e.payload
}), W$ = (e) => {
  switch (e.type) {
    case "audio":
      return j$(e);
    case "card":
      return M$(e);
    case "carousel":
      return q$(e);
    case "dropdown":
      return L$(e);
    case "file":
      return F$(e);
    case "image":
      return U$(e);
    case "location":
      return B$(e);
    case "single-choice":
      return z$(e);
    case "text":
      return Z$(e);
    case "video":
      return V$(e);
    case "quick_reply":
      return H$(e);
    default:
      throw new Error("Unsuported message type");
  }
}, o1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  messageAdapter: W$
}, Symbol.toStringTag, { value: "Module" })), K$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  messaging: U_,
  messagingToWebChat: o1,
  webchat: C_,
  webchatToMessaging: r1
}, Symbol.toStringTag, { value: "Module" })), J$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
let xc;
const Y$ = new Uint8Array(16);
function G$() {
  if (!xc && (xc = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !xc))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return xc(Y$);
}
const kn = [];
for (let e = 0; e < 256; ++e)
  kn.push((e + 256).toString(16).slice(1));
function X$(e, t = 0) {
  return kn[e[t + 0]] + kn[e[t + 1]] + kn[e[t + 2]] + kn[e[t + 3]] + "-" + kn[e[t + 4]] + kn[e[t + 5]] + "-" + kn[e[t + 6]] + kn[e[t + 7]] + "-" + kn[e[t + 8]] + kn[e[t + 9]] + "-" + kn[e[t + 10]] + kn[e[t + 11]] + kn[e[t + 12]] + kn[e[t + 13]] + kn[e[t + 14]] + kn[e[t + 15]];
}
const Q$ = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Vy = {
  randomUUID: Q$
};
function su(e, t, n) {
  if (Vy.randomUUID && !t && !e)
    return Vy.randomUUID();
  e = e || {};
  const r = e.random || (e.rng || G$)();
  if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, t) {
    n = n || 0;
    for (let i = 0; i < 16; ++i)
      t[n + i] = r[i];
    return t;
  }
  return X$(r);
}
const hd = (e) => ({
  block: e,
  type: "bubble"
}), eD = (e) => e.action === "Say something" ? {
  type: "button",
  variant: "action",
  text: e.title,
  buttonValue: e.text,
  reusable: !0
} : e.action === "Open URL" ? {
  type: "button",
  variant: "link",
  text: e.title,
  buttonValue: e.url,
  reusable: !0
} : {
  type: "button",
  variant: "action",
  text: e.title,
  buttonValue: e.payload,
  reusable: !0
}, a1 = ({
  title: e,
  image: t,
  actions: n,
  subtitle: r
}) => {
  const i = [];
  return t && i.push({
    type: "image",
    url: t
  }), e && i.push({
    type: "text",
    text: `## ${e}`
  }), r && i.push({
    type: "text",
    text: r
  }), n.length > 0 && i.push({
    type: "row",
    blocks: n.map(eD)
  }), {
    type: "column",
    horizontalAlignment: "center",
    blocks: [...i]
  };
}, tD = ({ choices: e, text: t }) => {
  const n = su(), r = hd({
    type: "text",
    text: t
  });
  return e.length === 0 ? r : {
    type: "column",
    horizontalAlignment: "left",
    blocks: [
      r,
      {
        type: "row",
        blocks: e.map(({ title: i, value: o }) => ({
          type: "button",
          variant: "action",
          text: i,
          buttonValue: o,
          groupId: n
        }))
      }
    ]
  };
}, nD = ({ options: e, text: t }) => {
  const n = [
    {
      type: "dropdown",
      label: t ?? "Select an option",
      options: e
    }
  ];
  return t && n.unshift({
    type: "text",
    text: t
  }), {
    type: "column",
    blocks: n
  };
}, im = ({ type: e, audio: t }) => ({
  payload: { type: e, url: t }
}), om = (e) => ({
  payload: hd(a1(e))
}), am = ({ items: e }) => ({
  payload: {
    type: "carousel",
    blocks: e.map(a1)
  }
}), sm = (e) => ({
  disableInput: e.disableFreeText,
  payload: tD(e)
}), cm = (e) => ({
  disableInput: !0,
  payload: hd(nD(e))
}), lm = ({ file: e, ...t }) => ({
  payload: {
    url: e,
    ...t
  }
}), um = ({ type: e, image: t }) => ({
  payload: { type: e, url: t }
}), dm = ({ type: e, latitude: t, longitude: n, title: r, address: i }) => ({
  payload: {
    type: e,
    latitude: t,
    longitude: n,
    title: r ?? i ?? "View on map"
  }
}), s1 = ({ text: e, payload: t }) => ({
  payload: {
    type: "text",
    text: e ?? t
  }
}), md = ({ type: e, text: t }) => ({
  payload: hd({ type: e, text: t })
}), fm = ({ type: e, video: t }) => ({
  payload: { type: e, url: t }
}), Sp = (e) => {
  switch (e.type) {
    case "audio":
      return im(e);
    case "card":
      return om(e);
    case "carousel":
      return am(e);
    case "single-choice":
      return sm(e);
    case "dropdown":
      return cm(e);
    case "file":
      return lm(e);
    case "image":
      return um(e);
    case "location":
      return dm(e);
    case "quick_reply":
      return s1(e);
    case "text":
      return md(e);
    case "video":
      return fm(e);
    default:
      throw new Error("Unsuported message type");
  }
}, rD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audioAdapter: im,
  cardAdapter: om,
  carouselAdapter: am,
  choiceAdapter: sm,
  dropdownAdapter: cm,
  fileAdapter: lm,
  imageAdapter: um,
  locationAdapter: dm,
  messageAdapter: Sp,
  quickReplyAdapter: s1,
  textAdapter: md,
  videoAdapter: fm
}, Symbol.toStringTag, { value: "Module" })), { webchatToMessaging: Dr } = K$, c1 = (e) => {
  const t = Dr.audioAdapter(e);
  return im(t);
}, l1 = (e) => {
  const t = Dr.cardAdapter(e);
  return om(t);
}, u1 = (e) => {
  const t = Dr.carouselAdapter(e);
  return am(t);
}, d1 = (e) => {
  const t = Dr.choiceAdapter(e);
  return sm(t);
}, f1 = (e) => {
  const t = Dr.dropdownAdapter(e);
  return cm(t);
}, p1 = (e) => {
  const t = Dr.fileAdapter(e);
  return lm(t);
}, h1 = (e) => {
  const t = Dr.imageAdapter(e);
  return um(t);
}, m1 = (e) => {
  const t = Dr.locationAdapter(e);
  return dm(t);
}, y1 = (e) => {
  const t = Dr.markdownAdapter(e);
  return md(t);
}, g1 = (e) => {
  const t = Dr.textAdapter(e);
  return md(t);
}, v1 = (e) => {
  const t = Dr.videoAdapter(e);
  return fm(t);
}, b1 = (e) => {
  switch (e.type) {
    case "audio":
      return c1(e);
    case "card":
      return l1(e);
    case "carousel":
      return u1(e);
    case "choice":
      return d1(e);
    case "dropdown":
      return f1(e);
    case "file":
      return p1(e);
    case "image":
      return h1(e);
    case "location":
      return m1(e);
    case "markdown":
      return y1(e);
    case "text":
      return g1(e);
    case "video":
      return v1(e);
    default:
      throw new Error("Unsuported message type");
  }
}, iD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audioAdapter: c1,
  cardAdapter: l1,
  carouselAdapter: u1,
  choiceAdapter: d1,
  dropdownAdapter: f1,
  fileAdapter: p1,
  imageAdapter: h1,
  locationAdapter: m1,
  markdownAdapter: y1,
  messageAdapter: b1,
  textAdapter: g1,
  videoAdapter: v1
}, Symbol.toStringTag, { value: "Module" })), rJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  messaging: U_,
  messagingToTarget: rD,
  messagingToWebChat: o1,
  target: J$,
  webchat: C_,
  webchatToMessaging: r1,
  webchatToTarget: iD
}, Symbol.toStringTag, { value: "Module" }));
var kp = { exports: {} }, za = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Hy;
function oD() {
  if (Hy)
    return za;
  Hy = 1;
  var e = Xt, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, c, l) {
    var u, d = {}, p = null, f = null;
    l !== void 0 && (p = "" + l), c.key !== void 0 && (p = "" + c.key), c.ref !== void 0 && (f = c.ref);
    for (u in c)
      r.call(c, u) && !o.hasOwnProperty(u) && (d[u] = c[u]);
    if (s && s.defaultProps)
      for (u in c = s.defaultProps, c)
        d[u] === void 0 && (d[u] = c[u]);
    return { $$typeof: t, type: s, key: p, ref: f, props: d, _owner: i.current };
  }
  return za.Fragment = n, za.jsx = a, za.jsxs = a, za;
}
var Za = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Wy;
function aD() {
  return Wy || (Wy = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Xt, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), h = Symbol.iterator, m = "@@iterator";
    function y(N) {
      if (N === null || typeof N != "object")
        return null;
      var ce = h && N[h] || N[m];
      return typeof ce == "function" ? ce : null;
    }
    var g = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function v(N) {
      {
        for (var ce = arguments.length, ye = new Array(ce > 1 ? ce - 1 : 0), ze = 1; ze < ce; ze++)
          ye[ze - 1] = arguments[ze];
        b("error", N, ye);
      }
    }
    function b(N, ce, ye) {
      {
        var ze = g.ReactDebugCurrentFrame, wt = ze.getStackAddendum();
        wt !== "" && (ce += "%s", ye = ye.concat([wt]));
        var kt = ye.map(function(pt) {
          return String(pt);
        });
        kt.unshift("Warning: " + ce), Function.prototype.apply.call(console[N], console, kt);
      }
    }
    var _ = !1, S = !1, x = !1, A = !1, I = !1, P;
    P = Symbol.for("react.module.reference");
    function R(N) {
      return !!(typeof N == "string" || typeof N == "function" || N === r || N === o || I || N === i || N === l || N === u || A || N === f || _ || S || x || typeof N == "object" && N !== null && (N.$$typeof === p || N.$$typeof === d || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      N.$$typeof === P || N.getModuleId !== void 0));
    }
    function M(N, ce, ye) {
      var ze = N.displayName;
      if (ze)
        return ze;
      var wt = ce.displayName || ce.name || "";
      return wt !== "" ? ye + "(" + wt + ")" : ye;
    }
    function V(N) {
      return N.displayName || "Context";
    }
    function U(N) {
      if (N == null)
        return null;
      if (typeof N.tag == "number" && v("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof N == "function")
        return N.displayName || N.name || null;
      if (typeof N == "string")
        return N;
      switch (N) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case l:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof N == "object")
        switch (N.$$typeof) {
          case s:
            var ce = N;
            return V(ce) + ".Consumer";
          case a:
            var ye = N;
            return V(ye._context) + ".Provider";
          case c:
            return M(N, N.render, "ForwardRef");
          case d:
            var ze = N.displayName || null;
            return ze !== null ? ze : U(N.type) || "Memo";
          case p: {
            var wt = N, kt = wt._payload, pt = wt._init;
            try {
              return U(pt(kt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var L = Object.assign, $ = 0, j, z, H, X, E, ee, de;
    function T() {
    }
    T.__reactDisabledLog = !0;
    function be() {
      {
        if ($ === 0) {
          j = console.log, z = console.info, H = console.warn, X = console.error, E = console.group, ee = console.groupCollapsed, de = console.groupEnd;
          var N = {
            configurable: !0,
            enumerable: !0,
            value: T,
            writable: !0
          };
          Object.defineProperties(console, {
            info: N,
            log: N,
            warn: N,
            error: N,
            group: N,
            groupCollapsed: N,
            groupEnd: N
          });
        }
        $++;
      }
    }
    function ke() {
      {
        if ($--, $ === 0) {
          var N = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: L({}, N, {
              value: j
            }),
            info: L({}, N, {
              value: z
            }),
            warn: L({}, N, {
              value: H
            }),
            error: L({}, N, {
              value: X
            }),
            group: L({}, N, {
              value: E
            }),
            groupCollapsed: L({}, N, {
              value: ee
            }),
            groupEnd: L({}, N, {
              value: de
            })
          });
        }
        $ < 0 && v("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Se = g.ReactCurrentDispatcher, Pe;
    function Be(N, ce, ye) {
      {
        if (Pe === void 0)
          try {
            throw Error();
          } catch (wt) {
            var ze = wt.stack.trim().match(/\n( *(at )?)/);
            Pe = ze && ze[1] || "";
          }
        return `
` + Pe + N;
      }
    }
    var Ae = !1, pe;
    {
      var ue = typeof WeakMap == "function" ? WeakMap : Map;
      pe = new ue();
    }
    function xe(N, ce) {
      if (!N || Ae)
        return "";
      {
        var ye = pe.get(N);
        if (ye !== void 0)
          return ye;
      }
      var ze;
      Ae = !0;
      var wt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var kt;
      kt = Se.current, Se.current = null, be();
      try {
        if (ce) {
          var pt = function() {
            throw Error();
          };
          if (Object.defineProperty(pt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(pt, []);
            } catch (dr) {
              ze = dr;
            }
            Reflect.construct(N, [], pt);
          } else {
            try {
              pt.call();
            } catch (dr) {
              ze = dr;
            }
            N.call(pt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (dr) {
            ze = dr;
          }
          N();
        }
      } catch (dr) {
        if (dr && ze && typeof dr.stack == "string") {
          for (var ct = dr.stack.split(`
`), Yt = ze.stack.split(`
`), Ut = ct.length - 1, Bt = Yt.length - 1; Ut >= 1 && Bt >= 0 && ct[Ut] !== Yt[Bt]; )
            Bt--;
          for (; Ut >= 1 && Bt >= 0; Ut--, Bt--)
            if (ct[Ut] !== Yt[Bt]) {
              if (Ut !== 1 || Bt !== 1)
                do
                  if (Ut--, Bt--, Bt < 0 || ct[Ut] !== Yt[Bt]) {
                    var Wn = `
` + ct[Ut].replace(" at new ", " at ");
                    return N.displayName && Wn.includes("<anonymous>") && (Wn = Wn.replace("<anonymous>", N.displayName)), typeof N == "function" && pe.set(N, Wn), Wn;
                  }
                while (Ut >= 1 && Bt >= 0);
              break;
            }
        }
      } finally {
        Ae = !1, Se.current = kt, ke(), Error.prepareStackTrace = wt;
      }
      var Nr = N ? N.displayName || N.name : "", gc = Nr ? Be(Nr) : "";
      return typeof N == "function" && pe.set(N, gc), gc;
    }
    function fe(N, ce, ye) {
      return xe(N, !1);
    }
    function $e(N) {
      var ce = N.prototype;
      return !!(ce && ce.isReactComponent);
    }
    function nt(N, ce, ye) {
      if (N == null)
        return "";
      if (typeof N == "function")
        return xe(N, $e(N));
      if (typeof N == "string")
        return Be(N);
      switch (N) {
        case l:
          return Be("Suspense");
        case u:
          return Be("SuspenseList");
      }
      if (typeof N == "object")
        switch (N.$$typeof) {
          case c:
            return fe(N.render);
          case d:
            return nt(N.type, ce, ye);
          case p: {
            var ze = N, wt = ze._payload, kt = ze._init;
            try {
              return nt(kt(wt), ce, ye);
            } catch {
            }
          }
        }
      return "";
    }
    var q = Object.prototype.hasOwnProperty, ie = {}, se = g.ReactDebugCurrentFrame;
    function le(N) {
      if (N) {
        var ce = N._owner, ye = nt(N.type, N._source, ce ? ce.type : null);
        se.setExtraStackFrame(ye);
      } else
        se.setExtraStackFrame(null);
    }
    function De(N, ce, ye, ze, wt) {
      {
        var kt = Function.call.bind(q);
        for (var pt in N)
          if (kt(N, pt)) {
            var ct = void 0;
            try {
              if (typeof N[pt] != "function") {
                var Yt = Error((ze || "React class") + ": " + ye + " type `" + pt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof N[pt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Yt.name = "Invariant Violation", Yt;
              }
              ct = N[pt](ce, pt, ze, ye, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ut) {
              ct = Ut;
            }
            ct && !(ct instanceof Error) && (le(wt), v("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ze || "React class", ye, pt, typeof ct), le(null)), ct instanceof Error && !(ct.message in ie) && (ie[ct.message] = !0, le(wt), v("Failed %s type: %s", ye, ct.message), le(null));
          }
      }
    }
    var _e = Array.isArray;
    function Ze(N) {
      return _e(N);
    }
    function yt(N) {
      {
        var ce = typeof Symbol == "function" && Symbol.toStringTag, ye = ce && N[Symbol.toStringTag] || N.constructor.name || "Object";
        return ye;
      }
    }
    function et(N) {
      try {
        return W(N), !1;
      } catch {
        return !0;
      }
    }
    function W(N) {
      return "" + N;
    }
    function re(N) {
      if (et(N))
        return v("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", yt(N)), W(N);
    }
    var ae = g.ReactCurrentOwner, Te = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Xe, Lt, Pt;
    Pt = {};
    function Ct(N) {
      if (q.call(N, "ref")) {
        var ce = Object.getOwnPropertyDescriptor(N, "ref").get;
        if (ce && ce.isReactWarning)
          return !1;
      }
      return N.ref !== void 0;
    }
    function jt(N) {
      if (q.call(N, "key")) {
        var ce = Object.getOwnPropertyDescriptor(N, "key").get;
        if (ce && ce.isReactWarning)
          return !1;
      }
      return N.key !== void 0;
    }
    function Qt(N, ce) {
      if (typeof N.ref == "string" && ae.current && ce && ae.current.stateNode !== ce) {
        var ye = U(ae.current.type);
        Pt[ye] || (v('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', U(ae.current.type), N.ref), Pt[ye] = !0);
      }
    }
    function B(N, ce) {
      {
        var ye = function() {
          Xe || (Xe = !0, v("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ce));
        };
        ye.isReactWarning = !0, Object.defineProperty(N, "key", {
          get: ye,
          configurable: !0
        });
      }
    }
    function K(N, ce) {
      {
        var ye = function() {
          Lt || (Lt = !0, v("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ce));
        };
        ye.isReactWarning = !0, Object.defineProperty(N, "ref", {
          get: ye,
          configurable: !0
        });
      }
    }
    var tt = function(N, ce, ye, ze, wt, kt, pt) {
      var ct = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: N,
        key: ce,
        ref: ye,
        props: pt,
        // Record the component responsible for creating this element.
        _owner: kt
      };
      return ct._store = {}, Object.defineProperty(ct._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ct, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ze
      }), Object.defineProperty(ct, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: wt
      }), Object.freeze && (Object.freeze(ct.props), Object.freeze(ct)), ct;
    };
    function at(N, ce, ye, ze, wt) {
      {
        var kt, pt = {}, ct = null, Yt = null;
        ye !== void 0 && (re(ye), ct = "" + ye), jt(ce) && (re(ce.key), ct = "" + ce.key), Ct(ce) && (Yt = ce.ref, Qt(ce, wt));
        for (kt in ce)
          q.call(ce, kt) && !Te.hasOwnProperty(kt) && (pt[kt] = ce[kt]);
        if (N && N.defaultProps) {
          var Ut = N.defaultProps;
          for (kt in Ut)
            pt[kt] === void 0 && (pt[kt] = Ut[kt]);
        }
        if (ct || Yt) {
          var Bt = typeof N == "function" ? N.displayName || N.name || "Unknown" : N;
          ct && B(pt, Bt), Yt && K(pt, Bt);
        }
        return tt(N, ct, Yt, wt, ze, ae.current, pt);
      }
    }
    var It = g.ReactCurrentOwner, Qe = g.ReactDebugCurrentFrame;
    function ln(N) {
      if (N) {
        var ce = N._owner, ye = nt(N.type, N._source, ce ? ce.type : null);
        Qe.setExtraStackFrame(ye);
      } else
        Qe.setExtraStackFrame(null);
    }
    var Un;
    Un = !1;
    function Wt(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function wn() {
      {
        if (It.current) {
          var N = U(It.current.type);
          if (N)
            return `

Check the render method of \`` + N + "`.";
        }
        return "";
      }
    }
    function er(N) {
      {
        if (N !== void 0) {
          var ce = N.fileName.replace(/^.*[\\\/]/, ""), ye = N.lineNumber;
          return `

Check your code at ` + ce + ":" + ye + ".";
        }
        return "";
      }
    }
    var $t = {};
    function St(N) {
      {
        var ce = wn();
        if (!ce) {
          var ye = typeof N == "string" ? N : N.displayName || N.name;
          ye && (ce = `

Check the top-level render call using <` + ye + ">.");
        }
        return ce;
      }
    }
    function Kt(N, ce) {
      {
        if (!N._store || N._store.validated || N.key != null)
          return;
        N._store.validated = !0;
        var ye = St(ce);
        if ($t[ye])
          return;
        $t[ye] = !0;
        var ze = "";
        N && N._owner && N._owner !== It.current && (ze = " It was passed a child from " + U(N._owner.type) + "."), ln(N), v('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ye, ze), ln(null);
      }
    }
    function Zt(N, ce) {
      {
        if (typeof N != "object")
          return;
        if (Ze(N))
          for (var ye = 0; ye < N.length; ye++) {
            var ze = N[ye];
            Wt(ze) && Kt(ze, ce);
          }
        else if (Wt(N))
          N._store && (N._store.validated = !0);
        else if (N) {
          var wt = y(N);
          if (typeof wt == "function" && wt !== N.entries)
            for (var kt = wt.call(N), pt; !(pt = kt.next()).done; )
              Wt(pt.value) && Kt(pt.value, ce);
        }
      }
    }
    function Jt(N) {
      {
        var ce = N.type;
        if (ce == null || typeof ce == "string")
          return;
        var ye;
        if (typeof ce == "function")
          ye = ce.propTypes;
        else if (typeof ce == "object" && (ce.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ce.$$typeof === d))
          ye = ce.propTypes;
        else
          return;
        if (ye) {
          var ze = U(ce);
          De(ye, N.props, "prop", ze, N);
        } else if (ce.PropTypes !== void 0 && !Un) {
          Un = !0;
          var wt = U(ce);
          v("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", wt || "Unknown");
        }
        typeof ce.getDefaultProps == "function" && !ce.getDefaultProps.isReactClassApproved && v("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Nt(N) {
      {
        for (var ce = Object.keys(N.props), ye = 0; ye < ce.length; ye++) {
          var ze = ce[ye];
          if (ze !== "children" && ze !== "key") {
            ln(N), v("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ze), ln(null);
            break;
          }
        }
        N.ref !== null && (ln(N), v("Invalid attribute `ref` supplied to `React.Fragment`."), ln(null));
      }
    }
    function hn(N, ce, ye, ze, wt, kt) {
      {
        var pt = R(N);
        if (!pt) {
          var ct = "";
          (N === void 0 || typeof N == "object" && N !== null && Object.keys(N).length === 0) && (ct += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Yt = er(wt);
          Yt ? ct += Yt : ct += wn();
          var Ut;
          N === null ? Ut = "null" : Ze(N) ? Ut = "array" : N !== void 0 && N.$$typeof === t ? (Ut = "<" + (U(N.type) || "Unknown") + " />", ct = " Did you accidentally export a JSX literal instead of a component?") : Ut = typeof N, v("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ut, ct);
        }
        var Bt = at(N, ce, ye, wt, kt);
        if (Bt == null)
          return Bt;
        if (pt) {
          var Wn = ce.children;
          if (Wn !== void 0)
            if (ze)
              if (Ze(Wn)) {
                for (var Nr = 0; Nr < Wn.length; Nr++)
                  Zt(Wn[Nr], N);
                Object.freeze && Object.freeze(Wn);
              } else
                v("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Zt(Wn, N);
        }
        return N === r ? Nt(Bt) : Jt(Bt), Bt;
      }
    }
    function mn(N, ce, ye) {
      return hn(N, ce, ye, !0);
    }
    function An(N, ce, ye) {
      return hn(N, ce, ye, !1);
    }
    var Gi = An, Xi = mn;
    Za.Fragment = r, Za.jsx = Gi, Za.jsxs = Xi;
  }()), Za;
}
process.env.NODE_ENV === "production" ? kp.exports = oD() : kp.exports = aD();
var F = kp.exports;
function bt() {
  return bt = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, bt.apply(this, arguments);
}
function yd(e, t = []) {
  let n = [];
  function r(o, a) {
    const s = /* @__PURE__ */ gr(a), c = n.length;
    n = [
      ...n,
      a
    ];
    function l(d) {
      const { scope: p, children: f, ...h } = d, m = (p == null ? void 0 : p[e][c]) || s, y = ho(
        () => h,
        Object.values(h)
      );
      return /* @__PURE__ */ Me(m.Provider, {
        value: y
      }, f);
    }
    function u(d, p) {
      const f = (p == null ? void 0 : p[e][c]) || s, h = Ir(f);
      if (h)
        return h;
      if (a !== void 0)
        return a;
      throw new Error(`\`${d}\` must be used within \`${o}\``);
    }
    return l.displayName = o + "Provider", [
      l,
      u
    ];
  }
  const i = () => {
    const o = n.map((a) => /* @__PURE__ */ gr(a));
    return function(s) {
      const c = (s == null ? void 0 : s[e]) || o;
      return ho(
        () => ({
          [`__scope${e}`]: {
            ...s,
            [e]: c
          }
        }),
        [
          s,
          c
        ]
      );
    };
  };
  return i.scopeName = e, [
    r,
    sD(i, ...t)
  ];
}
function sD(...e) {
  const t = e[0];
  if (e.length === 1)
    return t;
  const n = () => {
    const r = e.map(
      (i) => ({
        useScope: i(),
        scopeName: i.scopeName
      })
    );
    return function(o) {
      const a = r.reduce((s, { useScope: c, scopeName: l }) => {
        const d = c(o)[`__scope${l}`];
        return {
          ...s,
          ...d
        };
      }, {});
      return ho(
        () => ({
          [`__scope${t.scopeName}`]: a
        }),
        [
          a
        ]
      );
    };
  };
  return n.scopeName = t.scopeName, n;
}
function Bn(e) {
  const t = Ke(e);
  return Ne(() => {
    t.current = e;
  }), ho(
    () => (...n) => {
      var r;
      return (r = t.current) === null || r === void 0 ? void 0 : r.call(t, ...n);
    },
    []
  );
}
const ha = globalThis != null && globalThis.document ? Ls : () => {
};
function vo() {
  return vo = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, vo.apply(null, arguments);
}
function cD(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function w1(...e) {
  return (t) => e.forEach(
    (n) => cD(n, t)
  );
}
function ur(...e) {
  return an(w1(...e), e);
}
const pm = /* @__PURE__ */ Ue((e, t) => {
  const { children: n, ...r } = e, i = Go.toArray(n), o = i.find(uD);
  if (o) {
    const a = o.props.children, s = i.map((c) => c === o ? Go.count(a) > 1 ? Go.only(null) : /* @__PURE__ */ ds(a) ? a.props.children : null : c);
    return /* @__PURE__ */ Me(Ep, vo({}, r, {
      ref: t
    }), /* @__PURE__ */ ds(a) ? /* @__PURE__ */ Uu(a, void 0, s) : null);
  }
  return /* @__PURE__ */ Me(Ep, vo({}, r, {
    ref: t
  }), n);
});
pm.displayName = "Slot";
const Ep = /* @__PURE__ */ Ue((e, t) => {
  const { children: n, ...r } = e;
  return /* @__PURE__ */ ds(n) ? /* @__PURE__ */ Uu(n, {
    ...dD(r, n.props),
    ref: t ? w1(t, n.ref) : n.ref
  }) : Go.count(n) > 1 ? Go.only(null) : null;
});
Ep.displayName = "SlotClone";
const lD = ({ children: e }) => /* @__PURE__ */ Me($i, null, e);
function uD(e) {
  return /* @__PURE__ */ ds(e) && e.type === lD;
}
function dD(e, t) {
  const n = {
    ...t
  };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...s) => {
      o(...s), i(...s);
    } : i && (n[r] = i) : r === "style" ? n[r] = {
      ...i,
      ...o
    } : r === "className" && (n[r] = [
      i,
      o
    ].filter(Boolean).join(" "));
  }
  return {
    ...e,
    ...n
  };
}
const fD = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], Rn = fD.reduce((e, t) => {
  const n = /* @__PURE__ */ Ue((r, i) => {
    const { asChild: o, ...a } = r, s = o ? pm : t;
    return Ne(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ Me(s, vo({}, a, {
      ref: i
    }));
  });
  return n.displayName = `Primitive.${t}`, {
    ...e,
    [t]: n
  };
}, {});
function pD(e, t) {
  e && Db(
    () => e.dispatchEvent(t)
  );
}
const x1 = "Avatar", [hD, iJ] = yd(x1), [mD, _1] = hD(x1), S1 = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeAvatar: n, ...r } = e, [i, o] = Ve("idle");
  return /* @__PURE__ */ Me(mD, {
    scope: n,
    imageLoadingStatus: i,
    onImageLoadingStatusChange: o
  }, /* @__PURE__ */ Me(Rn.span, bt({}, r, {
    ref: t
  })));
}), yD = "AvatarImage", k1 = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeAvatar: n, src: r, onLoadingStatusChange: i = () => {
  }, ...o } = e, a = _1(yD, n), s = vD(r), c = Bn((l) => {
    i(l), a.onImageLoadingStatusChange(l);
  });
  return ha(() => {
    s !== "idle" && c(s);
  }, [
    s,
    c
  ]), s === "loaded" ? /* @__PURE__ */ Me(Rn.img, bt({}, o, {
    ref: t,
    src: r
  })) : null;
}), gD = "AvatarFallback", E1 = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeAvatar: n, delayMs: r, ...i } = e, o = _1(gD, n), [a, s] = Ve(r === void 0);
  return Ne(() => {
    if (r !== void 0) {
      const c = window.setTimeout(
        () => s(!0),
        r
      );
      return () => window.clearTimeout(c);
    }
  }, [
    r
  ]), a && o.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ Me(Rn.span, bt({}, i, {
    ref: t
  })) : null;
});
function vD(e) {
  const [t, n] = Ve("idle");
  return Ne(() => {
    if (!e) {
      n("error");
      return;
    }
    let r = !0;
    const i = new window.Image(), o = (a) => () => {
      r && n(a);
    };
    return n("loading"), i.onload = o("loaded"), i.onerror = o("error"), i.src = e, () => {
      r = !1;
    };
  }, [
    e
  ]), t;
}
let hm = class {
  constructor() {
    k(this, "eventMap");
    this.eventMap = {};
  }
  on(t, n) {
    var r;
    return this.eventMap[t] || (this.eventMap[t] = /* @__PURE__ */ new Set()), (r = this.eventMap[t]) == null || r.add(n), () => {
      var i;
      (i = this.eventMap[t]) == null || i.delete(n);
    };
  }
  emit(t, n) {
    var r, i;
    (r = this.eventMap[t]) == null || r.forEach((o) => {
      o(n);
    }), (i = this.eventMap["*"]) == null || i.forEach((o) => {
      o({ type: t, payload: n });
    });
  }
};
const bD = new hm();
function C1(e, t) {
  let n = 0;
  if (e.length == 0)
    return n;
  for (let r = 0; r < e.length; r++) {
    const i = e.charCodeAt(r);
    n = (n << 5) - n + i, n = n & n;
  }
  return Math.abs(n) % t;
}
const T1 = Ue(
  ({ userId: e, src: t, container: n, image: r, fallback: i, ...o }, a) => {
    const s = C1(e ?? "", 15);
    return /* @__PURE__ */ F.jsxs(S1, { ref: a, "data-color": s, ...n, ...o, children: [
      /* @__PURE__ */ F.jsx(k1, { src: t, ...r }),
      /* @__PURE__ */ F.jsx(E1, { ...i, children: typeof o.children == "string" ? o.children[0] : o.children })
    ] });
  }
);
function wD(e, t) {
  const n = t || {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const xD = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, _D = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, SD = {};
function Ky(e, t) {
  return ((t || SD).jsx ? _D : xD).test(e);
}
const kD = /[ \t\n\f\r]/g;
function ED(e) {
  return typeof e == "object" ? e.type === "text" ? Jy(e.value) : !1 : Jy(e);
}
function Jy(e) {
  return e.replace(kD, "") === "";
}
class Qs {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
}
Qs.prototype.property = {};
Qs.prototype.normal = {};
Qs.prototype.space = null;
function R1(e, t) {
  const n = {}, r = {};
  let i = -1;
  for (; ++i < e.length; )
    Object.assign(n, e[i].property), Object.assign(r, e[i].normal);
  return new Qs(n, r, t);
}
function Cp(e) {
  return e.toLowerCase();
}
class br {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
}
br.prototype.space = null;
br.prototype.boolean = !1;
br.prototype.booleanish = !1;
br.prototype.overloadedBoolean = !1;
br.prototype.number = !1;
br.prototype.commaSeparated = !1;
br.prototype.spaceSeparated = !1;
br.prototype.commaOrSpaceSeparated = !1;
br.prototype.mustUseProperty = !1;
br.prototype.defined = !1;
let CD = 0;
const ht = Oo(), on = Oo(), A1 = Oo(), me = Oo(), zt = Oo(), ta = Oo(), nr = Oo();
function Oo() {
  return 2 ** ++CD;
}
const Tp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: ht,
  booleanish: on,
  commaOrSpaceSeparated: nr,
  commaSeparated: ta,
  number: me,
  overloadedBoolean: A1,
  spaceSeparated: zt
}, Symbol.toStringTag, { value: "Module" })), sf = Object.keys(Tp);
class mm extends br {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, i) {
    let o = -1;
    if (super(t, n), Yy(this, "space", i), typeof r == "number")
      for (; ++o < sf.length; ) {
        const a = sf[o];
        Yy(this, sf[o], (r & Tp[a]) === Tp[a]);
      }
  }
}
mm.prototype.defined = !0;
function Yy(e, t, n) {
  n && (e[t] = n);
}
const TD = {}.hasOwnProperty;
function Da(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if (TD.call(e.properties, r)) {
      const i = e.properties[r], o = new mm(
        r,
        e.transform(e.attributes || {}, r),
        i,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (o.mustUseProperty = !0), t[r] = o, n[Cp(r)] = r, n[Cp(o.attribute)] = r;
    }
  return new Qs(t, n, e.space);
}
const O1 = Da({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), I1 = Da({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function P1(e, t) {
  return t in e ? e[t] : t;
}
function $1(e, t) {
  return P1(e, t.toLowerCase());
}
const D1 = Da({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: $1,
  properties: { xmlns: null, xmlnsXLink: null }
}), N1 = Da({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: on,
    ariaAutoComplete: null,
    ariaBusy: on,
    ariaChecked: on,
    ariaColCount: me,
    ariaColIndex: me,
    ariaColSpan: me,
    ariaControls: zt,
    ariaCurrent: null,
    ariaDescribedBy: zt,
    ariaDetails: null,
    ariaDisabled: on,
    ariaDropEffect: zt,
    ariaErrorMessage: null,
    ariaExpanded: on,
    ariaFlowTo: zt,
    ariaGrabbed: on,
    ariaHasPopup: null,
    ariaHidden: on,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: zt,
    ariaLevel: me,
    ariaLive: null,
    ariaModal: on,
    ariaMultiLine: on,
    ariaMultiSelectable: on,
    ariaOrientation: null,
    ariaOwns: zt,
    ariaPlaceholder: null,
    ariaPosInSet: me,
    ariaPressed: on,
    ariaReadOnly: on,
    ariaRelevant: null,
    ariaRequired: on,
    ariaRoleDescription: zt,
    ariaRowCount: me,
    ariaRowIndex: me,
    ariaRowSpan: me,
    ariaSelected: on,
    ariaSetSize: me,
    ariaSort: null,
    ariaValueMax: me,
    ariaValueMin: me,
    ariaValueNow: me,
    ariaValueText: null,
    role: null
  }
}), RD = Da({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: $1,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: ta,
    acceptCharset: zt,
    accessKey: zt,
    action: null,
    allow: null,
    allowFullScreen: ht,
    allowPaymentRequest: ht,
    allowUserMedia: ht,
    alt: null,
    as: null,
    async: ht,
    autoCapitalize: null,
    autoComplete: zt,
    autoFocus: ht,
    autoPlay: ht,
    capture: ht,
    charSet: null,
    checked: ht,
    cite: null,
    className: zt,
    cols: me,
    colSpan: null,
    content: null,
    contentEditable: on,
    controls: ht,
    controlsList: zt,
    coords: me | ta,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: ht,
    defer: ht,
    dir: null,
    dirName: null,
    disabled: ht,
    download: A1,
    draggable: on,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: ht,
    formTarget: null,
    headers: zt,
    height: me,
    hidden: ht,
    high: me,
    href: null,
    hrefLang: null,
    htmlFor: zt,
    httpEquiv: zt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: ht,
    itemId: null,
    itemProp: zt,
    itemRef: zt,
    itemScope: ht,
    itemType: zt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: ht,
    low: me,
    manifest: null,
    max: null,
    maxLength: me,
    media: null,
    method: null,
    min: null,
    minLength: me,
    multiple: ht,
    muted: ht,
    name: null,
    nonce: null,
    noModule: ht,
    noValidate: ht,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: ht,
    optimum: me,
    pattern: null,
    ping: zt,
    placeholder: null,
    playsInline: ht,
    poster: null,
    preload: null,
    readOnly: ht,
    referrerPolicy: null,
    rel: zt,
    required: ht,
    reversed: ht,
    rows: me,
    rowSpan: me,
    sandbox: zt,
    scope: null,
    scoped: ht,
    seamless: ht,
    selected: ht,
    shape: null,
    size: me,
    sizes: null,
    slot: null,
    span: me,
    spellCheck: on,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: me,
    step: null,
    style: null,
    tabIndex: me,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: ht,
    useMap: null,
    value: on,
    width: me,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: zt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: me,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: me,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: ht,
    // Lists. Use CSS to reduce space between items instead
    declare: ht,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: me,
    // `<img>` and `<object>`
    leftMargin: me,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: me,
    // `<body>`
    marginWidth: me,
    // `<body>`
    noResize: ht,
    // `<frame>`
    noHref: ht,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: ht,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: ht,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: me,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: on,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: me,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: me,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: ht,
    disableRemotePlayback: ht,
    prefix: null,
    property: null,
    results: me,
    security: null,
    unselectable: null
  }
}), AD = Da({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: P1,
  properties: {
    about: nr,
    accentHeight: me,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: me,
    amplitude: me,
    arabicForm: null,
    ascent: me,
    attributeName: null,
    attributeType: null,
    azimuth: me,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: me,
    by: null,
    calcMode: null,
    capHeight: me,
    className: zt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: me,
    diffuseConstant: me,
    direction: null,
    display: null,
    dur: null,
    divisor: me,
    dominantBaseline: null,
    download: ht,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: me,
    enableBackground: null,
    end: null,
    event: null,
    exponent: me,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: me,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: ta,
    g2: ta,
    glyphName: ta,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: me,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: me,
    horizOriginX: me,
    horizOriginY: me,
    id: null,
    ideographic: me,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: me,
    k: me,
    k1: me,
    k2: me,
    k3: me,
    k4: me,
    kernelMatrix: nr,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: me,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: me,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: me,
    overlineThickness: me,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: me,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: zt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: me,
    pointsAtY: me,
    pointsAtZ: me,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: nr,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: nr,
    rev: nr,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: nr,
    requiredFeatures: nr,
    requiredFonts: nr,
    requiredFormats: nr,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: me,
    specularExponent: me,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: me,
    strikethroughThickness: me,
    string: null,
    stroke: null,
    strokeDashArray: nr,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: me,
    strokeOpacity: me,
    strokeWidth: null,
    style: null,
    surfaceScale: me,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: nr,
    tabIndex: me,
    tableValues: null,
    target: null,
    targetX: me,
    targetY: me,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: nr,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: me,
    underlineThickness: me,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: me,
    values: null,
    vAlphabetic: me,
    vMathematical: me,
    vectorEffect: null,
    vHanging: me,
    vIdeographic: me,
    version: null,
    vertAdvY: me,
    vertOriginX: me,
    vertOriginY: me,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: me,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), OD = /^data[-\w.:]+$/i, Gy = /-[a-z]/g, ID = /[A-Z]/g;
function PD(e, t) {
  const n = Cp(t);
  let r = t, i = br;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && OD.test(t)) {
    if (t.charAt(4) === "-") {
      const o = t.slice(5).replace(Gy, DD);
      r = "data" + o.charAt(0).toUpperCase() + o.slice(1);
    } else {
      const o = t.slice(4);
      if (!Gy.test(o)) {
        let a = o.replace(ID, $D);
        a.charAt(0) !== "-" && (a = "-" + a), t = "data" + a;
      }
    }
    i = mm;
  }
  return new i(r, t);
}
function $D(e) {
  return "-" + e.toLowerCase();
}
function DD(e) {
  return e.charAt(1).toUpperCase();
}
const ND = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, jD = R1([I1, O1, D1, N1, RD], "html"), ym = R1([I1, O1, D1, N1, AD], "svg");
function MD(e) {
  return e.join(" ").trim();
}
var j1 = {}, Xy = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, qD = /\n/g, LD = /^\s*/, FD = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, UD = /^:\s*/, BD = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, zD = /^[;\s]*/, ZD = /^\s+|\s+$/g, VD = `
`, Qy = "/", eg = "*", oo = "", HD = "comment", WD = "declaration", KD = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  t = t || {};
  var n = 1, r = 1;
  function i(h) {
    var m = h.match(qD);
    m && (n += m.length);
    var y = h.lastIndexOf(VD);
    r = ~y ? h.length - y : r + h.length;
  }
  function o() {
    var h = { line: n, column: r };
    return function(m) {
      return m.position = new a(h), l(), m;
    };
  }
  function a(h) {
    this.start = h, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(h) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + h
    );
    if (m.reason = h, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent)
      throw m;
  }
  function c(h) {
    var m = h.exec(e);
    if (m) {
      var y = m[0];
      return i(y), e = e.slice(y.length), m;
    }
  }
  function l() {
    c(LD);
  }
  function u(h) {
    var m;
    for (h = h || []; m = d(); )
      m !== !1 && h.push(m);
    return h;
  }
  function d() {
    var h = o();
    if (!(Qy != e.charAt(0) || eg != e.charAt(1))) {
      for (var m = 2; oo != e.charAt(m) && (eg != e.charAt(m) || Qy != e.charAt(m + 1)); )
        ++m;
      if (m += 2, oo === e.charAt(m - 1))
        return s("End of comment missing");
      var y = e.slice(2, m - 2);
      return r += 2, i(y), e = e.slice(m), r += 2, h({
        type: HD,
        comment: y
      });
    }
  }
  function p() {
    var h = o(), m = c(FD);
    if (m) {
      if (d(), !c(UD))
        return s("property missing ':'");
      var y = c(BD), g = h({
        type: WD,
        property: tg(m[0].replace(Xy, oo)),
        value: y ? tg(y[0].replace(Xy, oo)) : oo
      });
      return c(zD), g;
    }
  }
  function f() {
    var h = [];
    u(h);
    for (var m; m = p(); )
      m !== !1 && (h.push(m), u(h));
    return h;
  }
  return l(), f();
};
function tg(e) {
  return e ? e.replace(ZD, oo) : oo;
}
var JD = it && it.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(j1, "__esModule", { value: !0 });
var YD = JD(KD);
function GD(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, YD.default)(e), i = typeof t == "function";
  return r.forEach(function(o) {
    if (o.type === "declaration") {
      var a = o.property, s = o.value;
      i ? t(a, s, o) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var ng = j1.default = GD;
const XD = ng.default || ng, M1 = q1("end"), gm = q1("start");
function q1(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function QD(e) {
  const t = gm(e), n = M1(e);
  if (t && n)
    return { start: t, end: n };
}
function rs(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? rg(e.position) : "start" in e || "end" in e ? rg(e) : "line" in e || "column" in e ? Rp(e) : "";
}
function Rp(e) {
  return ig(e && e.line) + ":" + ig(e && e.column);
}
function rg(e) {
  return Rp(e && e.start) + "-" + Rp(e && e.end);
}
function ig(e) {
  return e && typeof e == "number" ? e : 1;
}
class Fn extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", o = {}, a = !1;
    if (n && ("line" in n && "column" in n ? o = { place: n } : "start" in n && "end" in n ? o = { place: n } : "type" in n ? o = {
      ancestors: [n],
      place: n.position
    } : o = { ...n }), typeof t == "string" ? i = t : !o.cause && t && (a = !0, i = t.message, o.cause = t), !o.ruleId && !o.source && typeof r == "string") {
      const c = r.indexOf(":");
      c === -1 ? o.ruleId = r : (o.source = r.slice(0, c), o.ruleId = r.slice(c + 1));
    }
    if (!o.place && o.ancestors && o.ancestors) {
      const c = o.ancestors[o.ancestors.length - 1];
      c && (o.place = c.position);
    }
    const s = o.place && "start" in o.place ? o.place.start : o.place;
    this.ancestors = o.ancestors || void 0, this.cause = o.cause || void 0, this.column = s ? s.column : void 0, this.fatal = void 0, this.file, this.message = i, this.line = s ? s.line : void 0, this.name = rs(o.place) || "1:1", this.place = o.place || void 0, this.reason = this.message, this.ruleId = o.ruleId || void 0, this.source = o.source || void 0, this.stack = a && o.cause && typeof o.cause.stack == "string" ? o.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
Fn.prototype.file = "";
Fn.prototype.name = "";
Fn.prototype.reason = "";
Fn.prototype.message = "";
Fn.prototype.stack = "";
Fn.prototype.column = void 0;
Fn.prototype.line = void 0;
Fn.prototype.ancestors = void 0;
Fn.prototype.cause = void 0;
Fn.prototype.fatal = void 0;
Fn.prototype.place = void 0;
Fn.prototype.ruleId = void 0;
Fn.prototype.source = void 0;
const vm = {}.hasOwnProperty, eN = /* @__PURE__ */ new Map(), tN = /[A-Z]/g, nN = /-([a-z])/g, rN = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), iN = /* @__PURE__ */ new Set(["td", "th"]), L1 = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function oN(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = pN(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = fN(n, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? ym : jD,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, o = F1(i, e, void 0);
  return o && typeof o != "string" ? o : i.create(
    e,
    i.Fragment,
    { children: o || void 0 },
    void 0
  );
}
function F1(e, t, n) {
  if (t.type === "element")
    return aN(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return sN(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return lN(e, t, n);
  if (t.type === "mdxjsEsm")
    return cN(e, t);
  if (t.type === "root")
    return uN(e, t, n);
  if (t.type === "text")
    return dN(e, t);
}
function aN(e, t, n) {
  const r = e.schema;
  let i = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = ym, e.schema = i), e.ancestors.push(t);
  const o = B1(e, t.tagName, !1), a = hN(e, t);
  let s = wm(e, t);
  return rN.has(t.tagName) && (s = s.filter(function(c) {
    return typeof c == "string" ? !ED(c) : !0;
  })), U1(e, a, o, t), bm(a, s), e.ancestors.pop(), e.schema = r, e.create(t, o, a, n);
}
function sN(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  vs(e, t.position);
}
function cN(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  vs(e, t.position);
}
function lN(e, t, n) {
  const r = e.schema;
  let i = r;
  t.name === "svg" && r.space === "html" && (i = ym, e.schema = i), e.ancestors.push(t);
  const o = t.name === null ? e.Fragment : B1(e, t.name, !0), a = mN(e, t), s = wm(e, t);
  return U1(e, a, o, t), bm(a, s), e.ancestors.pop(), e.schema = r, e.create(t, o, a, n);
}
function uN(e, t, n) {
  const r = {};
  return bm(r, wm(e, t)), e.create(t, e.Fragment, r, n);
}
function dN(e, t) {
  return t.value;
}
function U1(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function bm(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function fN(e, t, n) {
  return r;
  function r(i, o, a, s) {
    const l = Array.isArray(a.children) ? n : t;
    return s ? l(o, a, s) : l(o, a);
  }
}
function pN(e, t) {
  return n;
  function n(r, i, o, a) {
    const s = Array.isArray(o.children), c = gm(r);
    return t(
      i,
      o,
      a,
      s,
      {
        columnNumber: c ? c.column - 1 : void 0,
        fileName: e,
        lineNumber: c ? c.line : void 0
      },
      void 0
    );
  }
}
function hN(e, t) {
  const n = {};
  let r, i;
  for (i in t.properties)
    if (i !== "children" && vm.call(t.properties, i)) {
      const o = yN(e, i, t.properties[i]);
      if (o) {
        const [a, s] = o;
        e.tableCellAlignToStyle && a === "align" && typeof s == "string" && iN.has(t.tagName) ? r = s : n[a] = s;
      }
    }
  if (r) {
    const o = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    o[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function mN(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const o = r.data.estree.body[0];
        o.type;
        const a = o.expression;
        a.type;
        const s = a.properties[0];
        s.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(s.argument)
        );
      } else
        vs(e, t.position);
    else {
      const i = r.name;
      let o;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const s = r.value.data.estree.body[0];
          s.type, o = e.evaluater.evaluateExpression(s.expression);
        } else
          vs(e, t.position);
      else
        o = r.value === null ? !0 : r.value;
      n[i] = /** @type {Props[keyof Props]} */
      o;
    }
  return n;
}
function wm(e, t) {
  const n = [];
  let r = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : eN;
  for (; ++r < t.children.length; ) {
    const o = t.children[r];
    let a;
    if (e.passKeys) {
      const c = o.type === "element" ? o.tagName : o.type === "mdxJsxFlowElement" || o.type === "mdxJsxTextElement" ? o.name : void 0;
      if (c) {
        const l = i.get(c) || 0;
        a = c + "-" + l, i.set(c, l + 1);
      }
    }
    const s = F1(e, o, a);
    s !== void 0 && n.push(s);
  }
  return n;
}
function yN(e, t, n) {
  const r = PD(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? wD(n) : MD(n)), r.property === "style") {
      let i = typeof n == "object" ? n : gN(e, String(n));
      return e.stylePropertyNameCase === "css" && (i = vN(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? ND[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function gN(e, t) {
  const n = {};
  try {
    XD(t, r);
  } catch (i) {
    if (!e.ignoreInvalidStyle) {
      const o = (
        /** @type {Error} */
        i
      ), a = new Fn("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: o,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw a.file = e.filePath || void 0, a.url = L1 + "#cannot-parse-style-attribute", a;
    }
  }
  return n;
  function r(i, o) {
    let a = i;
    a.slice(0, 2) !== "--" && (a.slice(0, 4) === "-ms-" && (a = "ms-" + a.slice(4)), a = a.replace(nN, wN)), n[a] = o;
  }
}
function B1(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let o = -1, a;
    for (; ++o < i.length; ) {
      const s = Ky(i[o]) ? { type: "Identifier", name: i[o] } : { type: "Literal", value: i[o] };
      a = a ? {
        type: "MemberExpression",
        object: a,
        property: s,
        computed: !!(o && s.type === "Literal"),
        optional: !1
      } : s;
    }
    r = a;
  } else
    r = Ky(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const i = (
      /** @type {keyof JSX.IntrinsicElements} */
      r.value
    );
    return vm.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  vs(e);
}
function vs(e, t) {
  const n = new Fn(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = L1 + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function vN(e) {
  const t = {};
  let n;
  for (n in e)
    vm.call(e, n) && (t[bN(n)] = e[n]);
  return t;
}
function bN(e) {
  let t = e.replace(tN, xN);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function wN(e, t) {
  return t.toUpperCase();
}
function xN(e) {
  return "-" + e.toLowerCase();
}
const cf = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, _N = {};
function xm(e, t) {
  const n = t || _N, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return z1(e, r, i);
}
function z1(e, t, n) {
  if (SN(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return og(e.children, t, n);
  }
  return Array.isArray(e) ? og(e, t, n) : "";
}
function og(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = z1(e[i], t, n);
  return r.join("");
}
function SN(e) {
  return !!(e && typeof e == "object");
}
const ag = document.createElement("i");
function _m(e) {
  const t = "&" + e + ";";
  ag.innerHTML = t;
  const n = ag.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function sr(e, t, n, r) {
  const i = e.length;
  let o = 0, a;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    a = Array.from(r), a.unshift(t, n), e.splice(...a);
  else
    for (n && e.splice(t, n); o < r.length; )
      a = r.slice(o, o + 1e4), a.unshift(t, 0), e.splice(...a), o += 1e4, t += 1e4;
}
function hr(e, t) {
  return e.length > 0 ? (sr(e, e.length, 0, t), e) : t;
}
const sg = {}.hasOwnProperty;
function Z1(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    kN(t, e[n]);
  return t;
}
function kN(e, t) {
  let n;
  for (n in t) {
    const i = (sg.call(e, n) ? e[n] : void 0) || (e[n] = {}), o = t[n];
    let a;
    if (o)
      for (a in o) {
        sg.call(i, a) || (i[a] = []);
        const s = o[a];
        EN(
          // @ts-expect-error Looks like a list.
          i[a],
          Array.isArray(s) ? s : s ? [s] : []
        );
      }
  }
}
function EN(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  sr(e, 0, 0, r);
}
function V1(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function Tr(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const zn = Wi(/[A-Za-z]/), Dn = Wi(/[\dA-Za-z]/), CN = Wi(/[#-'*+\--9=?A-Z^-~]/);
function cu(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const Ap = Wi(/\d/), TN = Wi(/[\dA-Fa-f]/), RN = Wi(/[!-/:-@[-`{-~]/);
function Ye(e) {
  return e !== null && e < -2;
}
function Mt(e) {
  return e !== null && (e < 0 || e === 32);
}
function vt(e) {
  return e === -2 || e === -1 || e === 32;
}
const gd = Wi(/\p{P}|\p{S}/u), bo = Wi(/\s/);
function Wi(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function Na(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const o = e.charCodeAt(n);
    let a = "";
    if (o === 37 && Dn(e.charCodeAt(n + 1)) && Dn(e.charCodeAt(n + 2)))
      i = 2;
    else if (o < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(o)) || (a = String.fromCharCode(o));
    else if (o > 55295 && o < 57344) {
      const s = e.charCodeAt(n + 1);
      o < 56320 && s > 56319 && s < 57344 ? (a = String.fromCharCode(o, s), i = 1) : a = "";
    } else
      a = String.fromCharCode(o);
    a && (t.push(e.slice(r, n), encodeURIComponent(a)), r = n + i + 1, a = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
function Tt(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let o = 0;
  return a;
  function a(c) {
    return vt(c) ? (e.enter(n), s(c)) : t(c);
  }
  function s(c) {
    return vt(c) && o++ < i ? (e.consume(c), s) : (e.exit(n), t(c));
  }
}
const AN = {
  tokenize: ON
};
function ON(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    i
  );
  let n;
  return t;
  function r(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), Tt(e, t, "linePrefix");
  }
  function i(s) {
    return e.enter("paragraph"), o(s);
  }
  function o(s) {
    const c = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = c), n = c, a(s);
  }
  function a(s) {
    if (s === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(s);
      return;
    }
    return Ye(s) ? (e.consume(s), e.exit("chunkText"), o) : (e.consume(s), a);
  }
}
const IN = {
  tokenize: PN
}, cg = {
  tokenize: $N
};
function PN(e) {
  const t = this, n = [];
  let r = 0, i, o, a;
  return s;
  function s(b) {
    if (r < n.length) {
      const _ = n[r];
      return t.containerState = _[1], e.attempt(
        _[0].continuation,
        c,
        l
      )(b);
    }
    return l(b);
  }
  function c(b) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && v();
      const _ = t.events.length;
      let S = _, x;
      for (; S--; )
        if (t.events[S][0] === "exit" && t.events[S][1].type === "chunkFlow") {
          x = t.events[S][1].end;
          break;
        }
      g(r);
      let A = _;
      for (; A < t.events.length; )
        t.events[A][1].end = Object.assign({}, x), A++;
      return sr(
        t.events,
        S + 1,
        0,
        t.events.slice(_)
      ), t.events.length = A, l(b);
    }
    return s(b);
  }
  function l(b) {
    if (r === n.length) {
      if (!i)
        return p(b);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return h(b);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      cg,
      u,
      d
    )(b);
  }
  function u(b) {
    return i && v(), g(r), p(b);
  }
  function d(b) {
    return t.parser.lazy[t.now().line] = r !== n.length, a = t.now().offset, h(b);
  }
  function p(b) {
    return t.containerState = {}, e.attempt(
      cg,
      f,
      h
    )(b);
  }
  function f(b) {
    return r++, n.push([t.currentConstruct, t.containerState]), p(b);
  }
  function h(b) {
    if (b === null) {
      i && v(), g(0), e.consume(b);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: o,
      _tokenizer: i
    }), m(b);
  }
  function m(b) {
    if (b === null) {
      y(e.exit("chunkFlow"), !0), g(0), e.consume(b);
      return;
    }
    return Ye(b) ? (e.consume(b), y(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, s) : (e.consume(b), m);
  }
  function y(b, _) {
    const S = t.sliceStream(b);
    if (_ && S.push(null), b.previous = o, o && (o.next = b), o = b, i.defineSkip(b.start), i.write(S), t.parser.lazy[b.start.line]) {
      let x = i.events.length;
      for (; x--; )
        if (
          // The token starts before the line ending
          i.events[x][1].start.offset < a && // and either is not ended yet
          (!i.events[x][1].end || // or ends after it.
          i.events[x][1].end.offset > a)
        )
          return;
      const A = t.events.length;
      let I = A, P, R;
      for (; I--; )
        if (t.events[I][0] === "exit" && t.events[I][1].type === "chunkFlow") {
          if (P) {
            R = t.events[I][1].end;
            break;
          }
          P = !0;
        }
      for (g(r), x = A; x < t.events.length; )
        t.events[x][1].end = Object.assign({}, R), x++;
      sr(
        t.events,
        I + 1,
        0,
        t.events.slice(A)
      ), t.events.length = x;
    }
  }
  function g(b) {
    let _ = n.length;
    for (; _-- > b; ) {
      const S = n[_];
      t.containerState = S[1], S[0].exit.call(t, e);
    }
    n.length = b;
  }
  function v() {
    i.write([null]), o = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function $N(e, t, n) {
  return Tt(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function lu(e) {
  if (e === null || Mt(e) || bo(e))
    return 1;
  if (gd(e))
    return 2;
}
function vd(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const o = e[i].resolveAll;
    o && !r.includes(o) && (t = o(t, n), r.push(o));
  }
  return t;
}
const Op = {
  name: "attention",
  tokenize: NN,
  resolveAll: DN
};
function DN(e, t) {
  let n = -1, r, i, o, a, s, c, l, u;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          c = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const d = Object.assign({}, e[r][1].end), p = Object.assign({}, e[n][1].start);
          lg(d, -c), lg(p, c), a = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: d,
            end: Object.assign({}, e[r][1].end)
          }, s = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[n][1].start),
            end: p
          }, o = {
            type: c > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[n][1].start)
          }, i = {
            type: c > 1 ? "strong" : "emphasis",
            start: Object.assign({}, a.start),
            end: Object.assign({}, s.end)
          }, e[r][1].end = Object.assign({}, a.start), e[n][1].start = Object.assign({}, s.end), l = [], e[r][1].end.offset - e[r][1].start.offset && (l = hr(l, [
            ["enter", e[r][1], t],
            ["exit", e[r][1], t]
          ])), l = hr(l, [
            ["enter", i, t],
            ["enter", a, t],
            ["exit", a, t],
            ["enter", o, t]
          ]), l = hr(
            l,
            vd(
              t.parser.constructs.insideSpan.null,
              e.slice(r + 1, n),
              t
            )
          ), l = hr(l, [
            ["exit", o, t],
            ["enter", s, t],
            ["exit", s, t],
            ["exit", i, t]
          ]), e[n][1].end.offset - e[n][1].start.offset ? (u = 2, l = hr(l, [
            ["enter", e[n][1], t],
            ["exit", e[n][1], t]
          ])) : u = 0, sr(e, r - 1, n - r + 3, l), n = r + l.length - u - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function NN(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = lu(r);
  let o;
  return a;
  function a(c) {
    return o = c, e.enter("attentionSequence"), s(c);
  }
  function s(c) {
    if (c === o)
      return e.consume(c), s;
    const l = e.exit("attentionSequence"), u = lu(c), d = !u || u === 2 && i || n.includes(c), p = !i || i === 2 && u || n.includes(r);
    return l._open = !!(o === 42 ? d : d && (i || !p)), l._close = !!(o === 42 ? p : p && (u || !d)), t(c);
  }
}
function lg(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const jN = {
  name: "autolink",
  tokenize: MN
};
function MN(e, t, n) {
  let r = 0;
  return i;
  function i(f) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), o;
  }
  function o(f) {
    return zn(f) ? (e.consume(f), a) : l(f);
  }
  function a(f) {
    return f === 43 || f === 45 || f === 46 || Dn(f) ? (r = 1, s(f)) : l(f);
  }
  function s(f) {
    return f === 58 ? (e.consume(f), r = 0, c) : (f === 43 || f === 45 || f === 46 || Dn(f)) && r++ < 32 ? (e.consume(f), s) : (r = 0, l(f));
  }
  function c(f) {
    return f === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.exit("autolink"), t) : f === null || f === 32 || f === 60 || cu(f) ? n(f) : (e.consume(f), c);
  }
  function l(f) {
    return f === 64 ? (e.consume(f), u) : CN(f) ? (e.consume(f), l) : n(f);
  }
  function u(f) {
    return Dn(f) ? d(f) : n(f);
  }
  function d(f) {
    return f === 46 ? (e.consume(f), r = 0, u) : f === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.exit("autolink"), t) : p(f);
  }
  function p(f) {
    if ((f === 45 || Dn(f)) && r++ < 63) {
      const h = f === 45 ? p : d;
      return e.consume(f), h;
    }
    return n(f);
  }
}
const ec = {
  tokenize: qN,
  partial: !0
};
function qN(e, t, n) {
  return r;
  function r(o) {
    return vt(o) ? Tt(e, i, "linePrefix")(o) : i(o);
  }
  function i(o) {
    return o === null || Ye(o) ? t(o) : n(o);
  }
}
const H1 = {
  name: "blockQuote",
  tokenize: LN,
  continuation: {
    tokenize: FN
  },
  exit: UN
};
function LN(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    if (a === 62) {
      const s = r.containerState;
      return s.open || (e.enter("blockQuote", {
        _container: !0
      }), s.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(a), e.exit("blockQuoteMarker"), o;
    }
    return n(a);
  }
  function o(a) {
    return vt(a) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(a), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(a));
  }
}
function FN(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return vt(a) ? Tt(
      e,
      o,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(a) : o(a);
  }
  function o(a) {
    return e.attempt(H1, t, n)(a);
  }
}
function UN(e) {
  e.exit("blockQuote");
}
const W1 = {
  name: "characterEscape",
  tokenize: BN
};
function BN(e, t, n) {
  return r;
  function r(o) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(o), e.exit("escapeMarker"), i;
  }
  function i(o) {
    return RN(o) ? (e.enter("characterEscapeValue"), e.consume(o), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(o);
  }
}
const K1 = {
  name: "characterReference",
  tokenize: zN
};
function zN(e, t, n) {
  const r = this;
  let i = 0, o, a;
  return s;
  function s(d) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), c;
  }
  function c(d) {
    return d === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(d), e.exit("characterReferenceMarkerNumeric"), l) : (e.enter("characterReferenceValue"), o = 31, a = Dn, u(d));
  }
  function l(d) {
    return d === 88 || d === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(d), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), o = 6, a = TN, u) : (e.enter("characterReferenceValue"), o = 7, a = Ap, u(d));
  }
  function u(d) {
    if (d === 59 && i) {
      const p = e.exit("characterReferenceValue");
      return a === Dn && !_m(r.sliceSerialize(p)) ? n(d) : (e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return a(d) && i++ < o ? (e.consume(d), u) : n(d);
  }
}
const ug = {
  tokenize: VN,
  partial: !0
}, dg = {
  name: "codeFenced",
  tokenize: ZN,
  concrete: !0
};
function ZN(e, t, n) {
  const r = this, i = {
    tokenize: S,
    partial: !0
  };
  let o = 0, a = 0, s;
  return c;
  function c(x) {
    return l(x);
  }
  function l(x) {
    const A = r.events[r.events.length - 1];
    return o = A && A[1].type === "linePrefix" ? A[2].sliceSerialize(A[1], !0).length : 0, s = x, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), u(x);
  }
  function u(x) {
    return x === s ? (a++, e.consume(x), u) : a < 3 ? n(x) : (e.exit("codeFencedFenceSequence"), vt(x) ? Tt(e, d, "whitespace")(x) : d(x));
  }
  function d(x) {
    return x === null || Ye(x) ? (e.exit("codeFencedFence"), r.interrupt ? t(x) : e.check(ug, m, _)(x)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), p(x));
  }
  function p(x) {
    return x === null || Ye(x) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), d(x)) : vt(x) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Tt(e, f, "whitespace")(x)) : x === 96 && x === s ? n(x) : (e.consume(x), p);
  }
  function f(x) {
    return x === null || Ye(x) ? d(x) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), h(x));
  }
  function h(x) {
    return x === null || Ye(x) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), d(x)) : x === 96 && x === s ? n(x) : (e.consume(x), h);
  }
  function m(x) {
    return e.attempt(i, _, y)(x);
  }
  function y(x) {
    return e.enter("lineEnding"), e.consume(x), e.exit("lineEnding"), g;
  }
  function g(x) {
    return o > 0 && vt(x) ? Tt(
      e,
      v,
      "linePrefix",
      o + 1
    )(x) : v(x);
  }
  function v(x) {
    return x === null || Ye(x) ? e.check(ug, m, _)(x) : (e.enter("codeFlowValue"), b(x));
  }
  function b(x) {
    return x === null || Ye(x) ? (e.exit("codeFlowValue"), v(x)) : (e.consume(x), b);
  }
  function _(x) {
    return e.exit("codeFenced"), t(x);
  }
  function S(x, A, I) {
    let P = 0;
    return R;
    function R($) {
      return x.enter("lineEnding"), x.consume($), x.exit("lineEnding"), M;
    }
    function M($) {
      return x.enter("codeFencedFence"), vt($) ? Tt(
        x,
        V,
        "linePrefix",
        r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )($) : V($);
    }
    function V($) {
      return $ === s ? (x.enter("codeFencedFenceSequence"), U($)) : I($);
    }
    function U($) {
      return $ === s ? (P++, x.consume($), U) : P >= a ? (x.exit("codeFencedFenceSequence"), vt($) ? Tt(x, L, "whitespace")($) : L($)) : I($);
    }
    function L($) {
      return $ === null || Ye($) ? (x.exit("codeFencedFence"), A($)) : I($);
    }
  }
}
function VN(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return a === null ? n(a) : (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o);
  }
  function o(a) {
    return r.parser.lazy[r.now().line] ? n(a) : t(a);
  }
}
const lf = {
  name: "codeIndented",
  tokenize: WN
}, HN = {
  tokenize: KN,
  partial: !0
};
function WN(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return e.enter("codeIndented"), Tt(e, o, "linePrefix", 4 + 1)(l);
  }
  function o(l) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? a(l) : n(l);
  }
  function a(l) {
    return l === null ? c(l) : Ye(l) ? e.attempt(HN, a, c)(l) : (e.enter("codeFlowValue"), s(l));
  }
  function s(l) {
    return l === null || Ye(l) ? (e.exit("codeFlowValue"), a(l)) : (e.consume(l), s);
  }
  function c(l) {
    return e.exit("codeIndented"), t(l);
  }
}
function KN(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return r.parser.lazy[r.now().line] ? n(a) : Ye(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), i) : Tt(e, o, "linePrefix", 4 + 1)(a);
  }
  function o(a) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : Ye(a) ? i(a) : n(a);
  }
}
const JN = {
  name: "codeText",
  tokenize: XN,
  resolve: YN,
  previous: GN
};
function YN(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function GN(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function XN(e, t, n) {
  let r = 0, i, o;
  return a;
  function a(d) {
    return e.enter("codeText"), e.enter("codeTextSequence"), s(d);
  }
  function s(d) {
    return d === 96 ? (e.consume(d), r++, s) : (e.exit("codeTextSequence"), c(d));
  }
  function c(d) {
    return d === null ? n(d) : d === 32 ? (e.enter("space"), e.consume(d), e.exit("space"), c) : d === 96 ? (o = e.enter("codeTextSequence"), i = 0, u(d)) : Ye(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), c) : (e.enter("codeTextData"), l(d));
  }
  function l(d) {
    return d === null || d === 32 || d === 96 || Ye(d) ? (e.exit("codeTextData"), c(d)) : (e.consume(d), l);
  }
  function u(d) {
    return d === 96 ? (e.consume(d), i++, u) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(d)) : (o.type = "codeTextData", l(d));
  }
}
function J1(e) {
  const t = {};
  let n = -1, r, i, o, a, s, c, l;
  for (; ++n < e.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = e[n], n && r[1].type === "chunkFlow" && e[n - 1][1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, o = 0, o < c.length && c[o][1].type === "lineEndingBlank" && (o += 2), o < c.length && c[o][1].type === "content"))
      for (; ++o < c.length && c[o][1].type !== "content"; )
        c[o][1].type === "chunkText" && (c[o][1]._isInFirstContentOfListItem = !0, o++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, QN(e, n)), n = t[n], l = !0);
    else if (r[1]._container) {
      for (o = n, i = void 0; o-- && (a = e[o], a[1].type === "lineEnding" || a[1].type === "lineEndingBlank"); )
        a[0] === "enter" && (i && (e[i][1].type = "lineEndingBlank"), a[1].type = "lineEnding", i = o);
      i && (r[1].end = Object.assign({}, e[i][1].start), s = e.slice(i, n), s.unshift(r), sr(e, i, n - i + 1, s));
    }
  }
  return !l;
}
function QN(e, t) {
  const n = e[t][1], r = e[t][2];
  let i = t - 1;
  const o = [], a = n._tokenizer || r.parser[n.contentType](n.start), s = a.events, c = [], l = {};
  let u, d, p = -1, f = n, h = 0, m = 0;
  const y = [m];
  for (; f; ) {
    for (; e[++i][1] !== f; )
      ;
    o.push(i), f._tokenizer || (u = r.sliceStream(f), f.next || u.push(null), d && a.defineSkip(f.start), f._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0), a.write(u), f._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)), d = f, f = f.next;
  }
  for (f = n; ++p < s.length; )
    // Find a void token that includes a break.
    s[p][0] === "exit" && s[p - 1][0] === "enter" && s[p][1].type === s[p - 1][1].type && s[p][1].start.line !== s[p][1].end.line && (m = p + 1, y.push(m), f._tokenizer = void 0, f.previous = void 0, f = f.next);
  for (a.events = [], f ? (f._tokenizer = void 0, f.previous = void 0) : y.pop(), p = y.length; p--; ) {
    const g = s.slice(y[p], y[p + 1]), v = o.pop();
    c.unshift([v, v + g.length - 1]), sr(e, v, 2, g);
  }
  for (p = -1; ++p < c.length; )
    l[h + c[p][0]] = h + c[p][1], h += c[p][1] - c[p][0] - 1;
  return l;
}
const ej = {
  tokenize: rj,
  resolve: nj
}, tj = {
  tokenize: ij,
  partial: !0
};
function nj(e) {
  return J1(e), e;
}
function rj(e, t) {
  let n;
  return r;
  function r(s) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(s);
  }
  function i(s) {
    return s === null ? o(s) : Ye(s) ? e.check(
      tj,
      a,
      o
    )(s) : (e.consume(s), i);
  }
  function o(s) {
    return e.exit("chunkContent"), e.exit("content"), t(s);
  }
  function a(s) {
    return e.consume(s), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function ij(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), Tt(e, o, "linePrefix");
  }
  function o(a) {
    if (a === null || Ye(a))
      return n(a);
    const s = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : e.interrupt(r.parser.constructs.flow, n, t)(a);
  }
}
function Y1(e, t, n, r, i, o, a, s, c) {
  const l = c || Number.POSITIVE_INFINITY;
  let u = 0;
  return d;
  function d(g) {
    return g === 60 ? (e.enter(r), e.enter(i), e.enter(o), e.consume(g), e.exit(o), p) : g === null || g === 32 || g === 41 || cu(g) ? n(g) : (e.enter(r), e.enter(a), e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), m(g));
  }
  function p(g) {
    return g === 62 ? (e.enter(o), e.consume(g), e.exit(o), e.exit(i), e.exit(r), t) : (e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), f(g));
  }
  function f(g) {
    return g === 62 ? (e.exit("chunkString"), e.exit(s), p(g)) : g === null || g === 60 || Ye(g) ? n(g) : (e.consume(g), g === 92 ? h : f);
  }
  function h(g) {
    return g === 60 || g === 62 || g === 92 ? (e.consume(g), f) : f(g);
  }
  function m(g) {
    return !u && (g === null || g === 41 || Mt(g)) ? (e.exit("chunkString"), e.exit(s), e.exit(a), e.exit(r), t(g)) : u < l && g === 40 ? (e.consume(g), u++, m) : g === 41 ? (e.consume(g), u--, m) : g === null || g === 32 || g === 40 || cu(g) ? n(g) : (e.consume(g), g === 92 ? y : m);
  }
  function y(g) {
    return g === 40 || g === 41 || g === 92 ? (e.consume(g), m) : m(g);
  }
}
function G1(e, t, n, r, i, o) {
  const a = this;
  let s = 0, c;
  return l;
  function l(f) {
    return e.enter(r), e.enter(i), e.consume(f), e.exit(i), e.enter(o), u;
  }
  function u(f) {
    return s > 999 || f === null || f === 91 || f === 93 && !c || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    f === 94 && !s && "_hiddenFootnoteSupport" in a.parser.constructs ? n(f) : f === 93 ? (e.exit(o), e.enter(i), e.consume(f), e.exit(i), e.exit(r), t) : Ye(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), u) : (e.enter("chunkString", {
      contentType: "string"
    }), d(f));
  }
  function d(f) {
    return f === null || f === 91 || f === 93 || Ye(f) || s++ > 999 ? (e.exit("chunkString"), u(f)) : (e.consume(f), c || (c = !vt(f)), f === 92 ? p : d);
  }
  function p(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), s++, d) : d(f);
  }
}
function X1(e, t, n, r, i, o) {
  let a;
  return s;
  function s(p) {
    return p === 34 || p === 39 || p === 40 ? (e.enter(r), e.enter(i), e.consume(p), e.exit(i), a = p === 40 ? 41 : p, c) : n(p);
  }
  function c(p) {
    return p === a ? (e.enter(i), e.consume(p), e.exit(i), e.exit(r), t) : (e.enter(o), l(p));
  }
  function l(p) {
    return p === a ? (e.exit(o), c(a)) : p === null ? n(p) : Ye(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), Tt(e, l, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), u(p));
  }
  function u(p) {
    return p === a || p === null || Ye(p) ? (e.exit("chunkString"), l(p)) : (e.consume(p), p === 92 ? d : u);
  }
  function d(p) {
    return p === a || p === 92 ? (e.consume(p), u) : u(p);
  }
}
function is(e, t) {
  let n;
  return r;
  function r(i) {
    return Ye(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : vt(i) ? Tt(
      e,
      r,
      n ? "linePrefix" : "lineSuffix"
    )(i) : t(i);
  }
}
const oj = {
  name: "definition",
  tokenize: sj
}, aj = {
  tokenize: cj,
  partial: !0
};
function sj(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(f) {
    return e.enter("definition"), a(f);
  }
  function a(f) {
    return G1.call(
      r,
      e,
      s,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(f);
  }
  function s(f) {
    return i = Tr(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), f === 58 ? (e.enter("definitionMarker"), e.consume(f), e.exit("definitionMarker"), c) : n(f);
  }
  function c(f) {
    return Mt(f) ? is(e, l)(f) : l(f);
  }
  function l(f) {
    return Y1(
      e,
      u,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(f);
  }
  function u(f) {
    return e.attempt(aj, d, d)(f);
  }
  function d(f) {
    return vt(f) ? Tt(e, p, "whitespace")(f) : p(f);
  }
  function p(f) {
    return f === null || Ye(f) ? (e.exit("definition"), r.parser.defined.push(i), t(f)) : n(f);
  }
}
function cj(e, t, n) {
  return r;
  function r(s) {
    return Mt(s) ? is(e, i)(s) : n(s);
  }
  function i(s) {
    return X1(
      e,
      o,
      n,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(s);
  }
  function o(s) {
    return vt(s) ? Tt(e, a, "whitespace")(s) : a(s);
  }
  function a(s) {
    return s === null || Ye(s) ? t(s) : n(s);
  }
}
const lj = {
  name: "hardBreakEscape",
  tokenize: uj
};
function uj(e, t, n) {
  return r;
  function r(o) {
    return e.enter("hardBreakEscape"), e.consume(o), i;
  }
  function i(o) {
    return Ye(o) ? (e.exit("hardBreakEscape"), t(o)) : n(o);
  }
}
const dj = {
  name: "headingAtx",
  tokenize: pj,
  resolve: fj
};
function fj(e, t) {
  let n = e.length - 2, r = 3, i, o;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, o = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, sr(e, r, n - r + 1, [
    ["enter", i, t],
    ["enter", o, t],
    ["exit", o, t],
    ["exit", i, t]
  ])), e;
}
function pj(e, t, n) {
  let r = 0;
  return i;
  function i(u) {
    return e.enter("atxHeading"), o(u);
  }
  function o(u) {
    return e.enter("atxHeadingSequence"), a(u);
  }
  function a(u) {
    return u === 35 && r++ < 6 ? (e.consume(u), a) : u === null || Mt(u) ? (e.exit("atxHeadingSequence"), s(u)) : n(u);
  }
  function s(u) {
    return u === 35 ? (e.enter("atxHeadingSequence"), c(u)) : u === null || Ye(u) ? (e.exit("atxHeading"), t(u)) : vt(u) ? Tt(e, s, "whitespace")(u) : (e.enter("atxHeadingText"), l(u));
  }
  function c(u) {
    return u === 35 ? (e.consume(u), c) : (e.exit("atxHeadingSequence"), s(u));
  }
  function l(u) {
    return u === null || u === 35 || Mt(u) ? (e.exit("atxHeadingText"), s(u)) : (e.consume(u), l);
  }
}
const hj = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], fg = ["pre", "script", "style", "textarea"], mj = {
  name: "htmlFlow",
  tokenize: bj,
  resolveTo: vj,
  concrete: !0
}, yj = {
  tokenize: xj,
  partial: !0
}, gj = {
  tokenize: wj,
  partial: !0
};
function vj(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function bj(e, t, n) {
  const r = this;
  let i, o, a, s, c;
  return l;
  function l(T) {
    return u(T);
  }
  function u(T) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(T), d;
  }
  function d(T) {
    return T === 33 ? (e.consume(T), p) : T === 47 ? (e.consume(T), o = !0, m) : T === 63 ? (e.consume(T), i = 3, r.interrupt ? t : E) : zn(T) ? (e.consume(T), a = String.fromCharCode(T), y) : n(T);
  }
  function p(T) {
    return T === 45 ? (e.consume(T), i = 2, f) : T === 91 ? (e.consume(T), i = 5, s = 0, h) : zn(T) ? (e.consume(T), i = 4, r.interrupt ? t : E) : n(T);
  }
  function f(T) {
    return T === 45 ? (e.consume(T), r.interrupt ? t : E) : n(T);
  }
  function h(T) {
    const be = "CDATA[";
    return T === be.charCodeAt(s++) ? (e.consume(T), s === be.length ? r.interrupt ? t : V : h) : n(T);
  }
  function m(T) {
    return zn(T) ? (e.consume(T), a = String.fromCharCode(T), y) : n(T);
  }
  function y(T) {
    if (T === null || T === 47 || T === 62 || Mt(T)) {
      const be = T === 47, ke = a.toLowerCase();
      return !be && !o && fg.includes(ke) ? (i = 1, r.interrupt ? t(T) : V(T)) : hj.includes(a.toLowerCase()) ? (i = 6, be ? (e.consume(T), g) : r.interrupt ? t(T) : V(T)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(T) : o ? v(T) : b(T));
    }
    return T === 45 || Dn(T) ? (e.consume(T), a += String.fromCharCode(T), y) : n(T);
  }
  function g(T) {
    return T === 62 ? (e.consume(T), r.interrupt ? t : V) : n(T);
  }
  function v(T) {
    return vt(T) ? (e.consume(T), v) : R(T);
  }
  function b(T) {
    return T === 47 ? (e.consume(T), R) : T === 58 || T === 95 || zn(T) ? (e.consume(T), _) : vt(T) ? (e.consume(T), b) : R(T);
  }
  function _(T) {
    return T === 45 || T === 46 || T === 58 || T === 95 || Dn(T) ? (e.consume(T), _) : S(T);
  }
  function S(T) {
    return T === 61 ? (e.consume(T), x) : vt(T) ? (e.consume(T), S) : b(T);
  }
  function x(T) {
    return T === null || T === 60 || T === 61 || T === 62 || T === 96 ? n(T) : T === 34 || T === 39 ? (e.consume(T), c = T, A) : vt(T) ? (e.consume(T), x) : I(T);
  }
  function A(T) {
    return T === c ? (e.consume(T), c = null, P) : T === null || Ye(T) ? n(T) : (e.consume(T), A);
  }
  function I(T) {
    return T === null || T === 34 || T === 39 || T === 47 || T === 60 || T === 61 || T === 62 || T === 96 || Mt(T) ? S(T) : (e.consume(T), I);
  }
  function P(T) {
    return T === 47 || T === 62 || vt(T) ? b(T) : n(T);
  }
  function R(T) {
    return T === 62 ? (e.consume(T), M) : n(T);
  }
  function M(T) {
    return T === null || Ye(T) ? V(T) : vt(T) ? (e.consume(T), M) : n(T);
  }
  function V(T) {
    return T === 45 && i === 2 ? (e.consume(T), j) : T === 60 && i === 1 ? (e.consume(T), z) : T === 62 && i === 4 ? (e.consume(T), ee) : T === 63 && i === 3 ? (e.consume(T), E) : T === 93 && i === 5 ? (e.consume(T), X) : Ye(T) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(
      yj,
      de,
      U
    )(T)) : T === null || Ye(T) ? (e.exit("htmlFlowData"), U(T)) : (e.consume(T), V);
  }
  function U(T) {
    return e.check(
      gj,
      L,
      de
    )(T);
  }
  function L(T) {
    return e.enter("lineEnding"), e.consume(T), e.exit("lineEnding"), $;
  }
  function $(T) {
    return T === null || Ye(T) ? U(T) : (e.enter("htmlFlowData"), V(T));
  }
  function j(T) {
    return T === 45 ? (e.consume(T), E) : V(T);
  }
  function z(T) {
    return T === 47 ? (e.consume(T), a = "", H) : V(T);
  }
  function H(T) {
    if (T === 62) {
      const be = a.toLowerCase();
      return fg.includes(be) ? (e.consume(T), ee) : V(T);
    }
    return zn(T) && a.length < 8 ? (e.consume(T), a += String.fromCharCode(T), H) : V(T);
  }
  function X(T) {
    return T === 93 ? (e.consume(T), E) : V(T);
  }
  function E(T) {
    return T === 62 ? (e.consume(T), ee) : T === 45 && i === 2 ? (e.consume(T), E) : V(T);
  }
  function ee(T) {
    return T === null || Ye(T) ? (e.exit("htmlFlowData"), de(T)) : (e.consume(T), ee);
  }
  function de(T) {
    return e.exit("htmlFlow"), t(T);
  }
}
function wj(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return Ye(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o) : n(a);
  }
  function o(a) {
    return r.parser.lazy[r.now().line] ? n(a) : t(a);
  }
}
function xj(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(ec, t, n);
  }
}
const _j = {
  name: "htmlText",
  tokenize: Sj
};
function Sj(e, t, n) {
  const r = this;
  let i, o, a;
  return s;
  function s(E) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(E), c;
  }
  function c(E) {
    return E === 33 ? (e.consume(E), l) : E === 47 ? (e.consume(E), S) : E === 63 ? (e.consume(E), b) : zn(E) ? (e.consume(E), I) : n(E);
  }
  function l(E) {
    return E === 45 ? (e.consume(E), u) : E === 91 ? (e.consume(E), o = 0, h) : zn(E) ? (e.consume(E), v) : n(E);
  }
  function u(E) {
    return E === 45 ? (e.consume(E), f) : n(E);
  }
  function d(E) {
    return E === null ? n(E) : E === 45 ? (e.consume(E), p) : Ye(E) ? (a = d, z(E)) : (e.consume(E), d);
  }
  function p(E) {
    return E === 45 ? (e.consume(E), f) : d(E);
  }
  function f(E) {
    return E === 62 ? j(E) : E === 45 ? p(E) : d(E);
  }
  function h(E) {
    const ee = "CDATA[";
    return E === ee.charCodeAt(o++) ? (e.consume(E), o === ee.length ? m : h) : n(E);
  }
  function m(E) {
    return E === null ? n(E) : E === 93 ? (e.consume(E), y) : Ye(E) ? (a = m, z(E)) : (e.consume(E), m);
  }
  function y(E) {
    return E === 93 ? (e.consume(E), g) : m(E);
  }
  function g(E) {
    return E === 62 ? j(E) : E === 93 ? (e.consume(E), g) : m(E);
  }
  function v(E) {
    return E === null || E === 62 ? j(E) : Ye(E) ? (a = v, z(E)) : (e.consume(E), v);
  }
  function b(E) {
    return E === null ? n(E) : E === 63 ? (e.consume(E), _) : Ye(E) ? (a = b, z(E)) : (e.consume(E), b);
  }
  function _(E) {
    return E === 62 ? j(E) : b(E);
  }
  function S(E) {
    return zn(E) ? (e.consume(E), x) : n(E);
  }
  function x(E) {
    return E === 45 || Dn(E) ? (e.consume(E), x) : A(E);
  }
  function A(E) {
    return Ye(E) ? (a = A, z(E)) : vt(E) ? (e.consume(E), A) : j(E);
  }
  function I(E) {
    return E === 45 || Dn(E) ? (e.consume(E), I) : E === 47 || E === 62 || Mt(E) ? P(E) : n(E);
  }
  function P(E) {
    return E === 47 ? (e.consume(E), j) : E === 58 || E === 95 || zn(E) ? (e.consume(E), R) : Ye(E) ? (a = P, z(E)) : vt(E) ? (e.consume(E), P) : j(E);
  }
  function R(E) {
    return E === 45 || E === 46 || E === 58 || E === 95 || Dn(E) ? (e.consume(E), R) : M(E);
  }
  function M(E) {
    return E === 61 ? (e.consume(E), V) : Ye(E) ? (a = M, z(E)) : vt(E) ? (e.consume(E), M) : P(E);
  }
  function V(E) {
    return E === null || E === 60 || E === 61 || E === 62 || E === 96 ? n(E) : E === 34 || E === 39 ? (e.consume(E), i = E, U) : Ye(E) ? (a = V, z(E)) : vt(E) ? (e.consume(E), V) : (e.consume(E), L);
  }
  function U(E) {
    return E === i ? (e.consume(E), i = void 0, $) : E === null ? n(E) : Ye(E) ? (a = U, z(E)) : (e.consume(E), U);
  }
  function L(E) {
    return E === null || E === 34 || E === 39 || E === 60 || E === 61 || E === 96 ? n(E) : E === 47 || E === 62 || Mt(E) ? P(E) : (e.consume(E), L);
  }
  function $(E) {
    return E === 47 || E === 62 || Mt(E) ? P(E) : n(E);
  }
  function j(E) {
    return E === 62 ? (e.consume(E), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(E);
  }
  function z(E) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(E), e.exit("lineEnding"), H;
  }
  function H(E) {
    return vt(E) ? Tt(
      e,
      X,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(E) : X(E);
  }
  function X(E) {
    return e.enter("htmlTextData"), a(E);
  }
}
const Sm = {
  name: "labelEnd",
  tokenize: Aj,
  resolveTo: Rj,
  resolveAll: Tj
}, kj = {
  tokenize: Oj
}, Ej = {
  tokenize: Ij
}, Cj = {
  tokenize: Pj
};
function Tj(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t++);
  }
  return e;
}
function Rj(e, t) {
  let n = e.length, r = 0, i, o, a, s;
  for (; n--; )
    if (i = e[n][1], o) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (a) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (o = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else
      i.type === "labelEnd" && (a = n);
  const c = {
    type: e[o][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[o][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, l = {
    type: "label",
    start: Object.assign({}, e[o][1].start),
    end: Object.assign({}, e[a][1].end)
  }, u = {
    type: "labelText",
    start: Object.assign({}, e[o + r + 2][1].end),
    end: Object.assign({}, e[a - 2][1].start)
  };
  return s = [
    ["enter", c, t],
    ["enter", l, t]
  ], s = hr(s, e.slice(o + 1, o + r + 3)), s = hr(s, [["enter", u, t]]), s = hr(
    s,
    vd(
      t.parser.constructs.insideSpan.null,
      e.slice(o + r + 4, a - 3),
      t
    )
  ), s = hr(s, [
    ["exit", u, t],
    e[a - 2],
    e[a - 1],
    ["exit", l, t]
  ]), s = hr(s, e.slice(a + 1)), s = hr(s, [["exit", c, t]]), sr(e, o, e.length, s), e;
}
function Aj(e, t, n) {
  const r = this;
  let i = r.events.length, o, a;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      o = r.events[i][1];
      break;
    }
  return s;
  function s(p) {
    return o ? o._inactive ? d(p) : (a = r.parser.defined.includes(
      Tr(
        r.sliceSerialize({
          start: o.end,
          end: r.now()
        })
      )
    ), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(p), e.exit("labelMarker"), e.exit("labelEnd"), c) : n(p);
  }
  function c(p) {
    return p === 40 ? e.attempt(
      kj,
      u,
      a ? u : d
    )(p) : p === 91 ? e.attempt(
      Ej,
      u,
      a ? l : d
    )(p) : a ? u(p) : d(p);
  }
  function l(p) {
    return e.attempt(
      Cj,
      u,
      d
    )(p);
  }
  function u(p) {
    return t(p);
  }
  function d(p) {
    return o._balanced = !0, n(p);
  }
}
function Oj(e, t, n) {
  return r;
  function r(d) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), i;
  }
  function i(d) {
    return Mt(d) ? is(e, o)(d) : o(d);
  }
  function o(d) {
    return d === 41 ? u(d) : Y1(
      e,
      a,
      s,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(d);
  }
  function a(d) {
    return Mt(d) ? is(e, c)(d) : u(d);
  }
  function s(d) {
    return n(d);
  }
  function c(d) {
    return d === 34 || d === 39 || d === 40 ? X1(
      e,
      l,
      n,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(d) : u(d);
  }
  function l(d) {
    return Mt(d) ? is(e, u)(d) : u(d);
  }
  function u(d) {
    return d === 41 ? (e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), e.exit("resource"), t) : n(d);
  }
}
function Ij(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return G1.call(
      r,
      e,
      o,
      a,
      "reference",
      "referenceMarker",
      "referenceString"
    )(s);
  }
  function o(s) {
    return r.parser.defined.includes(
      Tr(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? t(s) : n(s);
  }
  function a(s) {
    return n(s);
  }
}
function Pj(e, t, n) {
  return r;
  function r(o) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), i;
  }
  function i(o) {
    return o === 93 ? (e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), e.exit("reference"), t) : n(o);
  }
}
const $j = {
  name: "labelStartImage",
  tokenize: Dj,
  resolveAll: Sm.resolveAll
};
function Dj(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(s), e.exit("labelImageMarker"), o;
  }
  function o(s) {
    return s === 91 ? (e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelImage"), a) : n(s);
  }
  function a(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const Nj = {
  name: "labelStartLink",
  tokenize: jj,
  resolveAll: Sm.resolveAll
};
function jj(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelLink"), o;
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : t(a);
  }
}
const uf = {
  name: "lineEnding",
  tokenize: Mj
};
function Mj(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Tt(e, t, "linePrefix");
  }
}
const Jc = {
  name: "thematicBreak",
  tokenize: qj
};
function qj(e, t, n) {
  let r = 0, i;
  return o;
  function o(l) {
    return e.enter("thematicBreak"), a(l);
  }
  function a(l) {
    return i = l, s(l);
  }
  function s(l) {
    return l === i ? (e.enter("thematicBreakSequence"), c(l)) : r >= 3 && (l === null || Ye(l)) ? (e.exit("thematicBreak"), t(l)) : n(l);
  }
  function c(l) {
    return l === i ? (e.consume(l), r++, c) : (e.exit("thematicBreakSequence"), vt(l) ? Tt(e, s, "whitespace")(l) : s(l));
  }
}
const Yn = {
  name: "list",
  tokenize: Uj,
  continuation: {
    tokenize: Bj
  },
  exit: Zj
}, Lj = {
  tokenize: Vj,
  partial: !0
}, Fj = {
  tokenize: zj,
  partial: !0
};
function Uj(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, a = 0;
  return s;
  function s(f) {
    const h = r.containerState.type || (f === 42 || f === 43 || f === 45 ? "listUnordered" : "listOrdered");
    if (h === "listUnordered" ? !r.containerState.marker || f === r.containerState.marker : Ap(f)) {
      if (r.containerState.type || (r.containerState.type = h, e.enter(h, {
        _container: !0
      })), h === "listUnordered")
        return e.enter("listItemPrefix"), f === 42 || f === 45 ? e.check(Jc, n, l)(f) : l(f);
      if (!r.interrupt || f === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), c(f);
    }
    return n(f);
  }
  function c(f) {
    return Ap(f) && ++a < 10 ? (e.consume(f), c) : (!r.interrupt || a < 2) && (r.containerState.marker ? f === r.containerState.marker : f === 41 || f === 46) ? (e.exit("listItemValue"), l(f)) : n(f);
  }
  function l(f) {
    return e.enter("listItemMarker"), e.consume(f), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || f, e.check(
      ec,
      // Cant be empty when interrupting.
      r.interrupt ? n : u,
      e.attempt(
        Lj,
        p,
        d
      )
    );
  }
  function u(f) {
    return r.containerState.initialBlankLine = !0, o++, p(f);
  }
  function d(f) {
    return vt(f) ? (e.enter("listItemPrefixWhitespace"), e.consume(f), e.exit("listItemPrefixWhitespace"), p) : n(f);
  }
  function p(f) {
    return r.containerState.size = o + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(f);
  }
}
function Bj(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(ec, i, o);
  function i(s) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Tt(
      e,
      t,
      "listItemIndent",
      r.containerState.size + 1
    )(s);
  }
  function o(s) {
    return r.containerState.furtherBlankLines || !vt(s) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, a(s)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(Fj, t, a)(s));
  }
  function a(s) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, Tt(
      e,
      e.attempt(Yn, t, n),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(s);
  }
}
function zj(e, t, n) {
  const r = this;
  return Tt(
    e,
    i,
    "listItemIndent",
    r.containerState.size + 1
  );
  function i(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === r.containerState.size ? t(o) : n(o);
  }
}
function Zj(e) {
  e.exit(this.containerState.type);
}
function Vj(e, t, n) {
  const r = this;
  return Tt(
    e,
    i,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function i(o) {
    const a = r.events[r.events.length - 1];
    return !vt(o) && a && a[1].type === "listItemPrefixWhitespace" ? t(o) : n(o);
  }
}
const pg = {
  name: "setextUnderline",
  tokenize: Wj,
  resolveTo: Hj
};
function Hj(e, t) {
  let n = e.length, r, i, o;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !o && e[n][1].type === "definition" && (o = n);
  const a = {
    type: "setextHeading",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[i][1].type = "setextHeadingText", o ? (e.splice(i, 0, ["enter", a, t]), e.splice(o + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[o][1].end)) : e[r][1] = a, e.push(["exit", a, t]), e;
}
function Wj(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(l) {
    let u = r.events.length, d;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        d = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || d) ? (e.enter("setextHeadingLine"), i = l, a(l)) : n(l);
  }
  function a(l) {
    return e.enter("setextHeadingLineSequence"), s(l);
  }
  function s(l) {
    return l === i ? (e.consume(l), s) : (e.exit("setextHeadingLineSequence"), vt(l) ? Tt(e, c, "lineSuffix")(l) : c(l));
  }
  function c(l) {
    return l === null || Ye(l) ? (e.exit("setextHeadingLine"), t(l)) : n(l);
  }
}
const Kj = {
  tokenize: Jj
};
function Jj(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    ec,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      i,
      Tt(
        e,
        e.attempt(
          this.parser.constructs.flow,
          i,
          e.attempt(ej, i)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(o), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const Yj = {
  resolveAll: eS()
}, Gj = Q1("string"), Xj = Q1("text");
function Q1(e) {
  return {
    tokenize: t,
    resolveAll: eS(
      e === "text" ? Qj : void 0
    )
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], o = n.attempt(i, a, s);
    return a;
    function a(u) {
      return l(u) ? o(u) : s(u);
    }
    function s(u) {
      if (u === null) {
        n.consume(u);
        return;
      }
      return n.enter("data"), n.consume(u), c;
    }
    function c(u) {
      return l(u) ? (n.exit("data"), o(u)) : (n.consume(u), c);
    }
    function l(u) {
      if (u === null)
        return !0;
      const d = i[u];
      let p = -1;
      if (d)
        for (; ++p < d.length; ) {
          const f = d[p];
          if (!f.previous || f.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function eS(e) {
  return t;
  function t(n, r) {
    let i = -1, o;
    for (; ++i <= n.length; )
      o === void 0 ? n[i] && n[i][1].type === "data" && (o = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== o + 2 && (n[o][1].end = n[i - 1][1].end, n.splice(o + 2, i - o - 2), i = o + 2), o = void 0);
    return e ? e(n, r) : n;
  }
}
function Qj(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let o = i.length, a = -1, s = 0, c;
      for (; o--; ) {
        const l = i[o];
        if (typeof l == "string") {
          for (a = l.length; l.charCodeAt(a - 1) === 32; )
            s++, a--;
          if (a)
            break;
          a = -1;
        } else if (l === -2)
          c = !0, s++;
        else if (l !== -1) {
          o++;
          break;
        }
      }
      if (s) {
        const l = {
          type: n === e.length || c || s < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - s,
            offset: r.end.offset - s,
            _index: r.start._index + o,
            _bufferIndex: o ? a : r.start._bufferIndex + a
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, l.start), r.start.offset === r.end.offset ? Object.assign(r, l) : (e.splice(
          n,
          0,
          ["enter", l, t],
          ["exit", l, t]
        ), n += 2);
      }
      n++;
    }
  return e;
}
function eM(e, t, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, o = [];
  let a = [], s = [];
  const c = {
    consume: v,
    enter: b,
    exit: _,
    attempt: A(S),
    check: A(x),
    interrupt: A(x, {
      interrupt: !0
    })
  }, l = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: f,
    sliceSerialize: p,
    now: h,
    defineSkip: m,
    write: d
  };
  let u = t.tokenize.call(l, c);
  return t.resolveAll && o.push(t), l;
  function d(M) {
    return a = hr(a, M), y(), a[a.length - 1] !== null ? [] : (I(t, 0), l.events = vd(o, l.events, l), l.events);
  }
  function p(M, V) {
    return nM(f(M), V);
  }
  function f(M) {
    return tM(a, M);
  }
  function h() {
    const { line: M, column: V, offset: U, _index: L, _bufferIndex: $ } = r;
    return {
      line: M,
      column: V,
      offset: U,
      _index: L,
      _bufferIndex: $
    };
  }
  function m(M) {
    i[M.line] = M.column, R();
  }
  function y() {
    let M;
    for (; r._index < a.length; ) {
      const V = a[r._index];
      if (typeof V == "string")
        for (M = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === M && r._bufferIndex < V.length; )
          g(V.charCodeAt(r._bufferIndex));
      else
        g(V);
    }
  }
  function g(M) {
    u = u(M);
  }
  function v(M) {
    Ye(M) ? (r.line++, r.column = 1, r.offset += M === -3 ? 2 : 1, R()) : M !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === a[r._index].length && (r._bufferIndex = -1, r._index++)), l.previous = M;
  }
  function b(M, V) {
    const U = V || {};
    return U.type = M, U.start = h(), l.events.push(["enter", U, l]), s.push(U), U;
  }
  function _(M) {
    const V = s.pop();
    return V.end = h(), l.events.push(["exit", V, l]), V;
  }
  function S(M, V) {
    I(M, V.from);
  }
  function x(M, V) {
    V.restore();
  }
  function A(M, V) {
    return U;
    function U(L, $, j) {
      let z, H, X, E;
      return Array.isArray(L) ? de(L) : "tokenize" in L ? (
        // @ts-expect-error Looks like a construct.
        de([L])
      ) : ee(L);
      function ee(Se) {
        return Pe;
        function Pe(Be) {
          const Ae = Be !== null && Se[Be], pe = Be !== null && Se.null, ue = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Ae) ? Ae : Ae ? [Ae] : [],
            ...Array.isArray(pe) ? pe : pe ? [pe] : []
          ];
          return de(ue)(Be);
        }
      }
      function de(Se) {
        return z = Se, H = 0, Se.length === 0 ? j : T(Se[H]);
      }
      function T(Se) {
        return Pe;
        function Pe(Be) {
          return E = P(), X = Se, Se.partial || (l.currentConstruct = Se), Se.name && l.parser.constructs.disable.null.includes(Se.name) ? ke() : Se.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            V ? Object.assign(Object.create(l), V) : l,
            c,
            be,
            ke
          )(Be);
        }
      }
      function be(Se) {
        return M(X, E), $;
      }
      function ke(Se) {
        return E.restore(), ++H < z.length ? T(z[H]) : j;
      }
    }
  }
  function I(M, V) {
    M.resolveAll && !o.includes(M) && o.push(M), M.resolve && sr(
      l.events,
      V,
      l.events.length - V,
      M.resolve(l.events.slice(V), l)
    ), M.resolveTo && (l.events = M.resolveTo(l.events, l));
  }
  function P() {
    const M = h(), V = l.previous, U = l.currentConstruct, L = l.events.length, $ = Array.from(s);
    return {
      restore: j,
      from: L
    };
    function j() {
      r = M, l.previous = V, l.currentConstruct = U, l.events.length = L, s = $, R();
    }
  }
  function R() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function tM(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, o = t.end._bufferIndex;
  let a;
  if (n === i)
    a = [e[n].slice(r, o)];
  else {
    if (a = e.slice(n, i), r > -1) {
      const s = a[0];
      typeof s == "string" ? a[0] = s.slice(r) : a.shift();
    }
    o > 0 && a.push(e[i].slice(0, o));
  }
  return a;
}
function nM(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const o = e[n];
    let a;
    if (typeof o == "string")
      a = o;
    else
      switch (o) {
        case -5: {
          a = "\r";
          break;
        }
        case -4: {
          a = `
`;
          break;
        }
        case -3: {
          a = `\r
`;
          break;
        }
        case -2: {
          a = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && i)
            continue;
          a = " ";
          break;
        }
        default:
          a = String.fromCharCode(o);
      }
    i = o === -2, r.push(a);
  }
  return r.join("");
}
const rM = {
  42: Yn,
  43: Yn,
  45: Yn,
  48: Yn,
  49: Yn,
  50: Yn,
  51: Yn,
  52: Yn,
  53: Yn,
  54: Yn,
  55: Yn,
  56: Yn,
  57: Yn,
  62: H1
}, iM = {
  91: oj
}, oM = {
  [-2]: lf,
  [-1]: lf,
  32: lf
}, aM = {
  35: dj,
  42: Jc,
  45: [pg, Jc],
  60: mj,
  61: pg,
  95: Jc,
  96: dg,
  126: dg
}, sM = {
  38: K1,
  92: W1
}, cM = {
  [-5]: uf,
  [-4]: uf,
  [-3]: uf,
  33: $j,
  38: K1,
  42: Op,
  60: [jN, _j],
  91: Nj,
  92: [lj, W1],
  93: Sm,
  95: Op,
  96: JN
}, lM = {
  null: [Op, Yj]
}, uM = {
  null: [42, 95]
}, dM = {
  null: []
}, fM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: uM,
  contentInitial: iM,
  disable: dM,
  document: rM,
  flow: aM,
  flowInitial: oM,
  insideSpan: lM,
  string: sM,
  text: cM
}, Symbol.toStringTag, { value: "Module" }));
function pM(e) {
  const n = (
    /** @type {FullNormalizedExtension} */
    Z1([fM, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n,
    content: i(AN),
    document: i(IN),
    flow: i(Kj),
    string: i(Gj),
    text: i(Xj)
  };
  return r;
  function i(o) {
    return a;
    function a(s) {
      return eM(r, o, s);
    }
  }
}
function hM(e) {
  for (; !J1(e); )
    ;
  return e;
}
const hg = /[\0\t\n\r]/g;
function mM() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(o, a, s) {
    const c = [];
    let l, u, d, p, f;
    for (o = t + (typeof o == "string" ? o.toString() : new TextDecoder(a || void 0).decode(o)), d = 0, t = "", n && (o.charCodeAt(0) === 65279 && d++, n = void 0); d < o.length; ) {
      if (hg.lastIndex = d, l = hg.exec(o), p = l && l.index !== void 0 ? l.index : o.length, f = o.charCodeAt(p), !l) {
        t = o.slice(d);
        break;
      }
      if (f === 10 && d === p && r)
        c.push(-3), r = void 0;
      else
        switch (r && (c.push(-5), r = void 0), d < p && (c.push(o.slice(d, p)), e += p - d), f) {
          case 0: {
            c.push(65533), e++;
            break;
          }
          case 9: {
            for (u = Math.ceil(e / 4) * 4, c.push(-2); e++ < u; )
              c.push(-1);
            break;
          }
          case 10: {
            c.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      d = p + 1;
    }
    return s && (r && c.push(-5), t && c.push(t), c.push(null)), c;
  }
}
const yM = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function gM(e) {
  return e.replace(yM, vM);
}
function vM(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), o = i === 120 || i === 88;
    return V1(n.slice(o ? 2 : 1), o ? 16 : 10);
  }
  return _m(n) || e;
}
const tS = {}.hasOwnProperty;
function bM(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), wM(n)(
    hM(
      pM(n).document().write(mM()(e, t, !0))
    )
  );
}
function wM(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: o(se),
      autolinkProtocol: P,
      autolinkEmail: P,
      atxHeading: o($e),
      blockQuote: o(Ae),
      characterEscape: P,
      characterReference: P,
      codeFenced: o(pe),
      codeFencedFenceInfo: a,
      codeFencedFenceMeta: a,
      codeIndented: o(pe, a),
      codeText: o(ue, a),
      codeTextData: P,
      data: P,
      codeFlowValue: P,
      definition: o(xe),
      definitionDestinationString: a,
      definitionLabelString: a,
      definitionTitleString: a,
      emphasis: o(fe),
      hardBreakEscape: o(nt),
      hardBreakTrailing: o(nt),
      htmlFlow: o(q, a),
      htmlFlowData: P,
      htmlText: o(q, a),
      htmlTextData: P,
      image: o(ie),
      label: a,
      link: o(se),
      listItem: o(De),
      listItemValue: p,
      listOrdered: o(le, d),
      listUnordered: o(le),
      paragraph: o(_e),
      reference: T,
      referenceString: a,
      resourceDestinationString: a,
      resourceTitleString: a,
      setextHeading: o($e),
      strong: o(Ze),
      thematicBreak: o(et)
    },
    exit: {
      atxHeading: c(),
      atxHeadingSequence: S,
      autolink: c(),
      autolinkEmail: Be,
      autolinkProtocol: Pe,
      blockQuote: c(),
      characterEscapeValue: R,
      characterReferenceMarkerHexadecimal: ke,
      characterReferenceMarkerNumeric: ke,
      characterReferenceValue: Se,
      codeFenced: c(y),
      codeFencedFence: m,
      codeFencedFenceInfo: f,
      codeFencedFenceMeta: h,
      codeFlowValue: R,
      codeIndented: c(g),
      codeText: c($),
      codeTextData: R,
      data: R,
      definition: c(),
      definitionDestinationString: _,
      definitionLabelString: v,
      definitionTitleString: b,
      emphasis: c(),
      hardBreakEscape: c(V),
      hardBreakTrailing: c(V),
      htmlFlow: c(U),
      htmlFlowData: R,
      htmlText: c(L),
      htmlTextData: R,
      image: c(z),
      label: X,
      labelText: H,
      lineEnding: M,
      link: c(j),
      listItem: c(),
      listOrdered: c(),
      listUnordered: c(),
      paragraph: c(),
      referenceString: be,
      resourceDestinationString: E,
      resourceTitleString: ee,
      resource: de,
      setextHeading: c(I),
      setextHeadingLineSequence: A,
      setextHeadingText: x,
      strong: c(),
      thematicBreak: c()
    }
  };
  nS(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(W) {
    let re = {
      type: "root",
      children: []
    };
    const ae = {
      stack: [re],
      tokenStack: [],
      config: t,
      enter: s,
      exit: l,
      buffer: a,
      resume: u,
      data: n
    }, Te = [];
    let Xe = -1;
    for (; ++Xe < W.length; )
      if (W[Xe][1].type === "listOrdered" || W[Xe][1].type === "listUnordered")
        if (W[Xe][0] === "enter")
          Te.push(Xe);
        else {
          const Lt = Te.pop();
          Xe = i(W, Lt, Xe);
        }
    for (Xe = -1; ++Xe < W.length; ) {
      const Lt = t[W[Xe][0]];
      tS.call(Lt, W[Xe][1].type) && Lt[W[Xe][1].type].call(
        Object.assign(
          {
            sliceSerialize: W[Xe][2].sliceSerialize
          },
          ae
        ),
        W[Xe][1]
      );
    }
    if (ae.tokenStack.length > 0) {
      const Lt = ae.tokenStack[ae.tokenStack.length - 1];
      (Lt[1] || mg).call(ae, void 0, Lt[0]);
    }
    for (re.position = {
      start: _i(
        W.length > 0 ? W[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: _i(
        W.length > 0 ? W[W.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, Xe = -1; ++Xe < t.transforms.length; )
      re = t.transforms[Xe](re) || re;
    return re;
  }
  function i(W, re, ae) {
    let Te = re - 1, Xe = -1, Lt = !1, Pt, Ct, jt, Qt;
    for (; ++Te <= ae; ) {
      const B = W[Te];
      switch (B[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          B[0] === "enter" ? Xe++ : Xe--, Qt = void 0;
          break;
        }
        case "lineEndingBlank": {
          B[0] === "enter" && (Pt && !Qt && !Xe && !jt && (jt = Te), Qt = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Qt = void 0;
      }
      if (!Xe && B[0] === "enter" && B[1].type === "listItemPrefix" || Xe === -1 && B[0] === "exit" && (B[1].type === "listUnordered" || B[1].type === "listOrdered")) {
        if (Pt) {
          let K = Te;
          for (Ct = void 0; K--; ) {
            const tt = W[K];
            if (tt[1].type === "lineEnding" || tt[1].type === "lineEndingBlank") {
              if (tt[0] === "exit")
                continue;
              Ct && (W[Ct][1].type = "lineEndingBlank", Lt = !0), tt[1].type = "lineEnding", Ct = K;
            } else if (!(tt[1].type === "linePrefix" || tt[1].type === "blockQuotePrefix" || tt[1].type === "blockQuotePrefixWhitespace" || tt[1].type === "blockQuoteMarker" || tt[1].type === "listItemIndent"))
              break;
          }
          jt && (!Ct || jt < Ct) && (Pt._spread = !0), Pt.end = Object.assign(
            {},
            Ct ? W[Ct][1].start : B[1].end
          ), W.splice(Ct || Te, 0, ["exit", Pt, B[2]]), Te++, ae++;
        }
        if (B[1].type === "listItemPrefix") {
          const K = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, B[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          Pt = K, W.splice(Te, 0, ["enter", K, B[2]]), Te++, ae++, jt = void 0, Qt = !0;
        }
      }
    }
    return W[re][1]._spread = Lt, ae;
  }
  function o(W, re) {
    return ae;
    function ae(Te) {
      s.call(this, W(Te), Te), re && re.call(this, Te);
    }
  }
  function a() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function s(W, re, ae) {
    this.stack[this.stack.length - 1].children.push(W), this.stack.push(W), this.tokenStack.push([re, ae]), W.position = {
      start: _i(re.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function c(W) {
    return re;
    function re(ae) {
      W && W.call(this, ae), l.call(this, ae);
    }
  }
  function l(W, re) {
    const ae = this.stack.pop(), Te = this.tokenStack.pop();
    if (Te)
      Te[0].type !== W.type && (re ? re.call(this, W, Te[0]) : (Te[1] || mg).call(this, W, Te[0]));
    else
      throw new Error(
        "Cannot close `" + W.type + "` (" + rs({
          start: W.start,
          end: W.end
        }) + "): its not open"
      );
    ae.position.end = _i(W.end);
  }
  function u() {
    return xm(this.stack.pop());
  }
  function d() {
    this.data.expectingFirstListItemValue = !0;
  }
  function p(W) {
    if (this.data.expectingFirstListItemValue) {
      const re = this.stack[this.stack.length - 2];
      re.start = Number.parseInt(this.sliceSerialize(W), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function f() {
    const W = this.resume(), re = this.stack[this.stack.length - 1];
    re.lang = W;
  }
  function h() {
    const W = this.resume(), re = this.stack[this.stack.length - 1];
    re.meta = W;
  }
  function m() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function y() {
    const W = this.resume(), re = this.stack[this.stack.length - 1];
    re.value = W.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function g() {
    const W = this.resume(), re = this.stack[this.stack.length - 1];
    re.value = W.replace(/(\r?\n|\r)$/g, "");
  }
  function v(W) {
    const re = this.resume(), ae = this.stack[this.stack.length - 1];
    ae.label = re, ae.identifier = Tr(
      this.sliceSerialize(W)
    ).toLowerCase();
  }
  function b() {
    const W = this.resume(), re = this.stack[this.stack.length - 1];
    re.title = W;
  }
  function _() {
    const W = this.resume(), re = this.stack[this.stack.length - 1];
    re.url = W;
  }
  function S(W) {
    const re = this.stack[this.stack.length - 1];
    if (!re.depth) {
      const ae = this.sliceSerialize(W).length;
      re.depth = ae;
    }
  }
  function x() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function A(W) {
    const re = this.stack[this.stack.length - 1];
    re.depth = this.sliceSerialize(W).codePointAt(0) === 61 ? 1 : 2;
  }
  function I() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function P(W) {
    const ae = this.stack[this.stack.length - 1].children;
    let Te = ae[ae.length - 1];
    (!Te || Te.type !== "text") && (Te = yt(), Te.position = {
      start: _i(W.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, ae.push(Te)), this.stack.push(Te);
  }
  function R(W) {
    const re = this.stack.pop();
    re.value += this.sliceSerialize(W), re.position.end = _i(W.end);
  }
  function M(W) {
    const re = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const ae = re.children[re.children.length - 1];
      ae.position.end = _i(W.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(re.type) && (P.call(this, W), R.call(this, W));
  }
  function V() {
    this.data.atHardBreak = !0;
  }
  function U() {
    const W = this.resume(), re = this.stack[this.stack.length - 1];
    re.value = W;
  }
  function L() {
    const W = this.resume(), re = this.stack[this.stack.length - 1];
    re.value = W;
  }
  function $() {
    const W = this.resume(), re = this.stack[this.stack.length - 1];
    re.value = W;
  }
  function j() {
    const W = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const re = this.data.referenceType || "shortcut";
      W.type += "Reference", W.referenceType = re, delete W.url, delete W.title;
    } else
      delete W.identifier, delete W.label;
    this.data.referenceType = void 0;
  }
  function z() {
    const W = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const re = this.data.referenceType || "shortcut";
      W.type += "Reference", W.referenceType = re, delete W.url, delete W.title;
    } else
      delete W.identifier, delete W.label;
    this.data.referenceType = void 0;
  }
  function H(W) {
    const re = this.sliceSerialize(W), ae = this.stack[this.stack.length - 2];
    ae.label = gM(re), ae.identifier = Tr(re).toLowerCase();
  }
  function X() {
    const W = this.stack[this.stack.length - 1], re = this.resume(), ae = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, ae.type === "link") {
      const Te = W.children;
      ae.children = Te;
    } else
      ae.alt = re;
  }
  function E() {
    const W = this.resume(), re = this.stack[this.stack.length - 1];
    re.url = W;
  }
  function ee() {
    const W = this.resume(), re = this.stack[this.stack.length - 1];
    re.title = W;
  }
  function de() {
    this.data.inReference = void 0;
  }
  function T() {
    this.data.referenceType = "collapsed";
  }
  function be(W) {
    const re = this.resume(), ae = this.stack[this.stack.length - 1];
    ae.label = re, ae.identifier = Tr(
      this.sliceSerialize(W)
    ).toLowerCase(), this.data.referenceType = "full";
  }
  function ke(W) {
    this.data.characterReferenceType = W.type;
  }
  function Se(W) {
    const re = this.sliceSerialize(W), ae = this.data.characterReferenceType;
    let Te;
    ae ? (Te = V1(
      re,
      ae === "characterReferenceMarkerNumeric" ? 10 : 16
    ), this.data.characterReferenceType = void 0) : Te = _m(re);
    const Xe = this.stack.pop();
    Xe.value += Te, Xe.position.end = _i(W.end);
  }
  function Pe(W) {
    R.call(this, W);
    const re = this.stack[this.stack.length - 1];
    re.url = this.sliceSerialize(W);
  }
  function Be(W) {
    R.call(this, W);
    const re = this.stack[this.stack.length - 1];
    re.url = "mailto:" + this.sliceSerialize(W);
  }
  function Ae() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function pe() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function ue() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function xe() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function fe() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function $e() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function nt() {
    return {
      type: "break"
    };
  }
  function q() {
    return {
      type: "html",
      value: ""
    };
  }
  function ie() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function se() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function le(W) {
    return {
      type: "list",
      ordered: W.type === "listOrdered",
      start: null,
      spread: W._spread,
      children: []
    };
  }
  function De(W) {
    return {
      type: "listItem",
      spread: W._spread,
      checked: null,
      children: []
    };
  }
  function _e() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Ze() {
    return {
      type: "strong",
      children: []
    };
  }
  function yt() {
    return {
      type: "text",
      value: ""
    };
  }
  function et() {
    return {
      type: "thematicBreak"
    };
  }
}
function _i(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function nS(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? nS(e, r) : xM(e, r);
  }
}
function xM(e, t) {
  let n;
  for (n in t)
    if (tS.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function mg(e, t) {
  throw e ? new Error(
    "Cannot close `" + e.type + "` (" + rs({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + t.type + "`, " + rs({
      start: t.start,
      end: t.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t.type + "`, " + rs({
      start: t.start,
      end: t.end
    }) + ") is still open"
  );
}
function _M(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return bM(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function SM(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function kM(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function EM(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i;
}
function CM(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function TM(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function RM(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = Na(r.toLowerCase()), o = e.footnoteOrder.indexOf(r);
  let a, s = e.footnoteCounts.get(r);
  s === void 0 ? (s = 0, e.footnoteOrder.push(r), a = e.footnoteOrder.length) : a = o + 1, s += 1, e.footnoteCounts.set(r, s);
  const c = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (s > 1 ? "-" + s : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(a) }]
  };
  e.patch(t, c);
  const l = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [c]
  };
  return e.patch(t, l), e.applyData(t, l);
}
function AM(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function OM(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function rS(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), o = i[0];
  o && o.type === "text" ? o.value = "[" + o.value : i.unshift({ type: "text", value: "[" });
  const a = i[i.length - 1];
  return a && a.type === "text" ? a.value += r : i.push({ type: "text", value: r }), i;
}
function IM(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return rS(e, t);
  const i = { src: Na(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const o = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, o), e.applyData(t, o);
}
function PM(e, t) {
  const n = { src: Na(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function $M(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function DM(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return rS(e, t);
  const i = { href: Na(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const o = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function NM(e, t) {
  const n = { href: Na(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function jM(e, t, n) {
  const r = e.all(t), i = n ? MM(n) : iS(t), o = {}, a = [];
  if (typeof t.checked == "boolean") {
    const u = r[0];
    let d;
    u && u.type === "element" && u.tagName === "p" ? d = u : (d = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(d)), d.children.length > 0 && d.children.unshift({ type: "text", value: " " }), d.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), o.className = ["task-list-item"];
  }
  let s = -1;
  for (; ++s < r.length; ) {
    const u = r[s];
    (i || s !== 0 || u.type !== "element" || u.tagName !== "p") && a.push({ type: "text", value: `
` }), u.type === "element" && u.tagName === "p" && !i ? a.push(...u.children) : a.push(u);
  }
  const c = r[r.length - 1];
  c && (i || c.type !== "element" || c.tagName !== "p") && a.push({ type: "text", value: `
` });
  const l = { type: "element", tagName: "li", properties: o, children: a };
  return e.patch(t, l), e.applyData(t, l);
}
function MM(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = iS(n[r]);
  }
  return t;
}
function iS(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function qM(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const a = r[i];
    if (a.type === "element" && a.tagName === "li" && a.properties && Array.isArray(a.properties.className) && a.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const o = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function LM(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function FM(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function UM(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function BM(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const a = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], a), i.push(a);
  }
  if (n.length > 0) {
    const a = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, s = gm(t.children[1]), c = M1(t.children[t.children.length - 1]);
    s && c && (a.position = { start: s, end: c }), i.push(a);
  }
  const o = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function zM(e, t, n) {
  const r = n ? n.children : void 0, o = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", a = n && n.type === "table" ? n.align : void 0, s = a ? a.length : t.children.length;
  let c = -1;
  const l = [];
  for (; ++c < s; ) {
    const d = t.children[c], p = {}, f = a ? a[c] : void 0;
    f && (p.align = f);
    let h = { type: "element", tagName: o, properties: p, children: [] };
    d && (h.children = e.all(d), e.patch(d, h), h = e.applyData(d, h)), l.push(h);
  }
  const u = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(l, !0)
  };
  return e.patch(t, u), e.applyData(t, u);
}
function ZM(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const yg = 9, gg = 32;
function VM(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const o = [];
  for (; r; )
    o.push(
      vg(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return o.push(vg(t.slice(i), i > 0, !1)), o.join("");
}
function vg(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let o = e.codePointAt(r);
    for (; o === yg || o === gg; )
      r++, o = e.codePointAt(r);
  }
  if (n) {
    let o = e.codePointAt(i - 1);
    for (; o === yg || o === gg; )
      i--, o = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function HM(e, t) {
  const n = { type: "text", value: VM(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function WM(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const KM = {
  blockquote: SM,
  break: kM,
  code: EM,
  delete: CM,
  emphasis: TM,
  footnoteReference: RM,
  heading: AM,
  html: OM,
  imageReference: IM,
  image: PM,
  inlineCode: $M,
  linkReference: DM,
  link: NM,
  listItem: jM,
  list: qM,
  paragraph: LM,
  // @ts-expect-error: root is different, but hard to type.
  root: FM,
  strong: UM,
  table: BM,
  tableCell: ZM,
  tableRow: zM,
  text: HM,
  thematicBreak: WM,
  toml: _c,
  yaml: _c,
  definition: _c,
  footnoteDefinition: _c
};
function _c() {
}
const oS = -1, bd = 0, uu = 1, du = 2, km = 3, Em = 4, Cm = 5, Tm = 6, aS = 7, sS = 8, bg = typeof self == "object" ? self : globalThis, JM = (e, t) => {
  const n = (i, o) => (e.set(o, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [o, a] = t[i];
    switch (o) {
      case bd:
      case oS:
        return n(a, i);
      case uu: {
        const s = n([], i);
        for (const c of a)
          s.push(r(c));
        return s;
      }
      case du: {
        const s = n({}, i);
        for (const [c, l] of a)
          s[r(c)] = r(l);
        return s;
      }
      case km:
        return n(new Date(a), i);
      case Em: {
        const { source: s, flags: c } = a;
        return n(new RegExp(s, c), i);
      }
      case Cm: {
        const s = n(/* @__PURE__ */ new Map(), i);
        for (const [c, l] of a)
          s.set(r(c), r(l));
        return s;
      }
      case Tm: {
        const s = n(/* @__PURE__ */ new Set(), i);
        for (const c of a)
          s.add(r(c));
        return s;
      }
      case aS: {
        const { name: s, message: c } = a;
        return n(new bg[s](c), i);
      }
      case sS:
        return n(BigInt(a), i);
      case "BigInt":
        return n(Object(BigInt(a)), i);
    }
    return n(new bg[o](a), i);
  };
  return r;
}, wg = (e) => JM(/* @__PURE__ */ new Map(), e)(0), jo = "", { toString: YM } = {}, { keys: GM } = Object, Va = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [bd, t];
  const n = YM.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [uu, jo];
    case "Object":
      return [du, jo];
    case "Date":
      return [km, jo];
    case "RegExp":
      return [Em, jo];
    case "Map":
      return [Cm, jo];
    case "Set":
      return [Tm, jo];
  }
  return n.includes("Array") ? [uu, n] : n.includes("Error") ? [aS, n] : [du, n];
}, Sc = ([e, t]) => e === bd && (t === "function" || t === "symbol"), XM = (e, t, n, r) => {
  const i = (a, s) => {
    const c = r.push(a) - 1;
    return n.set(s, c), c;
  }, o = (a) => {
    if (n.has(a))
      return n.get(a);
    let [s, c] = Va(a);
    switch (s) {
      case bd: {
        let u = a;
        switch (c) {
          case "bigint":
            s = sS, u = a.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + c);
            u = null;
            break;
          case "undefined":
            return i([oS], a);
        }
        return i([s, u], a);
      }
      case uu: {
        if (c)
          return i([c, [...a]], a);
        const u = [], d = i([s, u], a);
        for (const p of a)
          u.push(o(p));
        return d;
      }
      case du: {
        if (c)
          switch (c) {
            case "BigInt":
              return i([c, a.toString()], a);
            case "Boolean":
            case "Number":
            case "String":
              return i([c, a.valueOf()], a);
          }
        if (t && "toJSON" in a)
          return o(a.toJSON());
        const u = [], d = i([s, u], a);
        for (const p of GM(a))
          (e || !Sc(Va(a[p]))) && u.push([o(p), o(a[p])]);
        return d;
      }
      case km:
        return i([s, a.toISOString()], a);
      case Em: {
        const { source: u, flags: d } = a;
        return i([s, { source: u, flags: d }], a);
      }
      case Cm: {
        const u = [], d = i([s, u], a);
        for (const [p, f] of a)
          (e || !(Sc(Va(p)) || Sc(Va(f)))) && u.push([o(p), o(f)]);
        return d;
      }
      case Tm: {
        const u = [], d = i([s, u], a);
        for (const p of a)
          (e || !Sc(Va(p))) && u.push(o(p));
        return d;
      }
    }
    const { message: l } = a;
    return i([s, { name: c, message: l }], a);
  };
  return o;
}, xg = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return XM(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, fu = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? wg(xg(e, t)) : structuredClone(e)
) : (e, t) => wg(xg(e, t));
function QM(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function e2(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function t2(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || QM, r = e.options.footnoteBackLabel || e2, i = e.options.footnoteLabel || "Footnotes", o = e.options.footnoteLabelTagName || "h2", a = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, s = [];
  let c = -1;
  for (; ++c < e.footnoteOrder.length; ) {
    const l = e.footnoteById.get(e.footnoteOrder[c]);
    if (!l)
      continue;
    const u = e.all(l), d = String(l.identifier).toUpperCase(), p = Na(d.toLowerCase());
    let f = 0;
    const h = [], m = e.footnoteCounts.get(d);
    for (; m !== void 0 && ++f <= m; ) {
      h.length > 0 && h.push({ type: "text", value: " " });
      let v = typeof n == "string" ? n : n(c, f);
      typeof v == "string" && (v = { type: "text", value: v }), h.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + p + (f > 1 ? "-" + f : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(c, f),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(v) ? v : [v]
      });
    }
    const y = u[u.length - 1];
    if (y && y.type === "element" && y.tagName === "p") {
      const v = y.children[y.children.length - 1];
      v && v.type === "text" ? v.value += " " : y.children.push({ type: "text", value: " " }), y.children.push(...h);
    } else
      u.push(...h);
    const g = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + p },
      children: e.wrap(u, !0)
    };
    e.patch(l, g), s.push(g);
  }
  if (s.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: o,
          properties: {
            ...fu(a),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(s, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const wd = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return o2;
    if (typeof e == "function")
      return xd(e);
    if (typeof e == "object")
      return Array.isArray(e) ? n2(e) : r2(e);
    if (typeof e == "string")
      return i2(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function n2(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = wd(e[n]);
  return xd(r);
  function r(...i) {
    let o = -1;
    for (; ++o < t.length; )
      if (t[o].apply(this, i))
        return !0;
    return !1;
  }
}
function r2(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return xd(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let o;
    for (o in e)
      if (i[o] !== t[o])
        return !1;
    return !0;
  }
}
function i2(e) {
  return xd(t);
  function t(n) {
    return n && n.type === e;
  }
}
function xd(e) {
  return t;
  function t(n, r, i) {
    return !!(a2(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function o2() {
  return !0;
}
function a2(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const cS = [], s2 = !0, Ip = !1, c2 = "skip";
function lS(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const o = wd(i), a = r ? -1 : 1;
  s(e, void 0, [])();
  function s(c, l, u) {
    const d = (
      /** @type {Record<string, unknown>} */
      c && typeof c == "object" ? c : {}
    );
    if (typeof d.type == "string") {
      const f = (
        // `hast`
        typeof d.tagName == "string" ? d.tagName : (
          // `xast`
          typeof d.name == "string" ? d.name : void 0
        )
      );
      Object.defineProperty(p, "name", {
        value: "node (" + (c.type + (f ? "<" + f + ">" : "")) + ")"
      });
    }
    return p;
    function p() {
      let f = cS, h, m, y;
      if ((!t || o(c, l, u[u.length - 1] || void 0)) && (f = l2(n(c, u)), f[0] === Ip))
        return f;
      if ("children" in c && c.children) {
        const g = (
          /** @type {UnistParent} */
          c
        );
        if (g.children && f[0] !== c2)
          for (m = (r ? g.children.length : -1) + a, y = u.concat(g); m > -1 && m < g.children.length; ) {
            const v = g.children[m];
            if (h = s(v, m, y)(), h[0] === Ip)
              return h;
            m = typeof h[1] == "number" ? h[1] : m + a;
          }
      }
      return f;
    }
  }
}
function l2(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [s2, e] : e == null ? cS : [e];
}
function Rm(e, t, n, r) {
  let i, o, a;
  typeof t == "function" && typeof n != "function" ? (o = void 0, a = t, i = n) : (o = t, a = n, i = r), lS(e, o, s, i);
  function s(c, l) {
    const u = l[l.length - 1], d = u ? u.children.indexOf(c) : void 0;
    return a(c, d, u);
  }
}
const Pp = {}.hasOwnProperty, u2 = {};
function d2(e, t) {
  const n = t || u2, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), a = { ...KM, ...n.handlers }, s = {
    all: l,
    applyData: p2,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: o,
    footnoteOrder: [],
    handlers: a,
    one: c,
    options: n,
    patch: f2,
    wrap: m2
  };
  return Rm(e, function(u) {
    if (u.type === "definition" || u.type === "footnoteDefinition") {
      const d = u.type === "definition" ? r : i, p = String(u.identifier).toUpperCase();
      d.has(p) || d.set(p, u);
    }
  }), s;
  function c(u, d) {
    const p = u.type, f = s.handlers[p];
    if (Pp.call(s.handlers, p) && f)
      return f(s, u, d);
    if (s.options.passThrough && s.options.passThrough.includes(p)) {
      if ("children" in u) {
        const { children: m, ...y } = u, g = fu(y);
        return g.children = s.all(u), g;
      }
      return fu(u);
    }
    return (s.options.unknownHandler || h2)(s, u, d);
  }
  function l(u) {
    const d = [];
    if ("children" in u) {
      const p = u.children;
      let f = -1;
      for (; ++f < p.length; ) {
        const h = s.one(p[f], u);
        if (h) {
          if (f && p[f - 1].type === "break" && (!Array.isArray(h) && h.type === "text" && (h.value = _g(h.value)), !Array.isArray(h) && h.type === "element")) {
            const m = h.children[0];
            m && m.type === "text" && (m.value = _g(m.value));
          }
          Array.isArray(h) ? d.push(...h) : d.push(h);
        }
      }
    }
    return d;
  }
}
function f2(e, t) {
  e.position && (t.position = QD(e));
}
function p2(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, o = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const a = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: a };
      }
    n.type === "element" && o && Object.assign(n.properties, fu(o)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function h2(e, t) {
  const n = t.data || {}, r = "value" in t && !(Pp.call(n, "hProperties") || Pp.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function m2(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function _g(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function Sg(e, t) {
  const n = d2(e, t), r = n.one(e, void 0), i = t2(n), o = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && o.children.push({ type: "text", value: `
` }, i), o;
}
function y2(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      Sg(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      Sg(n, { file: r, ...t || e })
    );
  };
}
function kg(e) {
  if (e)
    throw e;
}
var Yc = Object.prototype.hasOwnProperty, uS = Object.prototype.toString, Eg = Object.defineProperty, Cg = Object.getOwnPropertyDescriptor, Tg = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : uS.call(t) === "[object Array]";
}, Rg = function(t) {
  if (!t || uS.call(t) !== "[object Object]")
    return !1;
  var n = Yc.call(t, "constructor"), r = t.constructor && t.constructor.prototype && Yc.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n && !r)
    return !1;
  var i;
  for (i in t)
    ;
  return typeof i > "u" || Yc.call(t, i);
}, Ag = function(t, n) {
  Eg && n.name === "__proto__" ? Eg(t, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : t[n.name] = n.newValue;
}, Og = function(t, n) {
  if (n === "__proto__")
    if (Yc.call(t, n)) {
      if (Cg)
        return Cg(t, n).value;
    } else
      return;
  return t[n];
}, g2 = function e() {
  var t, n, r, i, o, a, s = arguments[0], c = 1, l = arguments.length, u = !1;
  for (typeof s == "boolean" && (u = s, s = arguments[1] || {}, c = 2), (s == null || typeof s != "object" && typeof s != "function") && (s = {}); c < l; ++c)
    if (t = arguments[c], t != null)
      for (n in t)
        r = Og(s, n), i = Og(t, n), s !== i && (u && i && (Rg(i) || (o = Tg(i))) ? (o ? (o = !1, a = r && Tg(r) ? r : []) : a = r && Rg(r) ? r : {}, Ag(s, { name: n, newValue: e(u, a, i) })) : typeof i < "u" && Ag(s, { name: n, newValue: i }));
  return s;
};
const df = /* @__PURE__ */ Vi(g2);
function $p(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function v2() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let o = -1;
    const a = i.pop();
    if (typeof a != "function")
      throw new TypeError("Expected function as last argument, not " + a);
    s(null, ...i);
    function s(c, ...l) {
      const u = e[++o];
      let d = -1;
      if (c) {
        a(c);
        return;
      }
      for (; ++d < i.length; )
        (l[d] === null || l[d] === void 0) && (l[d] = i[d]);
      i = l, u ? b2(u, s)(...l) : a(null, ...l);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function b2(e, t) {
  let n;
  return r;
  function r(...a) {
    const s = e.length > a.length;
    let c;
    s && a.push(i);
    try {
      c = e.apply(this, a);
    } catch (l) {
      const u = (
        /** @type {Error} */
        l
      );
      if (s && n)
        throw u;
      return i(u);
    }
    s || (c instanceof Promise ? c.then(o, i) : c instanceof Error ? i(c) : o(c));
  }
  function i(a, ...s) {
    n || (n = !0, t(a, ...s));
  }
  function o(a) {
    i(null, a);
  }
}
const Lr = { basename: w2, dirname: x2, extname: _2, join: S2, sep: "/" };
function w2(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  tc(e);
  let n = 0, r = -1, i = e.length, o;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (o) {
          n = i + 1;
          break;
        }
      } else
        r < 0 && (o = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let a = -1, s = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (o) {
        n = i + 1;
        break;
      }
    } else
      a < 0 && (o = !0, a = i + 1), s > -1 && (e.codePointAt(i) === t.codePointAt(s--) ? s < 0 && (r = i) : (s = -1, r = a));
  return n === r ? r = a : r < 0 && (r = e.length), e.slice(n, r);
}
function x2(e) {
  if (tc(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else
      r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function _2(e) {
  tc(e);
  let t = e.length, n = -1, r = 0, i = -1, o = 0, a;
  for (; t--; ) {
    const s = e.codePointAt(t);
    if (s === 47) {
      if (a) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (a = !0, n = t + 1), s === 46 ? i < 0 ? i = t : o !== 1 && (o = 1) : i > -1 && (o = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  o === 0 || // The (right-most) trimmed path component is exactly `..`.
  o === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function S2(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    tc(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : k2(n);
}
function k2(e) {
  tc(e);
  const t = e.codePointAt(0) === 47;
  let n = E2(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function E2(e, t) {
  let n = "", r = 0, i = -1, o = 0, a = -1, s, c;
  for (; ++a <= e.length; ) {
    if (a < e.length)
      s = e.codePointAt(a);
    else {
      if (s === 47)
        break;
      s = 47;
    }
    if (s === 47) {
      if (!(i === a - 1 || o === 1))
        if (i !== a - 1 && o === 2) {
          if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              if (c = n.lastIndexOf("/"), c !== n.length - 1) {
                c < 0 ? (n = "", r = 0) : (n = n.slice(0, c), r = n.length - 1 - n.lastIndexOf("/")), i = a, o = 0;
                continue;
              }
            } else if (n.length > 0) {
              n = "", r = 0, i = a, o = 0;
              continue;
            }
          }
          t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
        } else
          n.length > 0 ? n += "/" + e.slice(i + 1, a) : n = e.slice(i + 1, a), r = a - i - 1;
      i = a, o = 0;
    } else
      s === 46 && o > -1 ? o++ : o = -1;
  }
  return n;
}
function tc(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const C2 = { cwd: T2 };
function T2() {
  return "/";
}
function Dp(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function R2(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Dp(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return A2(e);
}
function A2(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const ff = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class dS {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? Dp(t) ? n = { path: t } : typeof t == "string" || O2(t) ? n = { value: t } : n = t : n = {}, this.cwd = C2.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < ff.length; ) {
      const o = ff[r];
      o in n && n[o] !== void 0 && n[o] !== null && (this[o] = o === "history" ? [...n[o]] : n[o]);
    }
    let i;
    for (i in n)
      ff.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Lr.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    hf(t, "basename"), pf(t, "basename"), this.path = Lr.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Lr.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Ig(this.basename, "dirname"), this.path = Lr.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Lr.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (pf(t, "extname"), Ig(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Lr.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Dp(t) && (t = R2(t)), hf(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Lr.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    hf(t, "stem"), pf(t, "stem"), this.path = Lr.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new Fn(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function pf(e, t) {
  if (e && e.includes(Lr.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Lr.sep + "`"
    );
}
function hf(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Ig(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function O2(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const I2 = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], o = function() {
      return i.apply(o, arguments);
    };
    Object.setPrototypeOf(o, r);
    const a = Object.getOwnPropertyNames(i);
    for (const s of a) {
      const c = Object.getOwnPropertyDescriptor(i, s);
      c && Object.defineProperty(o, s, c);
    }
    return o;
  }
), P2 = {}.hasOwnProperty;
class Am extends I2 {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = v2();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@link Processor `Processor`}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Am()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(df(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * >  **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * >  **Note**: to register custom data in TypeScript, augment the
   * > {@link Data `Data`} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (gf("data", this.frozen), this.namespace[t] = n, this) : P2.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (gf("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * >  **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = kc(t), r = this.parser || this.Parser;
    return mf("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * >  **Note**: `process` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), mf("process", this.parser || this.Parser), yf("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(o, a) {
      const s = kc(t), c = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(s)
      );
      r.run(c, s, function(u, d, p) {
        if (u || !d || !p)
          return l(u);
        const f = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          d
        ), h = r.stringify(f, p);
        N2(h) ? p.value = h : p.result = h, l(
          u,
          /** @type {VFileWithOutput<CompileResult>} */
          p
        );
      });
      function l(u, d) {
        u || !d ? a(u) : o ? o(d) : n(void 0, d);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), mf("processSync", this.parser || this.Parser), yf("processSync", this.compiler || this.Compiler), this.process(t, i), $g("processSync", "process", n), r;
    function i(o, a) {
      n = !0, kg(o), r = a;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * >  **Note**: `run` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    Pg(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? o(void 0, r) : new Promise(o);
    function o(a, s) {
      const c = kc(n);
      i.run(t, c, l);
      function l(u, d, p) {
        const f = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          d || t
        );
        u ? s(u) : a ? a(f) : r(void 0, f, p);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, o), $g("runSync", "run", r), i;
    function o(a, s) {
      kg(a), i = s, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * >  **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = kc(n), i = this.compiler || this.Compiler;
    return yf("stringify", i), Pg(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * >  **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (gf("use", this.frozen), t != null)
      if (typeof t == "function")
        c(t, n);
      else if (typeof t == "object")
        Array.isArray(t) ? s(t) : a(t);
      else
        throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function o(l) {
      if (typeof l == "function")
        c(l, []);
      else if (typeof l == "object")
        if (Array.isArray(l)) {
          const [u, ...d] = (
            /** @type {PluginTuple<Array<unknown>>} */
            l
          );
          c(u, d);
        } else
          a(l);
      else
        throw new TypeError("Expected usable value, not `" + l + "`");
    }
    function a(l) {
      if (!("plugins" in l) && !("settings" in l))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      s(l.plugins), l.settings && (i.settings = df(!0, i.settings, l.settings));
    }
    function s(l) {
      let u = -1;
      if (l != null)
        if (Array.isArray(l))
          for (; ++u < l.length; ) {
            const d = l[u];
            o(d);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + l + "`");
    }
    function c(l, u) {
      let d = -1, p = -1;
      for (; ++d < r.length; )
        if (r[d][0] === l) {
          p = d;
          break;
        }
      if (p === -1)
        r.push([l, ...u]);
      else if (u.length > 0) {
        let [f, ...h] = u;
        const m = r[p][1];
        $p(m) && $p(f) && (f = df(!0, m, f)), r[p] = [l, f, ...h];
      }
    }
  }
}
const $2 = new Am().freeze();
function mf(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function yf(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function gf(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Pg(e) {
  if (!$p(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function $g(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function kc(e) {
  return D2(e) ? e : new dS(e);
}
function D2(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function N2(e) {
  return typeof e == "string" || j2(e);
}
function j2(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const M2 = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", Dg = [], Ng = { allowDangerousHtml: !0 }, q2 = /^(https?|ircs?|mailto|xmpp)$/i, L2 = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function F2(e) {
  const t = e.allowedElements, n = e.allowElement, r = e.children || "", i = e.className, o = e.components, a = e.disallowedElements, s = e.rehypePlugins || Dg, c = e.remarkPlugins || Dg, l = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Ng } : Ng, u = e.skipHtml, d = e.unwrapDisallowed, p = e.urlTransform || U2, f = $2().use(_M).use(c).use(y2, l).use(s), h = new dS();
  typeof r == "string" && (h.value = r);
  for (const v of L2)
    Object.hasOwn(e, v.from) && ("" + v.from + (v.to ? "use `" + v.to + "` instead" : "remove it") + M2 + v.id, void 0);
  const m = f.parse(h);
  let y = f.runSync(m, h);
  return i && (y = {
    type: "element",
    tagName: "div",
    properties: { className: i },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      y.type === "root" ? y.children : [y]
    )
  }), Rm(y, g), oN(y, {
    Fragment: F.Fragment,
    components: o,
    ignoreInvalidStyle: !0,
    jsx: F.jsx,
    jsxs: F.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function g(v, b, _) {
    if (v.type === "raw" && _ && typeof b == "number")
      return u ? _.children.splice(b, 1) : _.children[b] = { type: "text", value: v.value }, b;
    if (v.type === "element") {
      let S;
      for (S in cf)
        if (Object.hasOwn(cf, S) && Object.hasOwn(v.properties, S)) {
          const x = v.properties[S], A = cf[S];
          (A === null || A.includes(v.tagName)) && (v.properties[S] = p(String(x || ""), S, v));
        }
    }
    if (v.type === "element") {
      let S = t ? !t.includes(v.tagName) : a ? a.includes(v.tagName) : !1;
      if (!S && n && typeof b == "number" && (S = !n(v, b, _)), S && _ && typeof b == "number")
        return d && v.children ? _.children.splice(b, 1, ...v.children) : _.children.splice(b, 1), b;
    }
  }
}
function U2(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    i > -1 && t > i || n > -1 && t > n || r > -1 && t > r || // It is a protocol, it should be allowed.
    q2.test(e.slice(0, t)) ? e : ""
  );
}
function B2(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function fS(e, t, n) {
  const i = wd((n || {}).ignore || []), o = z2(t);
  let a = -1;
  for (; ++a < o.length; )
    lS(e, "text", s);
  function s(l, u) {
    let d = -1, p;
    for (; ++d < u.length; ) {
      const f = u[d], h = p ? p.children : void 0;
      if (i(
        f,
        h ? h.indexOf(f) : void 0,
        p
      ))
        return;
      p = f;
    }
    if (p)
      return c(l, u);
  }
  function c(l, u) {
    const d = u[u.length - 1], p = o[a][0], f = o[a][1];
    let h = 0;
    const y = d.children.indexOf(l);
    let g = !1, v = [];
    p.lastIndex = 0;
    let b = p.exec(l.value);
    for (; b; ) {
      const _ = b.index, S = {
        index: b.index,
        input: b.input,
        stack: [...u, l]
      };
      let x = f(...b, S);
      if (typeof x == "string" && (x = x.length > 0 ? { type: "text", value: x } : void 0), x === !1 ? p.lastIndex = _ + 1 : (h !== _ && v.push({
        type: "text",
        value: l.value.slice(h, _)
      }), Array.isArray(x) ? v.push(...x) : x && v.push(x), h = _ + b[0].length, g = !0), !p.global)
        break;
      b = p.exec(l.value);
    }
    return g ? (h < l.value.length && v.push({ type: "text", value: l.value.slice(h) }), d.children.splice(y, 1, ...v)) : v = [l], y + v.length;
  }
}
function z2(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    t.push([Z2(i[0]), V2(i[1])]);
  }
  return t;
}
function Z2(e) {
  return typeof e == "string" ? new RegExp(B2(e), "g") : e;
}
function V2(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
function H2(e) {
  fS(e, [/\r?\n|\r/g, W2]);
}
function W2() {
  return { type: "break" };
}
function K2() {
  return function(e) {
    H2(e);
  };
}
function jg(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
const vf = "phrasing", bf = ["autolink", "link", "image", "label"];
function J2() {
  return {
    transforms: [nq],
    enter: {
      literalAutolink: G2,
      literalAutolinkEmail: wf,
      literalAutolinkHttp: wf,
      literalAutolinkWww: wf
    },
    exit: {
      literalAutolink: tq,
      literalAutolinkEmail: eq,
      literalAutolinkHttp: X2,
      literalAutolinkWww: Q2
    }
  };
}
function Y2() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: vf,
        notInConstruct: bf
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: vf,
        notInConstruct: bf
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: vf,
        notInConstruct: bf
      }
    ]
  };
}
function G2(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function wf(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function X2(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function Q2(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function eq(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function tq(e) {
  this.exit(e);
}
function nq(e) {
  fS(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, rq],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, iq]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function rq(e, t, n, r, i) {
  let o = "";
  if (!pS(i) || (/^w/i.test(t) && (n = t + n, t = "", o = "http://"), !oq(n)))
    return !1;
  const a = aq(n + r);
  if (!a[0])
    return !1;
  const s = {
    type: "link",
    title: null,
    url: o + t + a[0],
    children: [{ type: "text", value: t + a[0] }]
  };
  return a[1] ? [s, { type: "text", value: a[1] }] : s;
}
function iq(e, t, n, r) {
  return (
    // Not an expected previous character.
    !pS(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function oq(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function aq(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const i = jg(e, "(");
  let o = jg(e, ")");
  for (; r !== -1 && i > o; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), o++;
  return [e, n];
}
function pS(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || bo(n) || gd(n)) && (!t || n !== 47);
}
hS.peek = gq;
function sq() {
  return {
    enter: {
      gfmFootnoteDefinition: lq,
      gfmFootnoteDefinitionLabelString: uq,
      gfmFootnoteCall: pq,
      gfmFootnoteCallString: hq
    },
    exit: {
      gfmFootnoteDefinition: fq,
      gfmFootnoteDefinitionLabelString: dq,
      gfmFootnoteCall: yq,
      gfmFootnoteCallString: mq
    }
  };
}
function cq() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: vq, footnoteReference: hS }
  };
}
function lq(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function uq() {
  this.buffer();
}
function dq(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = Tr(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function fq(e) {
  this.exit(e);
}
function pq(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function hq() {
  this.buffer();
}
function mq(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = Tr(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function yq(e) {
  this.exit(e);
}
function hS(e, t, n, r) {
  const i = n.createTracker(r);
  let o = i.move("[^");
  const a = n.enter("footnoteReference"), s = n.enter("reference");
  return o += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: o,
      after: "]"
    })
  ), s(), a(), o += i.move("]"), o;
}
function gq() {
  return "[";
}
function vq(e, t, n, r) {
  const i = n.createTracker(r);
  let o = i.move("[^");
  const a = n.enter("footnoteDefinition"), s = n.enter("label");
  return o += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: o,
      after: "]"
    })
  ), s(), o += i.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), i.shift(4), o += i.move(
    n.indentLines(n.containerFlow(e, i.current()), bq)
  ), a(), o;
}
function bq(e, t, n) {
  return t === 0 ? e : (n ? "" : "    ") + e;
}
const wq = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
mS.peek = Eq;
function xq() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Sq },
    exit: { strikethrough: kq }
  };
}
function _q() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: wq
      }
    ],
    handlers: { delete: mS }
  };
}
function Sq(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function kq(e) {
  this.exit(e);
}
function mS(e, t, n, r) {
  const i = n.createTracker(r), o = n.enter("strikethrough");
  let a = i.move("~~");
  return a += n.containerPhrasing(e, {
    ...i.current(),
    before: a,
    after: "~"
  }), a += i.move("~~"), o(), a;
}
function Eq() {
  return "~";
}
function Cq(e, t = {}) {
  const n = (t.align || []).concat(), r = t.stringLength || Rq, i = [], o = [], a = [], s = [];
  let c = 0, l = -1;
  for (; ++l < e.length; ) {
    const h = [], m = [];
    let y = -1;
    for (e[l].length > c && (c = e[l].length); ++y < e[l].length; ) {
      const g = Tq(e[l][y]);
      if (t.alignDelimiters !== !1) {
        const v = r(g);
        m[y] = v, (s[y] === void 0 || v > s[y]) && (s[y] = v);
      }
      h.push(g);
    }
    o[l] = h, a[l] = m;
  }
  let u = -1;
  if (typeof n == "object" && "length" in n)
    for (; ++u < c; )
      i[u] = Mg(n[u]);
  else {
    const h = Mg(n);
    for (; ++u < c; )
      i[u] = h;
  }
  u = -1;
  const d = [], p = [];
  for (; ++u < c; ) {
    const h = i[u];
    let m = "", y = "";
    h === 99 ? (m = ":", y = ":") : h === 108 ? m = ":" : h === 114 && (y = ":");
    let g = t.alignDelimiters === !1 ? 1 : Math.max(
      1,
      s[u] - m.length - y.length
    );
    const v = m + "-".repeat(g) + y;
    t.alignDelimiters !== !1 && (g = m.length + g + y.length, g > s[u] && (s[u] = g), p[u] = g), d[u] = v;
  }
  o.splice(1, 0, d), a.splice(1, 0, p), l = -1;
  const f = [];
  for (; ++l < o.length; ) {
    const h = o[l], m = a[l];
    u = -1;
    const y = [];
    for (; ++u < c; ) {
      const g = h[u] || "";
      let v = "", b = "";
      if (t.alignDelimiters !== !1) {
        const _ = s[u] - (m[u] || 0), S = i[u];
        S === 114 ? v = " ".repeat(_) : S === 99 ? _ % 2 ? (v = " ".repeat(_ / 2 + 0.5), b = " ".repeat(_ / 2 - 0.5)) : (v = " ".repeat(_ / 2), b = v) : b = " ".repeat(_);
      }
      t.delimiterStart !== !1 && !u && y.push("|"), t.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(t.alignDelimiters === !1 && g === "") && (t.delimiterStart !== !1 || u) && y.push(" "), t.alignDelimiters !== !1 && y.push(v), y.push(g), t.alignDelimiters !== !1 && y.push(b), t.padding !== !1 && y.push(" "), (t.delimiterEnd !== !1 || u !== c - 1) && y.push("|");
    }
    f.push(
      t.delimiterEnd === !1 ? y.join("").replace(/ +$/, "") : y.join("")
    );
  }
  return f.join(`
`);
}
function Tq(e) {
  return e == null ? "" : String(e);
}
function Rq(e) {
  return e.length;
}
function Mg(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function Aq(e, t, n, r) {
  const i = n.enter("blockquote"), o = n.createTracker(r);
  o.move("> "), o.shift(2);
  const a = n.indentLines(
    n.containerFlow(e, o.current()),
    Oq
  );
  return i(), a;
}
function Oq(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function Iq(e, t) {
  return qg(e, t.inConstruct, !0) && !qg(e, t.notInConstruct, !1);
}
function qg(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function Lg(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && Iq(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function Pq(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, o = 0, a = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++o > a && (a = o) : o = 1, i = r + t.length, r = n.indexOf(t, i);
  return a;
}
function $q(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function Dq(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function Nq(e, t, n, r) {
  const i = Dq(n), o = e.value || "", a = i === "`" ? "GraveAccent" : "Tilde";
  if ($q(e, n)) {
    const d = n.enter("codeIndented"), p = n.indentLines(o, jq);
    return d(), p;
  }
  const s = n.createTracker(r), c = i.repeat(Math.max(Pq(o, i) + 1, 3)), l = n.enter("codeFenced");
  let u = s.move(c);
  if (e.lang) {
    const d = n.enter(`codeFencedLang${a}`);
    u += s.move(
      n.safe(e.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...s.current()
      })
    ), d();
  }
  if (e.lang && e.meta) {
    const d = n.enter(`codeFencedMeta${a}`);
    u += s.move(" "), u += s.move(
      n.safe(e.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...s.current()
      })
    ), d();
  }
  return u += s.move(`
`), o && (u += s.move(o + `
`)), u += s.move(c), l(), u;
}
function jq(e, t, n) {
  return (n ? "" : "    ") + e;
}
function Om(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function Mq(e, t, n, r) {
  const i = Om(n), o = i === '"' ? "Quote" : "Apostrophe", a = n.enter("definition");
  let s = n.enter("label");
  const c = n.createTracker(r);
  let l = c.move("[");
  return l += c.move(
    n.safe(n.associationId(e), {
      before: l,
      after: "]",
      ...c.current()
    })
  ), l += c.move("]: "), s(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), l += c.move("<"), l += c.move(
    n.safe(e.url, { before: l, after: ">", ...c.current() })
  ), l += c.move(">")) : (s = n.enter("destinationRaw"), l += c.move(
    n.safe(e.url, {
      before: l,
      after: e.title ? " " : `
`,
      ...c.current()
    })
  )), s(), e.title && (s = n.enter(`title${o}`), l += c.move(" " + i), l += c.move(
    n.safe(e.title, {
      before: l,
      after: i,
      ...c.current()
    })
  ), l += c.move(i), s()), a(), l;
}
function qq(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
yS.peek = Lq;
function yS(e, t, n, r) {
  const i = qq(n), o = n.enter("emphasis"), a = n.createTracker(r);
  let s = a.move(i);
  return s += a.move(
    n.containerPhrasing(e, {
      before: s,
      after: i,
      ...a.current()
    })
  ), s += a.move(i), o(), s;
}
function Lq(e, t, n) {
  return n.options.emphasis || "*";
}
function Fq(e, t) {
  let n = !1;
  return Rm(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Ip;
  }), !!((!e.depth || e.depth < 3) && xm(e) && (t.options.setext || n));
}
function Uq(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), o = n.createTracker(r);
  if (Fq(e, n)) {
    const u = n.enter("headingSetext"), d = n.enter("phrasing"), p = n.containerPhrasing(e, {
      ...o.current(),
      before: `
`,
      after: `
`
    });
    return d(), u(), p + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size
      p.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(p.lastIndexOf("\r"), p.lastIndexOf(`
`)) + 1)
    );
  }
  const a = "#".repeat(i), s = n.enter("headingAtx"), c = n.enter("phrasing");
  o.move(a + " ");
  let l = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...o.current()
  });
  return /^[\t ]/.test(l) && (l = "&#x" + l.charCodeAt(0).toString(16).toUpperCase() + ";" + l.slice(1)), l = l ? a + " " + l : a, n.options.closeAtx && (l += " " + a), c(), s(), l;
}
gS.peek = Bq;
function gS(e) {
  return e.value || "";
}
function Bq() {
  return "<";
}
vS.peek = zq;
function vS(e, t, n, r) {
  const i = Om(n), o = i === '"' ? "Quote" : "Apostrophe", a = n.enter("image");
  let s = n.enter("label");
  const c = n.createTracker(r);
  let l = c.move("![");
  return l += c.move(
    n.safe(e.alt, { before: l, after: "]", ...c.current() })
  ), l += c.move("]("), s(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), l += c.move("<"), l += c.move(
    n.safe(e.url, { before: l, after: ">", ...c.current() })
  ), l += c.move(">")) : (s = n.enter("destinationRaw"), l += c.move(
    n.safe(e.url, {
      before: l,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), s(), e.title && (s = n.enter(`title${o}`), l += c.move(" " + i), l += c.move(
    n.safe(e.title, {
      before: l,
      after: i,
      ...c.current()
    })
  ), l += c.move(i), s()), l += c.move(")"), a(), l;
}
function zq() {
  return "!";
}
bS.peek = Zq;
function bS(e, t, n, r) {
  const i = e.referenceType, o = n.enter("imageReference");
  let a = n.enter("label");
  const s = n.createTracker(r);
  let c = s.move("![");
  const l = n.safe(e.alt, {
    before: c,
    after: "]",
    ...s.current()
  });
  c += s.move(l + "]["), a();
  const u = n.stack;
  n.stack = [], a = n.enter("reference");
  const d = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...s.current()
  });
  return a(), n.stack = u, o(), i === "full" || !l || l !== d ? c += s.move(d + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += s.move("]"), c;
}
function Zq() {
  return "!";
}
wS.peek = Vq;
function wS(e, t, n) {
  let r = e.value || "", i = "`", o = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++o < n.unsafe.length; ) {
    const a = n.unsafe[o], s = n.compilePattern(a);
    let c;
    if (a.atBreak)
      for (; c = s.exec(r); ) {
        let l = c.index;
        r.charCodeAt(l) === 10 && r.charCodeAt(l - 1) === 13 && l--, r = r.slice(0, l) + " " + r.slice(c.index + 1);
      }
  }
  return i + r + i;
}
function Vq() {
  return "`";
}
function xS(e, t) {
  const n = xm(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
_S.peek = Hq;
function _S(e, t, n, r) {
  const i = Om(n), o = i === '"' ? "Quote" : "Apostrophe", a = n.createTracker(r);
  let s, c;
  if (xS(e, n)) {
    const u = n.stack;
    n.stack = [], s = n.enter("autolink");
    let d = a.move("<");
    return d += a.move(
      n.containerPhrasing(e, {
        before: d,
        after: ">",
        ...a.current()
      })
    ), d += a.move(">"), s(), n.stack = u, d;
  }
  s = n.enter("link"), c = n.enter("label");
  let l = a.move("[");
  return l += a.move(
    n.containerPhrasing(e, {
      before: l,
      after: "](",
      ...a.current()
    })
  ), l += a.move("]("), c(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), l += a.move("<"), l += a.move(
    n.safe(e.url, { before: l, after: ">", ...a.current() })
  ), l += a.move(">")) : (c = n.enter("destinationRaw"), l += a.move(
    n.safe(e.url, {
      before: l,
      after: e.title ? " " : ")",
      ...a.current()
    })
  )), c(), e.title && (c = n.enter(`title${o}`), l += a.move(" " + i), l += a.move(
    n.safe(e.title, {
      before: l,
      after: i,
      ...a.current()
    })
  ), l += a.move(i), c()), l += a.move(")"), s(), l;
}
function Hq(e, t, n) {
  return xS(e, n) ? "<" : "[";
}
SS.peek = Wq;
function SS(e, t, n, r) {
  const i = e.referenceType, o = n.enter("linkReference");
  let a = n.enter("label");
  const s = n.createTracker(r);
  let c = s.move("[");
  const l = n.containerPhrasing(e, {
    before: c,
    after: "]",
    ...s.current()
  });
  c += s.move(l + "]["), a();
  const u = n.stack;
  n.stack = [], a = n.enter("reference");
  const d = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...s.current()
  });
  return a(), n.stack = u, o(), i === "full" || !l || l !== d ? c += s.move(d + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += s.move("]"), c;
}
function Wq() {
  return "[";
}
function Im(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function Kq(e) {
  const t = Im(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function Jq(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function kS(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function Yq(e, t, n, r) {
  const i = n.enter("list"), o = n.bulletCurrent;
  let a = e.ordered ? Jq(n) : Im(n);
  const s = e.ordered ? a === "." ? ")" : "." : Kq(n);
  let c = t && n.bulletLastUsed ? a === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const u = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (a === "*" || a === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (c = !0), kS(n) === a && u
    ) {
      let d = -1;
      for (; ++d < e.children.length; ) {
        const p = e.children[d];
        if (p && p.type === "listItem" && p.children && p.children[0] && p.children[0].type === "thematicBreak") {
          c = !0;
          break;
        }
      }
    }
  }
  c && (a = s), n.bulletCurrent = a;
  const l = n.containerFlow(e, r);
  return n.bulletLastUsed = a, n.bulletCurrent = o, i(), l;
}
function Gq(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function Xq(e, t, n, r) {
  const i = Gq(n);
  let o = n.bulletCurrent || Im(n);
  t && t.type === "list" && t.ordered && (o = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + o);
  let a = o.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (a = Math.ceil(a / 4) * 4);
  const s = n.createTracker(r);
  s.move(o + " ".repeat(a - o.length)), s.shift(a);
  const c = n.enter("listItem"), l = n.indentLines(
    n.containerFlow(e, s.current()),
    u
  );
  return c(), l;
  function u(d, p, f) {
    return p ? (f ? "" : " ".repeat(a)) + d : (f ? o : o + " ".repeat(a - o.length)) + d;
  }
}
function Qq(e, t, n, r) {
  const i = n.enter("paragraph"), o = n.enter("phrasing"), a = n.containerPhrasing(e, r);
  return o(), i(), a;
}
const eL = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  wd([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function tL(e, t, n, r) {
  return (e.children.some(function(a) {
    return eL(a);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function nL(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
ES.peek = rL;
function ES(e, t, n, r) {
  const i = nL(n), o = n.enter("strong"), a = n.createTracker(r);
  let s = a.move(i + i);
  return s += a.move(
    n.containerPhrasing(e, {
      before: s,
      after: i,
      ...a.current()
    })
  ), s += a.move(i + i), o(), s;
}
function rL(e, t, n) {
  return n.options.strong || "*";
}
function iL(e, t, n, r) {
  return n.safe(e.value, r);
}
function oL(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function aL(e, t, n) {
  const r = (kS(n) + (n.options.ruleSpaces ? " " : "")).repeat(oL(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const CS = {
  blockquote: Aq,
  break: Lg,
  code: Nq,
  definition: Mq,
  emphasis: yS,
  hardBreak: Lg,
  heading: Uq,
  html: gS,
  image: vS,
  imageReference: bS,
  inlineCode: wS,
  link: _S,
  linkReference: SS,
  list: Yq,
  listItem: Xq,
  paragraph: Qq,
  root: tL,
  strong: ES,
  text: iL,
  thematicBreak: aL
};
function sL() {
  return {
    enter: {
      table: cL,
      tableData: Fg,
      tableHeader: Fg,
      tableRow: uL
    },
    exit: {
      codeText: dL,
      table: lL,
      tableData: xf,
      tableHeader: xf,
      tableRow: xf
    }
  };
}
function cL(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function lL(e) {
  this.exit(e), this.data.inTable = void 0;
}
function uL(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function xf(e) {
  this.exit(e);
}
function Fg(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function dL(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, fL));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function fL(e, t) {
  return t === "|" ? t : e;
}
function pL(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, o = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: p,
      table: a,
      tableCell: c,
      tableRow: s
    }
  };
  function a(f, h, m, y) {
    return l(u(f, m, y), f.align);
  }
  function s(f, h, m, y) {
    const g = d(f, m, y), v = l([g]);
    return v.slice(0, v.indexOf(`
`));
  }
  function c(f, h, m, y) {
    const g = m.enter("tableCell"), v = m.enter("phrasing"), b = m.containerPhrasing(f, {
      ...y,
      before: o,
      after: o
    });
    return v(), g(), b;
  }
  function l(f, h) {
    return Cq(f, {
      align: h,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function u(f, h, m) {
    const y = f.children;
    let g = -1;
    const v = [], b = h.enter("table");
    for (; ++g < y.length; )
      v[g] = d(y[g], h, m);
    return b(), v;
  }
  function d(f, h, m) {
    const y = f.children;
    let g = -1;
    const v = [], b = h.enter("tableRow");
    for (; ++g < y.length; )
      v[g] = c(y[g], f, h, m);
    return b(), v;
  }
  function p(f, h, m) {
    let y = CS.inlineCode(f, h, m);
    return m.stack.includes("tableCell") && (y = y.replace(/\|/g, "\\$&")), y;
  }
}
function hL() {
  return {
    exit: {
      taskListCheckValueChecked: Ug,
      taskListCheckValueUnchecked: Ug,
      paragraph: yL
    }
  };
}
function mL() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: gL }
  };
}
function Ug(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function yL(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let o = -1, a;
      for (; ++o < i.length; ) {
        const s = i[o];
        if (s.type === "paragraph") {
          a = s;
          break;
        }
      }
      a === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function gL(e, t, n, r) {
  const i = e.children[0], o = typeof e.checked == "boolean" && i && i.type === "paragraph", a = "[" + (e.checked ? "x" : " ") + "] ", s = n.createTracker(r);
  o && s.move(a);
  let c = CS.listItem(e, t, n, {
    ...r,
    ...s.current()
  });
  return o && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, l)), c;
  function l(u) {
    return u + a;
  }
}
function vL() {
  return [
    J2(),
    sq(),
    xq(),
    sL(),
    hL()
  ];
}
function bL(e) {
  return {
    extensions: [
      Y2(),
      cq(),
      _q(),
      pL(e),
      mL()
    ]
  };
}
const wL = {
  tokenize: CL,
  partial: !0
}, TS = {
  tokenize: TL,
  partial: !0
}, RS = {
  tokenize: RL,
  partial: !0
}, AS = {
  tokenize: AL,
  partial: !0
}, xL = {
  tokenize: OL,
  partial: !0
}, OS = {
  tokenize: kL,
  previous: PS
}, IS = {
  tokenize: EL,
  previous: $S
}, yi = {
  tokenize: SL,
  previous: DS
}, Gr = {};
function _L() {
  return {
    text: Gr
  };
}
let eo = 48;
for (; eo < 123; )
  Gr[eo] = yi, eo++, eo === 58 ? eo = 65 : eo === 91 && (eo = 97);
Gr[43] = yi;
Gr[45] = yi;
Gr[46] = yi;
Gr[95] = yi;
Gr[72] = [yi, IS];
Gr[104] = [yi, IS];
Gr[87] = [yi, OS];
Gr[119] = [yi, OS];
function SL(e, t, n) {
  const r = this;
  let i, o;
  return a;
  function a(d) {
    return !Np(d) || !DS.call(r, r.previous) || Pm(r.events) ? n(d) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), s(d));
  }
  function s(d) {
    return Np(d) ? (e.consume(d), s) : d === 64 ? (e.consume(d), c) : n(d);
  }
  function c(d) {
    return d === 46 ? e.check(
      xL,
      u,
      l
    )(d) : d === 45 || d === 95 || Dn(d) ? (o = !0, e.consume(d), c) : u(d);
  }
  function l(d) {
    return e.consume(d), i = !0, c;
  }
  function u(d) {
    return o && i && zn(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(d)) : n(d);
  }
}
function kL(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return a !== 87 && a !== 119 || !PS.call(r, r.previous) || Pm(r.events) ? n(a) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(
      wL,
      e.attempt(TS, e.attempt(RS, o), n),
      n
    )(a));
  }
  function o(a) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(a);
  }
}
function EL(e, t, n) {
  const r = this;
  let i = "", o = !1;
  return a;
  function a(d) {
    return (d === 72 || d === 104) && $S.call(r, r.previous) && !Pm(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(d), e.consume(d), s) : n(d);
  }
  function s(d) {
    if (zn(d) && i.length < 5)
      return i += String.fromCodePoint(d), e.consume(d), s;
    if (d === 58) {
      const p = i.toLowerCase();
      if (p === "http" || p === "https")
        return e.consume(d), c;
    }
    return n(d);
  }
  function c(d) {
    return d === 47 ? (e.consume(d), o ? l : (o = !0, c)) : n(d);
  }
  function l(d) {
    return d === null || cu(d) || Mt(d) || bo(d) || gd(d) ? n(d) : e.attempt(TS, e.attempt(RS, u), n)(d);
  }
  function u(d) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(d);
  }
}
function CL(e, t, n) {
  let r = 0;
  return i;
  function i(a) {
    return (a === 87 || a === 119) && r < 3 ? (r++, e.consume(a), i) : a === 46 && r === 3 ? (e.consume(a), o) : n(a);
  }
  function o(a) {
    return a === null ? n(a) : t(a);
  }
}
function TL(e, t, n) {
  let r, i, o;
  return a;
  function a(l) {
    return l === 46 || l === 95 ? e.check(AS, c, s)(l) : l === null || Mt(l) || bo(l) || l !== 45 && gd(l) ? c(l) : (o = !0, e.consume(l), a);
  }
  function s(l) {
    return l === 95 ? r = !0 : (i = r, r = void 0), e.consume(l), a;
  }
  function c(l) {
    return i || r || !o ? n(l) : t(l);
  }
}
function RL(e, t) {
  let n = 0, r = 0;
  return i;
  function i(a) {
    return a === 40 ? (n++, e.consume(a), i) : a === 41 && r < n ? o(a) : a === 33 || a === 34 || a === 38 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 60 || a === 63 || a === 93 || a === 95 || a === 126 ? e.check(AS, t, o)(a) : a === null || Mt(a) || bo(a) ? t(a) : (e.consume(a), i);
  }
  function o(a) {
    return a === 41 && r++, e.consume(a), i;
  }
}
function AL(e, t, n) {
  return r;
  function r(s) {
    return s === 33 || s === 34 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 63 || s === 95 || s === 126 ? (e.consume(s), r) : s === 38 ? (e.consume(s), o) : s === 93 ? (e.consume(s), i) : (
      // `<` is an end.
      s === 60 || // So is whitespace.
      s === null || Mt(s) || bo(s) ? t(s) : n(s)
    );
  }
  function i(s) {
    return s === null || s === 40 || s === 91 || Mt(s) || bo(s) ? t(s) : r(s);
  }
  function o(s) {
    return zn(s) ? a(s) : n(s);
  }
  function a(s) {
    return s === 59 ? (e.consume(s), r) : zn(s) ? (e.consume(s), a) : n(s);
  }
}
function OL(e, t, n) {
  return r;
  function r(o) {
    return e.consume(o), i;
  }
  function i(o) {
    return Dn(o) ? n(o) : t(o);
  }
}
function PS(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Mt(e);
}
function $S(e) {
  return !zn(e);
}
function DS(e) {
  return !(e === 47 || Np(e));
}
function Np(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || Dn(e);
}
function Pm(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const IL = {
  tokenize: LL,
  partial: !0
};
function PL() {
  return {
    document: {
      91: {
        tokenize: jL,
        continuation: {
          tokenize: ML
        },
        exit: qL
      }
    },
    text: {
      91: {
        tokenize: NL
      },
      93: {
        add: "after",
        tokenize: $L,
        resolveTo: DL
      }
    }
  };
}
function $L(e, t, n) {
  const r = this;
  let i = r.events.length;
  const o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a;
  for (; i--; ) {
    const c = r.events[i][1];
    if (c.type === "labelImage") {
      a = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return s;
  function s(c) {
    if (!a || !a._balanced)
      return n(c);
    const l = Tr(
      r.sliceSerialize({
        start: a.end,
        end: r.now()
      })
    );
    return l.codePointAt(0) !== 94 || !o.includes(l.slice(1)) ? n(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
  }
}
function DL(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const o = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, a = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, o.start),
    end: Object.assign({}, o.end)
  }, s = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", o, t],
    ["enter", a, t],
    ["exit", a, t],
    ["exit", o, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...s), e;
}
function NL(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o = 0, a;
  return s;
  function s(d) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(d) {
    return d !== 94 ? n(d) : (e.enter("gfmFootnoteCallMarker"), e.consume(d), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", l);
  }
  function l(d) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      d === 93 && !a || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      d === null || d === 91 || Mt(d)
    )
      return n(d);
    if (d === 93) {
      e.exit("chunkString");
      const p = e.exit("gfmFootnoteCallString");
      return i.includes(Tr(r.sliceSerialize(p))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(d);
    }
    return Mt(d) || (a = !0), o++, e.consume(d), d === 92 ? u : l;
  }
  function u(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), o++, l) : l(d);
  }
}
function jL(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o, a = 0, s;
  return c;
  function c(h) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), l;
  }
  function l(h) {
    return h === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", u) : n(h);
  }
  function u(h) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      h === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || Mt(h)
    )
      return n(h);
    if (h === 93) {
      e.exit("chunkString");
      const m = e.exit("gfmFootnoteDefinitionLabelString");
      return o = Tr(r.sliceSerialize(m)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), p;
    }
    return Mt(h) || (s = !0), a++, e.consume(h), h === 92 ? d : u;
  }
  function d(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), a++, u) : u(h);
  }
  function p(h) {
    return h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), i.includes(o) || i.push(o), Tt(
      e,
      f,
      "gfmFootnoteDefinitionWhitespace"
    )) : n(h);
  }
  function f(h) {
    return t(h);
  }
}
function ML(e, t, n) {
  return e.check(ec, t, e.attempt(IL, t, n));
}
function qL(e) {
  e.exit("gfmFootnoteDefinition");
}
function LL(e, t, n) {
  const r = this;
  return Tt(
    e,
    i,
    "gfmFootnoteDefinitionIndent",
    4 + 1
  );
  function i(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "gfmFootnoteDefinitionIndent" && a[2].sliceSerialize(a[1], !0).length === 4 ? t(o) : n(o);
  }
}
function FL(e) {
  let n = (e || {}).singleTilde;
  const r = {
    tokenize: o,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(a, s) {
    let c = -1;
    for (; ++c < a.length; )
      if (a[c][0] === "enter" && a[c][1].type === "strikethroughSequenceTemporary" && a[c][1]._close) {
        let l = c;
        for (; l--; )
          if (a[l][0] === "exit" && a[l][1].type === "strikethroughSequenceTemporary" && a[l][1]._open && // If the sizes are the same:
          a[c][1].end.offset - a[c][1].start.offset === a[l][1].end.offset - a[l][1].start.offset) {
            a[c][1].type = "strikethroughSequence", a[l][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, a[l][1].start),
              end: Object.assign({}, a[c][1].end)
            }, d = {
              type: "strikethroughText",
              start: Object.assign({}, a[l][1].end),
              end: Object.assign({}, a[c][1].start)
            }, p = [
              ["enter", u, s],
              ["enter", a[l][1], s],
              ["exit", a[l][1], s],
              ["enter", d, s]
            ], f = s.parser.constructs.insideSpan.null;
            f && sr(
              p,
              p.length,
              0,
              vd(f, a.slice(l + 1, c), s)
            ), sr(p, p.length, 0, [
              ["exit", d, s],
              ["enter", a[c][1], s],
              ["exit", a[c][1], s],
              ["exit", u, s]
            ]), sr(a, l - 1, c - l + 3, p), c = l + p.length - 2;
            break;
          }
      }
    for (c = -1; ++c < a.length; )
      a[c][1].type === "strikethroughSequenceTemporary" && (a[c][1].type = "data");
    return a;
  }
  function o(a, s, c) {
    const l = this.previous, u = this.events;
    let d = 0;
    return p;
    function p(h) {
      return l === 126 && u[u.length - 1][1].type !== "characterEscape" ? c(h) : (a.enter("strikethroughSequenceTemporary"), f(h));
    }
    function f(h) {
      const m = lu(l);
      if (h === 126)
        return d > 1 ? c(h) : (a.consume(h), d++, f);
      if (d < 2 && !n)
        return c(h);
      const y = a.exit("strikethroughSequenceTemporary"), g = lu(h);
      return y._open = !g || g === 2 && !!m, y._close = !m || m === 2 && !!g, s(h);
    }
  }
}
class UL {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    BL(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImpl(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(o, a) {
      return o[0] - a[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(
        t.slice(this.map[n][0] + this.map[n][1]),
        this.map[n][2]
      ), t.length = this.map[n][0];
    r.push([...t]), t.length = 0;
    let i = r.pop();
    for (; i; )
      t.push(...i), i = r.pop();
    this.map.length = 0;
  }
}
function BL(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += n, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function zL(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(
          e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
        );
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const o = r.length - 1;
          r[o] = r[o] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else
      i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function ZL() {
  return {
    flow: {
      null: {
        tokenize: VL,
        resolveAll: HL
      }
    }
  };
}
function VL(e, t, n) {
  const r = this;
  let i = 0, o = 0, a;
  return s;
  function s(R) {
    let M = r.events.length - 1;
    for (; M > -1; ) {
      const L = r.events[M][1].type;
      if (L === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      L === "linePrefix")
        M--;
      else
        break;
    }
    const V = M > -1 ? r.events[M][1].type : null, U = V === "tableHead" || V === "tableRow" ? x : c;
    return U === x && r.parser.lazy[r.now().line] ? n(R) : U(R);
  }
  function c(R) {
    return e.enter("tableHead"), e.enter("tableRow"), l(R);
  }
  function l(R) {
    return R === 124 || (a = !0, o += 1), u(R);
  }
  function u(R) {
    return R === null ? n(R) : Ye(R) ? o > 1 ? (o = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(R), e.exit("lineEnding"), f) : n(R) : vt(R) ? Tt(e, u, "whitespace")(R) : (o += 1, a && (a = !1, i += 1), R === 124 ? (e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), a = !0, u) : (e.enter("data"), d(R)));
  }
  function d(R) {
    return R === null || R === 124 || Mt(R) ? (e.exit("data"), u(R)) : (e.consume(R), R === 92 ? p : d);
  }
  function p(R) {
    return R === 92 || R === 124 ? (e.consume(R), d) : d(R);
  }
  function f(R) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(R) : (e.enter("tableDelimiterRow"), a = !1, vt(R) ? Tt(
      e,
      h,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(R) : h(R));
  }
  function h(R) {
    return R === 45 || R === 58 ? y(R) : R === 124 ? (a = !0, e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), m) : S(R);
  }
  function m(R) {
    return vt(R) ? Tt(e, y, "whitespace")(R) : y(R);
  }
  function y(R) {
    return R === 58 ? (o += 1, a = !0, e.enter("tableDelimiterMarker"), e.consume(R), e.exit("tableDelimiterMarker"), g) : R === 45 ? (o += 1, g(R)) : R === null || Ye(R) ? _(R) : S(R);
  }
  function g(R) {
    return R === 45 ? (e.enter("tableDelimiterFiller"), v(R)) : S(R);
  }
  function v(R) {
    return R === 45 ? (e.consume(R), v) : R === 58 ? (a = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(R), e.exit("tableDelimiterMarker"), b) : (e.exit("tableDelimiterFiller"), b(R));
  }
  function b(R) {
    return vt(R) ? Tt(e, _, "whitespace")(R) : _(R);
  }
  function _(R) {
    return R === 124 ? h(R) : R === null || Ye(R) ? !a || i !== o ? S(R) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(R)) : S(R);
  }
  function S(R) {
    return n(R);
  }
  function x(R) {
    return e.enter("tableRow"), A(R);
  }
  function A(R) {
    return R === 124 ? (e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), A) : R === null || Ye(R) ? (e.exit("tableRow"), t(R)) : vt(R) ? Tt(e, A, "whitespace")(R) : (e.enter("data"), I(R));
  }
  function I(R) {
    return R === null || R === 124 || Mt(R) ? (e.exit("data"), A(R)) : (e.consume(R), R === 92 ? P : I);
  }
  function P(R) {
    return R === 92 || R === 124 ? (e.consume(R), I) : I(R);
  }
}
function HL(e, t) {
  let n = -1, r = !0, i = 0, o = [0, 0, 0, 0], a = [0, 0, 0, 0], s = !1, c = 0, l, u, d;
  const p = new UL();
  for (; ++n < e.length; ) {
    const f = e[n], h = f[1];
    f[0] === "enter" ? h.type === "tableHead" ? (s = !1, c !== 0 && (Bg(p, t, c, l, u), u = void 0, c = 0), l = {
      type: "table",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, p.add(n, 0, [["enter", l, t]])) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (r = !0, d = void 0, o = [0, 0, 0, 0], a = [0, n + 1, 0, 0], s && (s = !1, u = {
      type: "tableBody",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, p.add(n, 0, [["enter", u, t]])), i = h.type === "tableDelimiterRow" ? 2 : u ? 3 : 1) : i && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") ? (r = !1, a[2] === 0 && (o[1] !== 0 && (a[0] = a[1], d = Ec(
      p,
      t,
      o,
      i,
      void 0,
      d
    ), o = [0, 0, 0, 0]), a[2] = n)) : h.type === "tableCellDivider" && (r ? r = !1 : (o[1] !== 0 && (a[0] = a[1], d = Ec(
      p,
      t,
      o,
      i,
      void 0,
      d
    )), o = a, a = [o[1], n, 0, 0])) : h.type === "tableHead" ? (s = !0, c = n) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (c = n, o[1] !== 0 ? (a[0] = a[1], d = Ec(
      p,
      t,
      o,
      i,
      n,
      d
    )) : a[1] !== 0 && (d = Ec(p, t, a, i, n, d)), i = 0) : i && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") && (a[3] = n);
  }
  for (c !== 0 && Bg(p, t, c, l, u), p.consume(t.events), n = -1; ++n < t.events.length; ) {
    const f = t.events[n];
    f[0] === "enter" && f[1].type === "table" && (f[1]._align = zL(t.events, n));
  }
  return e;
}
function Ec(e, t, n, r, i, o) {
  const a = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", s = "tableContent";
  n[0] !== 0 && (o.end = Object.assign({}, Zo(t.events, n[0])), e.add(n[0], 0, [["exit", o, t]]));
  const c = Zo(t.events, n[1]);
  if (o = {
    type: a,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, e.add(n[1], 0, [["enter", o, t]]), n[2] !== 0) {
    const l = Zo(t.events, n[2]), u = Zo(t.events, n[3]), d = {
      type: s,
      start: Object.assign({}, l),
      end: Object.assign({}, u)
    };
    if (e.add(n[2], 0, [["enter", d, t]]), r !== 2) {
      const p = t.events[n[2]], f = t.events[n[3]];
      if (p[1].end = Object.assign({}, f[1].end), p[1].type = "chunkText", p[1].contentType = "text", n[3] > n[2] + 1) {
        const h = n[2] + 1, m = n[3] - n[2] - 1;
        e.add(h, m, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", d, t]]);
  }
  return i !== void 0 && (o.end = Object.assign({}, Zo(t.events, i)), e.add(i, 0, [["exit", o, t]]), o = void 0), o;
}
function Bg(e, t, n, r, i) {
  const o = [], a = Zo(t.events, n);
  i && (i.end = Object.assign({}, a), o.push(["exit", i, t])), r.end = Object.assign({}, a), o.push(["exit", r, t]), e.add(n + 1, 0, o);
}
function Zo(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const WL = {
  tokenize: JL
};
function KL() {
  return {
    text: {
      91: WL
    }
  };
}
function JL(e, t, n) {
  const r = this;
  return i;
  function i(c) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), o)
    );
  }
  function o(c) {
    return Mt(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), a) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), a) : n(c);
  }
  function a(c) {
    return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), s) : n(c);
  }
  function s(c) {
    return Ye(c) ? t(c) : vt(c) ? e.check(
      {
        tokenize: YL
      },
      t,
      n
    )(c) : n(c);
  }
}
function YL(e, t, n) {
  return Tt(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function GL(e) {
  return Z1([
    _L(),
    PL(),
    FL(e),
    ZL(),
    KL()
  ]);
}
const XL = {};
function QL(e) {
  const t = (
    /** @type {Processor} */
    this
  ), n = e || XL, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), o = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), a = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(GL(n)), o.push(vL()), a.push(bL(n));
}
const eF = ({ text: e, type: t, styles: n }) => {
  const r = n == null ? void 0 : n[t], i = {
    h1: ({ node: o, ...a }) => /* @__PURE__ */ F.jsx("h1", { ...a, ...r == null ? void 0 : r.heading1 }),
    h2: ({ node: o, ...a }) => /* @__PURE__ */ F.jsx("h2", { ...a, ...r == null ? void 0 : r.heading2 }),
    h3: ({ node: o, ...a }) => /* @__PURE__ */ F.jsx("h3", { ...a, ...r == null ? void 0 : r.heading3 }),
    h4: "h3",
    h5: "h3",
    h6: "h3",
    em: ({ node: o, ...a }) => /* @__PURE__ */ F.jsx("em", { ...a, ...r == null ? void 0 : r.italic }),
    strong: ({ node: o, ...a }) => /* @__PURE__ */ F.jsx("strong", { ...a, ...r == null ? void 0 : r.bold }),
    p: ({ node: o, ...a }) => /* @__PURE__ */ F.jsx("p", { ...a, ...r == null ? void 0 : r.text }),
    hr: ({ node: o, ...a }) => /* @__PURE__ */ F.jsx("hr", { ...a, ...r == null ? void 0 : r.horizontalRule }),
    a: ({ node: o, ...a }) => /* @__PURE__ */ F.jsx("a", { ...a, ...r == null ? void 0 : r.link, target: "_blank" }),
    ol: ({ node: o, ...a }) => /* @__PURE__ */ F.jsx("ol", { ...a, ...r == null ? void 0 : r.orderedList }),
    ul: ({ node: o, ...a }) => /* @__PURE__ */ F.jsx("ul", { ...a, ...r == null ? void 0 : r.unorderedList }),
    li: ({ node: o, ...a }) => /* @__PURE__ */ F.jsx("li", { ...a, ...r == null ? void 0 : r.listItem }),
    br: ({ node: o, ...a }) => /* @__PURE__ */ F.jsx("br", { ...a, ...r == null ? void 0 : r.lineBreak }),
    img: () => null,
    pre: ({ node: o, ...a }) => /* @__PURE__ */ F.jsx("pre", { ...a, ...r == null ? void 0 : r.pre })
  };
  return /* @__PURE__ */ F.jsx(F2, { components: i, remarkPlugins: [QL, K2], children: e });
}, tF = (e, t, n = 120) => {
  Ne(() => {
    if (e) {
      e.style.height = "0px";
      const r = t ? Math.min(e.scrollHeight, n) : 20;
      e.style.height = `${r}px`;
    }
  }, [e, t]);
};
var NS = {}, $m = {}, jS = {};
Object.defineProperty(jS, "__esModule", { value: !0 });
var _d = {}, nF = it && it.__awaiter || function(e, t, n, r) {
  function i(o) {
    return o instanceof n ? o : new n(function(a) {
      a(o);
    });
  }
  return new (n || (n = Promise))(function(o, a) {
    function s(u) {
      try {
        l(r.next(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function l(u) {
      u.done ? o(u.value) : i(u.value).then(s, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
Object.defineProperty(_d, "__esModule", { value: !0 });
_d.Emitter = void 0;
let rF = class {
  constructor() {
    this.listeners = {};
  }
  on(t, n, r = !1) {
    const i = this.listeners[t];
    i ? r ? i.unshift(n) : i.push(n) : this.listeners[t] = [n];
  }
  emit(t, n) {
    return nF(this, void 0, void 0, function* () {
      const r = this.listeners[t];
      if (r != null && r.length) {
        for (const i of r)
          yield i(n);
        return !0;
      } else
        return !1;
    });
  }
};
_d.Emitter = rF;
var MS = {};
Object.defineProperty(MS, "__esModule", { value: !0 });
var qS = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.HealthEventType = void 0, function(t) {
    t.Create = "create", t.Configure = "configure", t.Start = "start", t.StartFailure = "start-failure", t.Initialize = "initialize", t.InitializeFailure = "initialize-failure", t.Sleep = "sleep", t.Delete = "delete";
  }(e.HealthEventType || (e.HealthEventType = {}));
})(qS);
var LS = {};
Object.defineProperty(LS, "__esModule", { value: !0 });
var FS = {};
Object.defineProperty(FS, "__esModule", { value: !0 });
var US = {};
Object.defineProperty(US, "__esModule", { value: !0 });
var BS = {};
Object.defineProperty(BS, "__esModule", { value: !0 });
(function(e) {
  var t = it && it.__createBinding || (Object.create ? function(r, i, o, a) {
    a === void 0 && (a = o), Object.defineProperty(r, a, { enumerable: !0, get: function() {
      return i[o];
    } });
  } : function(r, i, o, a) {
    a === void 0 && (a = o), r[a] = i[o];
  }), n = it && it.__exportStar || function(r, i) {
    for (var o in r)
      o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n(jS, e), n(_d, e), n(MS, e), n(qS, e), n(LS, e), n(FS, e), n(US, e), n(BS, e);
})($m);
var Sd = {}, zS = {}, jp = { exports: {} }, kd = {}, Dm = {}, Ed = {}, nc = {}, ma = {}, Io = {}, ja = {}, ya = {}, Vr = {};
Object.defineProperty(Vr, "__esModule", { value: !0 });
Vr.ERROR_PACKET = Vr.PACKET_TYPES_REVERSE = Vr.PACKET_TYPES = void 0;
const Hr = /* @__PURE__ */ Object.create(null);
Vr.PACKET_TYPES = Hr;
Hr.open = "0";
Hr.close = "1";
Hr.ping = "2";
Hr.pong = "3";
Hr.message = "4";
Hr.upgrade = "5";
Hr.noop = "6";
const ZS = /* @__PURE__ */ Object.create(null);
Vr.PACKET_TYPES_REVERSE = ZS;
Object.keys(Hr).forEach((e) => {
  ZS[Hr[e]] = e;
});
const iF = { type: "error", data: "parser error" };
Vr.ERROR_PACKET = iF;
Object.defineProperty(ya, "__esModule", { value: !0 });
ya.encodePacket = ya.encodePacketToBinary = void 0;
const oF = Vr, VS = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", HS = typeof ArrayBuffer == "function", WS = (e) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer, KS = ({ type: e, data: t }, n, r) => VS && t instanceof Blob ? n ? r(t) : zg(t, r) : HS && (t instanceof ArrayBuffer || WS(t)) ? n ? r(t) : zg(new Blob([t]), r) : r(oF.PACKET_TYPES[e] + (t || ""));
ya.encodePacket = KS;
const zg = (e, t) => {
  const n = new FileReader();
  return n.onload = function() {
    const r = n.result.split(",")[1];
    t("b" + (r || ""));
  }, n.readAsDataURL(e);
};
function Zg(e) {
  return e instanceof Uint8Array ? e : e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
}
let _f;
function aF(e, t) {
  if (VS && e.data instanceof Blob)
    return e.data.arrayBuffer().then(Zg).then(t);
  if (HS && (e.data instanceof ArrayBuffer || WS(e.data)))
    return t(Zg(e.data));
  KS(e, !1, (n) => {
    _f || (_f = new TextEncoder()), t(_f.encode(n));
  });
}
ya.encodePacketToBinary = aF;
var Cd = {}, ga = {};
Object.defineProperty(ga, "__esModule", { value: !0 });
ga.decode = ga.encode = void 0;
const Jo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ns = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let e = 0; e < Jo.length; e++)
  ns[Jo.charCodeAt(e)] = e;
const sF = (e) => {
  let t = new Uint8Array(e), n, r = t.length, i = "";
  for (n = 0; n < r; n += 3)
    i += Jo[t[n] >> 2], i += Jo[(t[n] & 3) << 4 | t[n + 1] >> 4], i += Jo[(t[n + 1] & 15) << 2 | t[n + 2] >> 6], i += Jo[t[n + 2] & 63];
  return r % 3 === 2 ? i = i.substring(0, i.length - 1) + "=" : r % 3 === 1 && (i = i.substring(0, i.length - 2) + "=="), i;
};
ga.encode = sF;
const cF = (e) => {
  let t = e.length * 0.75, n = e.length, r, i = 0, o, a, s, c;
  e[e.length - 1] === "=" && (t--, e[e.length - 2] === "=" && t--);
  const l = new ArrayBuffer(t), u = new Uint8Array(l);
  for (r = 0; r < n; r += 4)
    o = ns[e.charCodeAt(r)], a = ns[e.charCodeAt(r + 1)], s = ns[e.charCodeAt(r + 2)], c = ns[e.charCodeAt(r + 3)], u[i++] = o << 2 | a >> 4, u[i++] = (a & 15) << 4 | s >> 2, u[i++] = (s & 3) << 6 | c & 63;
  return l;
};
ga.decode = cF;
Object.defineProperty(Cd, "__esModule", { value: !0 });
Cd.decodePacket = void 0;
const Cc = Vr, lF = ga, uF = typeof ArrayBuffer == "function", dF = (e, t) => {
  if (typeof e != "string")
    return {
      type: "message",
      data: JS(e, t)
    };
  const n = e.charAt(0);
  return n === "b" ? {
    type: "message",
    data: fF(e.substring(1), t)
  } : Cc.PACKET_TYPES_REVERSE[n] ? e.length > 1 ? {
    type: Cc.PACKET_TYPES_REVERSE[n],
    data: e.substring(1)
  } : {
    type: Cc.PACKET_TYPES_REVERSE[n]
  } : Cc.ERROR_PACKET;
};
Cd.decodePacket = dF;
const fF = (e, t) => {
  if (uF) {
    const n = (0, lF.decode)(e);
    return JS(n, t);
  } else
    return { base64: !0, data: e };
}, JS = (e, t) => {
  switch (t) {
    case "blob":
      return e instanceof Blob ? e : new Blob([e]);
    case "arraybuffer":
    default:
      return e instanceof ArrayBuffer ? e : e.buffer;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.decodePayload = e.decodePacket = e.encodePayload = e.encodePacket = e.protocol = e.createPacketDecoderStream = e.createPacketEncoderStream = void 0;
  const t = ya;
  Object.defineProperty(e, "encodePacket", { enumerable: !0, get: function() {
    return t.encodePacket;
  } });
  const n = Cd;
  Object.defineProperty(e, "decodePacket", { enumerable: !0, get: function() {
    return n.decodePacket;
  } });
  const r = Vr, i = String.fromCharCode(30), o = (p, f) => {
    const h = p.length, m = new Array(h);
    let y = 0;
    p.forEach((g, v) => {
      (0, t.encodePacket)(g, !1, (b) => {
        m[v] = b, ++y === h && f(m.join(i));
      });
    });
  };
  e.encodePayload = o;
  const a = (p, f) => {
    const h = p.split(i), m = [];
    for (let y = 0; y < h.length; y++) {
      const g = (0, n.decodePacket)(h[y], f);
      if (m.push(g), g.type === "error")
        break;
    }
    return m;
  };
  e.decodePayload = a;
  function s() {
    return new TransformStream({
      transform(p, f) {
        (0, t.encodePacketToBinary)(p, (h) => {
          const m = h.length;
          let y;
          if (m < 126)
            y = new Uint8Array(1), new DataView(y.buffer).setUint8(0, m);
          else if (m < 65536) {
            y = new Uint8Array(3);
            const g = new DataView(y.buffer);
            g.setUint8(0, 126), g.setUint16(1, m);
          } else {
            y = new Uint8Array(9);
            const g = new DataView(y.buffer);
            g.setUint8(0, 127), g.setBigUint64(1, BigInt(m));
          }
          p.data && typeof p.data != "string" && (y[0] |= 128), f.enqueue(y), f.enqueue(h);
        });
      }
    });
  }
  e.createPacketEncoderStream = s;
  let c;
  function l(p) {
    return p.reduce((f, h) => f + h.length, 0);
  }
  function u(p, f) {
    if (p[0].length === f)
      return p.shift();
    const h = new Uint8Array(f);
    let m = 0;
    for (let y = 0; y < f; y++)
      h[y] = p[0][m++], m === p[0].length && (p.shift(), m = 0);
    return p.length && m < p[0].length && (p[0] = p[0].slice(m)), h;
  }
  function d(p, f) {
    c || (c = new TextDecoder());
    const h = [];
    let m = 0, y = -1, g = !1;
    return new TransformStream({
      transform(v, b) {
        for (h.push(v); ; ) {
          if (m === 0) {
            if (l(h) < 1)
              break;
            const _ = u(h, 1);
            g = (_[0] & 128) === 128, y = _[0] & 127, y < 126 ? m = 3 : y === 126 ? m = 1 : m = 2;
          } else if (m === 1) {
            if (l(h) < 2)
              break;
            const _ = u(h, 2);
            y = new DataView(_.buffer, _.byteOffset, _.length).getUint16(0), m = 3;
          } else if (m === 2) {
            if (l(h) < 8)
              break;
            const _ = u(h, 8), S = new DataView(_.buffer, _.byteOffset, _.length), x = S.getUint32(0);
            if (x > Math.pow(2, 53 - 32) - 1) {
              b.enqueue(r.ERROR_PACKET);
              break;
            }
            y = x * Math.pow(2, 32) + S.getUint32(4), m = 3;
          } else {
            if (l(h) < y)
              break;
            const _ = u(h, y);
            b.enqueue((0, n.decodePacket)(g ? _ : c.decode(_), f)), m = 0;
          }
          if (y === 0 || y > p) {
            b.enqueue(r.ERROR_PACKET);
            break;
          }
        }
      }
    });
  }
  e.createPacketDecoderStream = d, e.protocol = 4;
})(ja);
function Zn(e) {
  if (e)
    return pF(e);
}
function pF(e) {
  for (var t in Zn.prototype)
    e[t] = Zn.prototype[t];
  return e;
}
Zn.prototype.on = Zn.prototype.addEventListener = function(e, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this;
};
Zn.prototype.once = function(e, t) {
  function n() {
    this.off(e, n), t.apply(this, arguments);
  }
  return n.fn = t, this.on(e, n), this;
};
Zn.prototype.off = Zn.prototype.removeListener = Zn.prototype.removeAllListeners = Zn.prototype.removeEventListener = function(e, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var n = this._callbacks["$" + e];
  if (!n)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + e], this;
  for (var r, i = 0; i < n.length; i++)
    if (r = n[i], r === t || r.fn === t) {
      n.splice(i, 1);
      break;
    }
  return n.length === 0 && delete this._callbacks["$" + e], this;
};
Zn.prototype.emit = function(e) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), n = this._callbacks["$" + e], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  if (n) {
    n = n.slice(0);
    for (var r = 0, i = n.length; r < i; ++r)
      n[r].apply(this, t);
  }
  return this;
};
Zn.prototype.emitReserved = Zn.prototype.emit;
Zn.prototype.listeners = function(e) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + e] || [];
};
Zn.prototype.hasListeners = function(e) {
  return !!this.listeners(e).length;
};
const hF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Emitter: Zn
}, Symbol.toStringTag, { value: "Module" })), Ma = /* @__PURE__ */ vh(hF);
var yr = {}, Po = {};
Object.defineProperty(Po, "__esModule", { value: !0 });
Po.globalThisShim = void 0;
Po.globalThisShim = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
Object.defineProperty(yr, "__esModule", { value: !0 });
yr.byteLength = yr.installTimerFunctions = yr.pick = void 0;
const Ci = Po;
function mF(e, ...t) {
  return t.reduce((n, r) => (e.hasOwnProperty(r) && (n[r] = e[r]), n), {});
}
yr.pick = mF;
const yF = Ci.globalThisShim.setTimeout, gF = Ci.globalThisShim.clearTimeout;
function vF(e, t) {
  t.useNativeTimers ? (e.setTimeoutFn = yF.bind(Ci.globalThisShim), e.clearTimeoutFn = gF.bind(Ci.globalThisShim)) : (e.setTimeoutFn = Ci.globalThisShim.setTimeout.bind(Ci.globalThisShim), e.clearTimeoutFn = Ci.globalThisShim.clearTimeout.bind(Ci.globalThisShim));
}
yr.installTimerFunctions = vF;
const bF = 1.33;
function wF(e) {
  return typeof e == "string" ? xF(e) : Math.ceil((e.byteLength || e.size) * bF);
}
yr.byteLength = wF;
function xF(e) {
  let t = 0, n = 0;
  for (let r = 0, i = e.length; r < i; r++)
    t = e.charCodeAt(r), t < 128 ? n += 1 : t < 2048 ? n += 2 : t < 55296 || t >= 57344 ? n += 3 : (r++, n += 4);
  return n;
}
var Mp = { exports: {} }, Sf, Vg;
function _F() {
  if (Vg)
    return Sf;
  Vg = 1;
  var e = 1e3, t = e * 60, n = t * 60, r = n * 24, i = r * 7, o = r * 365.25;
  Sf = function(u, d) {
    d = d || {};
    var p = typeof u;
    if (p === "string" && u.length > 0)
      return a(u);
    if (p === "number" && isFinite(u))
      return d.long ? c(u) : s(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function a(u) {
    if (u = String(u), !(u.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (d) {
        var p = parseFloat(d[1]), f = (d[2] || "ms").toLowerCase();
        switch (f) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * o;
          case "weeks":
          case "week":
          case "w":
            return p * i;
          case "days":
          case "day":
          case "d":
            return p * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function s(u) {
    var d = Math.abs(u);
    return d >= r ? Math.round(u / r) + "d" : d >= n ? Math.round(u / n) + "h" : d >= t ? Math.round(u / t) + "m" : d >= e ? Math.round(u / e) + "s" : u + "ms";
  }
  function c(u) {
    var d = Math.abs(u);
    return d >= r ? l(u, d, r, "day") : d >= n ? l(u, d, n, "hour") : d >= t ? l(u, d, t, "minute") : d >= e ? l(u, d, e, "second") : u + " ms";
  }
  function l(u, d, p, f) {
    var h = d >= p * 1.5;
    return Math.round(u / p) + " " + f + (h ? "s" : "");
  }
  return Sf;
}
function SF(e) {
  n.debug = n, n.default = n, n.coerce = c, n.disable = o, n.enable = i, n.enabled = a, n.humanize = _F(), n.destroy = l, Object.keys(e).forEach((u) => {
    n[u] = e[u];
  }), n.names = [], n.skips = [], n.formatters = {};
  function t(u) {
    let d = 0;
    for (let p = 0; p < u.length; p++)
      d = (d << 5) - d + u.charCodeAt(p), d |= 0;
    return n.colors[Math.abs(d) % n.colors.length];
  }
  n.selectColor = t;
  function n(u) {
    let d, p = null, f, h;
    function m(...y) {
      if (!m.enabled)
        return;
      const g = m, v = Number(/* @__PURE__ */ new Date()), b = v - (d || v);
      g.diff = b, g.prev = d, g.curr = v, d = v, y[0] = n.coerce(y[0]), typeof y[0] != "string" && y.unshift("%O");
      let _ = 0;
      y[0] = y[0].replace(/%([a-zA-Z%])/g, (x, A) => {
        if (x === "%%")
          return "%";
        _++;
        const I = n.formatters[A];
        if (typeof I == "function") {
          const P = y[_];
          x = I.call(g, P), y.splice(_, 1), _--;
        }
        return x;
      }), n.formatArgs.call(g, y), (g.log || n.log).apply(g, y);
    }
    return m.namespace = u, m.useColors = n.useColors(), m.color = n.selectColor(u), m.extend = r, m.destroy = n.destroy, Object.defineProperty(m, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (f !== n.namespaces && (f = n.namespaces, h = n.enabled(u)), h),
      set: (y) => {
        p = y;
      }
    }), typeof n.init == "function" && n.init(m), m;
  }
  function r(u, d) {
    const p = n(this.namespace + (typeof d > "u" ? ":" : d) + u);
    return p.log = this.log, p;
  }
  function i(u) {
    n.save(u), n.namespaces = u, n.names = [], n.skips = [];
    let d;
    const p = (typeof u == "string" ? u : "").split(/[\s,]+/), f = p.length;
    for (d = 0; d < f; d++)
      p[d] && (u = p[d].replace(/\*/g, ".*?"), u[0] === "-" ? n.skips.push(new RegExp("^" + u.slice(1) + "$")) : n.names.push(new RegExp("^" + u + "$")));
  }
  function o() {
    const u = [
      ...n.names.map(s),
      ...n.skips.map(s).map((d) => "-" + d)
    ].join(",");
    return n.enable(""), u;
  }
  function a(u) {
    if (u[u.length - 1] === "*")
      return !0;
    let d, p;
    for (d = 0, p = n.skips.length; d < p; d++)
      if (n.skips[d].test(u))
        return !1;
    for (d = 0, p = n.names.length; d < p; d++)
      if (n.names[d].test(u))
        return !0;
    return !1;
  }
  function s(u) {
    return u.toString().substring(2, u.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function c(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function l() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return n.enable(n.load()), n;
}
var kF = SF;
(function(e, t) {
  t.formatArgs = r, t.save = i, t.load = o, t.useColors = n, t.storage = a(), t.destroy = (() => {
    let c = !1;
    return () => {
      c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function n() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function r(c) {
    if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const l = "color: " + this.color;
    c.splice(1, 0, l, "color: inherit");
    let u = 0, d = 0;
    c[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (u++, p === "%c" && (d = u));
    }), c.splice(d, 0, l);
  }
  t.log = console.debug || console.log || (() => {
  });
  function i(c) {
    try {
      c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function o() {
    let c;
    try {
      c = t.storage.getItem("debug");
    } catch {
    }
    return !c && typeof process < "u" && "env" in process && (c = process.env.DEBUG), c;
  }
  function a() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = kF(t);
  const { formatters: s } = e.exports;
  s.j = function(c) {
    try {
      return JSON.stringify(c);
    } catch (l) {
      return "[UnexpectedJSONParseError]: " + l.message;
    }
  };
})(Mp, Mp.exports);
var Xr = Mp.exports, wo = {};
Object.defineProperty(wo, "__esModule", { value: !0 });
wo.decode = wo.encode = void 0;
function EF(e) {
  let t = "";
  for (let n in e)
    e.hasOwnProperty(n) && (t.length && (t += "&"), t += encodeURIComponent(n) + "=" + encodeURIComponent(e[n]));
  return t;
}
wo.encode = EF;
function CF(e) {
  let t = {}, n = e.split("&");
  for (let r = 0, i = n.length; r < i; r++) {
    let o = n[r].split("=");
    t[decodeURIComponent(o[0])] = decodeURIComponent(o[1]);
  }
  return t;
}
wo.decode = CF;
var TF = it && it.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Io, "__esModule", { value: !0 });
Io.Transport = void 0;
const RF = ja, AF = Ma, OF = yr, IF = TF(Xr), PF = wo, $F = (0, IF.default)("engine.io-client:transport");
class DF extends Error {
  constructor(t, n, r) {
    super(t), this.description = n, this.context = r, this.type = "TransportError";
  }
}
class NF extends AF.Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(t) {
    super(), this.writable = !1, (0, OF.installTimerFunctions)(this, t), this.opts = t, this.query = t.query, this.socket = t.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(t, n, r) {
    return super.emitReserved("error", new DF(t, n, r)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(t) {
    this.readyState === "open" ? this.write(t) : $F("transport is not open, discarding packets");
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(t) {
    const n = (0, RF.decodePacket)(t, this.socket.binaryType);
    this.onPacket(n);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(t) {
  }
  createUri(t, n = {}) {
    return t + "://" + this._hostname() + this._port() + this.opts.path + this._query(n);
  }
  _hostname() {
    const t = this.opts.hostname;
    return t.indexOf(":") === -1 ? t : "[" + t + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(t) {
    const n = (0, PF.encode)(t);
    return n.length ? "?" + n : "";
  }
}
Io.Transport = NF;
var si = {};
Object.defineProperty(si, "__esModule", { value: !0 });
si.yeast = si.decode = si.encode = void 0;
const YS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), pu = 64, GS = {};
let Hg = 0, Ii = 0, Wg;
function qp(e) {
  let t = "";
  do
    t = YS[e % pu] + t, e = Math.floor(e / pu);
  while (e > 0);
  return t;
}
si.encode = qp;
function jF(e) {
  let t = 0;
  for (Ii = 0; Ii < e.length; Ii++)
    t = t * pu + GS[e.charAt(Ii)];
  return t;
}
si.decode = jF;
function MF() {
  const e = qp(+/* @__PURE__ */ new Date());
  return e !== Wg ? (Hg = 0, Wg = e) : e + "." + qp(Hg++);
}
si.yeast = MF;
for (; Ii < pu; Ii++)
  GS[YS[Ii]] = Ii;
var va = {}, Td = {};
Object.defineProperty(Td, "__esModule", { value: !0 });
Td.hasCORS = void 0;
let XS = !1;
try {
  XS = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
Td.hasCORS = XS;
Object.defineProperty(va, "__esModule", { value: !0 });
va.createCookieJar = va.XHR = void 0;
const qF = Td, LF = Po;
function FF(e) {
  const t = e.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || qF.hasCORS))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new LF.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
va.XHR = FF;
function UF() {
}
va.createCookieJar = UF;
var BF = it && it.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ma, "__esModule", { value: !0 });
ma.Request = ma.Polling = void 0;
const zF = Io, ZF = BF(Xr), VF = si, Kg = ja, Nm = va, HF = Ma, Jg = yr, WF = Po, Gn = (0, ZF.default)("engine.io-client:polling");
function KF() {
}
const JF = function() {
  return new Nm.XHR({
    xdomain: !1
  }).responseType != null;
}();
class YF extends zF.Transport {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(t) {
    if (super(t), this.polling = !1, typeof location < "u") {
      const r = location.protocol === "https:";
      let i = location.port;
      i || (i = r ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || i !== t.port;
    }
    const n = t && t.forceBase64;
    this.supportsBinary = JF && !n, this.opts.withCredentials && (this.cookieJar = (0, Nm.createCookieJar)());
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(t) {
    this.readyState = "pausing";
    const n = () => {
      Gn("paused"), this.readyState = "paused", t();
    };
    if (this.polling || !this.writable) {
      let r = 0;
      this.polling && (Gn("we are currently polling - waiting to pause"), r++, this.once("pollComplete", function() {
        Gn("pre-pause polling complete"), --r || n();
      })), this.writable || (Gn("we are currently writing - waiting to pause"), r++, this.once("drain", function() {
        Gn("pre-pause writing complete"), --r || n();
      }));
    } else
      n();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  poll() {
    Gn("polling"), this.polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(t) {
    Gn("polling got data %s", t);
    const n = (r) => {
      if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(r);
    };
    (0, Kg.decodePayload)(t, this.socket.binaryType).forEach(n), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" ? this.poll() : Gn('ignoring poll - transport state "%s"', this.readyState));
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const t = () => {
      Gn("writing close packet"), this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? (Gn("transport open - closing"), t()) : (Gn("transport not open - deferring close"), this.once("open", t));
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(t) {
    this.writable = !1, (0, Kg.encodePayload)(t, (n) => {
      this.doWrite(n, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "https" : "http", n = this.query || {};
    return this.opts.timestampRequests !== !1 && (n[this.opts.timestampParam] = (0, VF.yeast)()), !this.supportsBinary && !n.sid && (n.b64 = 1), this.createUri(t, n);
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @private
   */
  request(t = {}) {
    return Object.assign(t, { xd: this.xd, cookieJar: this.cookieJar }, this.opts), new lo(this.uri(), t);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(t, n) {
    const r = this.request({
      method: "POST",
      data: t
    });
    r.on("success", n), r.on("error", (i, o) => {
      this.onError("xhr post error", i, o);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    Gn("xhr poll");
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (n, r) => {
      this.onError("xhr poll error", n, r);
    }), this.pollXhr = t;
  }
}
ma.Polling = YF;
let lo = class Gc extends HF.Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(t, n) {
    super(), (0, Jg.installTimerFunctions)(this, n), this.opts = n, this.method = n.method || "GET", this.uri = t, this.data = n.data !== void 0 ? n.data : null, this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  create() {
    var t;
    const n = (0, Jg.pick)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    n.xdomain = !!this.opts.xd;
    const r = this.xhr = new Nm.XHR(n);
    try {
      Gn("xhr open %s: %s", this.method, this.uri), r.open(this.method, this.uri, !0);
      try {
        if (this.opts.extraHeaders) {
          r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0);
          for (let i in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(i) && r.setRequestHeader(i, this.opts.extraHeaders[i]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          r.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        r.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (t = this.opts.cookieJar) === null || t === void 0 || t.addCookies(r), "withCredentials" in r && (r.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (r.timeout = this.opts.requestTimeout), r.onreadystatechange = () => {
        var i;
        r.readyState === 3 && ((i = this.opts.cookieJar) === null || i === void 0 || i.parseCookies(r)), r.readyState === 4 && (r.status === 200 || r.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof r.status == "number" ? r.status : 0);
        }, 0));
      }, Gn("xhr data %s", this.data), r.send(this.data);
    } catch (i) {
      this.setTimeoutFn(() => {
        this.onError(i);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = Gc.requestsCount++, Gc.requests[this.index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  onError(t) {
    this.emitReserved("error", t, this.xhr), this.cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  cleanup(t) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = KF, t)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Gc.requests[this.index], this.xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  onLoad() {
    const t = this.xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this.cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this.cleanup();
  }
};
ma.Request = lo;
lo.requestsCount = 0;
lo.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", Yg);
  else if (typeof addEventListener == "function") {
    const e = "onpagehide" in WF.globalThisShim ? "pagehide" : "unload";
    addEventListener(e, Yg, !1);
  }
}
function Yg() {
  for (let e in lo.requests)
    lo.requests.hasOwnProperty(e) && lo.requests[e].abort();
}
var Rd = {}, ar = {};
Object.defineProperty(ar, "__esModule", { value: !0 });
ar.defaultBinaryType = ar.usingBrowserWebSocket = ar.WebSocket = ar.nextTick = void 0;
const Gg = Po;
ar.nextTick = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, n) => n(t, 0))();
ar.WebSocket = Gg.globalThisShim.WebSocket || Gg.globalThisShim.MozWebSocket;
ar.usingBrowserWebSocket = !0;
ar.defaultBinaryType = "arraybuffer";
var GF = it && it.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Rd, "__esModule", { value: !0 });
Rd.WS = void 0;
const XF = Io, QF = si, e3 = yr, Si = ar, t3 = GF(Xr), n3 = ja, r3 = (0, t3.default)("engine.io-client:websocket"), Xg = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class i3 extends XF.Transport {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  constructor(t) {
    super(t), this.supportsBinary = !t.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check())
      return;
    const t = this.uri(), n = this.opts.protocols, r = Xg ? {} : (0, e3.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
    try {
      this.ws = Si.usingBrowserWebSocket && !Xg ? n ? new Si.WebSocket(t, n) : new Si.WebSocket(t) : new Si.WebSocket(t, n, r);
    } catch (i) {
      return this.emitReserved("error", i);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let n = 0; n < t.length; n++) {
      const r = t[n], i = n === t.length - 1;
      (0, n3.encodePacket)(r, this.supportsBinary, (o) => {
        const a = {};
        Si.usingBrowserWebSocket || (r.options && (a.compress = r.options.compress), this.opts.perMessageDeflate && // @ts-ignore
        (typeof o == "string" ? Buffer.byteLength(o) : o.length) < this.opts.perMessageDeflate.threshold && (a.compress = !1));
        try {
          Si.usingBrowserWebSocket ? this.ws.send(o) : this.ws.send(o, a);
        } catch {
          r3("websocket closed before onclose event");
        }
        i && (0, Si.nextTick)(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "wss" : "ws", n = this.query || {};
    return this.opts.timestampRequests && (n[this.opts.timestampParam] = (0, QF.yeast)()), this.supportsBinary || (n.b64 = 1), this.createUri(t, n);
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @private
   */
  check() {
    return !!Si.WebSocket;
  }
}
Rd.WS = i3;
var Ad = {}, o3 = it && it.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ad, "__esModule", { value: !0 });
Ad.WT = void 0;
const a3 = Io, s3 = ar, Qg = ja, c3 = o3(Xr), Ha = (0, c3.default)("engine.io-client:webtransport");
class l3 extends a3.Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    typeof WebTransport == "function" && (this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]), this.transport.closed.then(() => {
      Ha("transport closed gracefully"), this.onClose();
    }).catch((t) => {
      Ha("transport closed due to %s", t), this.onError("webtransport error", t);
    }), this.transport.ready.then(() => {
      this.transport.createBidirectionalStream().then((t) => {
        const n = (0, Qg.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType), r = t.readable.pipeThrough(n).getReader(), i = (0, Qg.createPacketEncoderStream)();
        i.readable.pipeTo(t.writable), this.writer = i.writable.getWriter();
        const o = () => {
          r.read().then(({ done: s, value: c }) => {
            if (s) {
              Ha("session is closed");
              return;
            }
            Ha("received chunk: %o", c), this.onPacket(c), o();
          }).catch((s) => {
            Ha("an error occurred while reading: %s", s);
          });
        };
        o();
        const a = { type: "open" };
        this.query.sid && (a.data = `{"sid":"${this.query.sid}"}`), this.writer.write(a).then(() => this.onOpen());
      });
    }));
  }
  write(t) {
    this.writable = !1;
    for (let n = 0; n < t.length; n++) {
      const r = t[n], i = n === t.length - 1;
      this.writer.write(r).then(() => {
        i && (0, s3.nextTick)(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var t;
    (t = this.transport) === null || t === void 0 || t.close();
  }
}
Ad.WT = l3;
Object.defineProperty(nc, "__esModule", { value: !0 });
nc.transports = void 0;
const u3 = ma, d3 = Rd, f3 = Ad;
nc.transports = {
  websocket: d3.WS,
  webtransport: f3.WT,
  polling: u3.Polling
};
var rc = {};
Object.defineProperty(rc, "__esModule", { value: !0 });
rc.parse = void 0;
const p3 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, h3 = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function m3(e) {
  const t = e, n = e.indexOf("["), r = e.indexOf("]");
  n != -1 && r != -1 && (e = e.substring(0, n) + e.substring(n, r).replace(/:/g, ";") + e.substring(r, e.length));
  let i = p3.exec(e || ""), o = {}, a = 14;
  for (; a--; )
    o[h3[a]] = i[a] || "";
  return n != -1 && r != -1 && (o.source = t, o.host = o.host.substring(1, o.host.length - 1).replace(/;/g, ":"), o.authority = o.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), o.ipv6uri = !0), o.pathNames = y3(o, o.path), o.queryKey = g3(o, o.query), o;
}
rc.parse = m3;
function y3(e, t) {
  const n = /\/{2,9}/g, r = t.replace(n, "/").split("/");
  return (t.slice(0, 1) == "/" || t.length === 0) && r.splice(0, 1), t.slice(-1) == "/" && r.splice(r.length - 1, 1), r;
}
function g3(e, t) {
  const n = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, i, o) {
    i && (n[i] = o);
  }), n;
}
var v3 = it && it.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ed, "__esModule", { value: !0 });
Ed.Socket = void 0;
const b3 = nc, ev = yr, w3 = wo, tv = rc, x3 = v3(Xr), _3 = Ma, QS = ja, S3 = ar, Vt = (0, x3.default)("engine.io-client:socket");
let ek = class Vo extends _3.Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(t, n = {}) {
    super(), this.binaryType = S3.defaultBinaryType, this.writeBuffer = [], t && typeof t == "object" && (n = t, t = null), t ? (t = (0, tv.parse)(t), n.hostname = t.host, n.secure = t.protocol === "https" || t.protocol === "wss", n.port = t.port, t.query && (n.query = t.query)) : n.host && (n.hostname = (0, tv.parse)(n.host).host), (0, ev.installTimerFunctions)(this, n), this.secure = n.secure != null ? n.secure : typeof location < "u" && location.protocol === "https:", n.hostname && !n.port && (n.port = this.secure ? "443" : "80"), this.hostname = n.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = n.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = n.transports || [
      "polling",
      "websocket",
      "webtransport"
    ], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, n), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = (0, w3.decode)(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, !1))), this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(t) {
    Vt('creating transport "%s"', t);
    const n = Object.assign({}, this.opts.query);
    n.EIO = QS.protocol, n.transport = t, this.id && (n.sid = this.id);
    const r = Object.assign({}, this.opts, {
      query: n,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[t]);
    return Vt("options: %j", r), new b3.transports[t](r);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  open() {
    let t;
    if (this.opts.rememberUpgrade && Vo.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      t = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      t = this.transports[0];
    this.readyState = "opening";
    try {
      t = this.createTransport(t);
    } catch (n) {
      Vt("error while creating transport: %s", n), this.transports.shift(), this.open();
      return;
    }
    t.open(), this.setTransport(t);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(t) {
    Vt("setting transport %s", t.name), this.transport && (Vt("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = t, t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (n) => this.onClose("transport close", n));
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  probe(t) {
    Vt('probing transport "%s"', t);
    let n = this.createTransport(t), r = !1;
    Vo.priorWebsocketSuccess = !1;
    const i = () => {
      r || (Vt('probe transport "%s" opened', t), n.send([{ type: "ping", data: "probe" }]), n.once("packet", (d) => {
        if (!r)
          if (d.type === "pong" && d.data === "probe") {
            if (Vt('probe transport "%s" pong', t), this.upgrading = !0, this.emitReserved("upgrading", n), !n)
              return;
            Vo.priorWebsocketSuccess = n.name === "websocket", Vt('pausing current transport "%s"', this.transport.name), this.transport.pause(() => {
              r || this.readyState !== "closed" && (Vt("changing transport and sending upgrade packet"), u(), this.setTransport(n), n.send([{ type: "upgrade" }]), this.emitReserved("upgrade", n), n = null, this.upgrading = !1, this.flush());
            });
          } else {
            Vt('probe transport "%s" failed', t);
            const p = new Error("probe error");
            p.transport = n.name, this.emitReserved("upgradeError", p);
          }
      }));
    };
    function o() {
      r || (r = !0, u(), n.close(), n = null);
    }
    const a = (d) => {
      const p = new Error("probe error: " + d);
      p.transport = n.name, o(), Vt('probe transport "%s" failed because of error: %s', t, d), this.emitReserved("upgradeError", p);
    };
    function s() {
      a("transport closed");
    }
    function c() {
      a("socket closed");
    }
    function l(d) {
      n && d.name !== n.name && (Vt('"%s" works - aborting "%s"', d.name, n.name), o());
    }
    const u = () => {
      n.removeListener("open", i), n.removeListener("error", a), n.removeListener("close", s), this.off("close", c), this.off("upgrading", l);
    };
    n.once("open", i), n.once("error", a), n.once("close", s), this.once("close", c), this.once("upgrading", l), this.upgrades.indexOf("webtransport") !== -1 && t !== "webtransport" ? this.setTimeoutFn(() => {
      r || n.open();
    }, 200) : n.open();
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    if (Vt("socket open"), this.readyState = "open", Vo.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade) {
      Vt("starting upgrade probes");
      let t = 0;
      const n = this.upgrades.length;
      for (; t < n; t++)
        this.probe(this.upgrades[t]);
    }
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (Vt('socket receive: type "%s", data "%s"', t.type, t.data), this.emitReserved("packet", t), this.emitReserved("heartbeat"), this.resetPingTimeout(), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const n = new Error("server error");
          n.code = t.data, this.onError(n);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
    else
      Vt('packet received with socket readyState "%s"', this.readyState);
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this.getWritablePackets();
      Vt("flushing %d packets in socket", t.length), this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let n = 1;
    for (let r = 0; r < this.writeBuffer.length; r++) {
      const i = this.writeBuffer[r].data;
      if (i && (n += (0, ev.byteLength)(i)), r > 0 && n > this.maxPayload)
        return Vt("only send %d out of %d packets", r, this.writeBuffer.length), this.writeBuffer.slice(0, r);
      n += 2;
    }
    return Vt("payload size is %d (max: %d)", n, this.maxPayload), this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} callback function.
   * @return {Socket} for chaining.
   */
  write(t, n, r) {
    return this.sendPacket("message", t, n, r), this;
  }
  send(t, n, r) {
    return this.sendPacket("message", t, n, r), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  sendPacket(t, n, r, i) {
    if (typeof n == "function" && (i = n, n = void 0), typeof r == "function" && (i = r, r = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    r = r || {}, r.compress = r.compress !== !1;
    const o = {
      type: t,
      data: n,
      options: r
    };
    this.emitReserved("packetCreate", o), this.writeBuffer.push(o), i && this.once("flush", i), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const t = () => {
      this.onClose("forced close"), Vt("socket closing - telling transport to close"), this.transport.close();
    }, n = () => {
      this.off("upgrade", n), this.off("upgradeError", n), t();
    }, r = () => {
      this.once("upgrade", n), this.once("upgradeError", n);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? r() : t();
    }) : this.upgrading ? r() : t()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  onError(t) {
    Vt("socket error %j", t), Vo.priorWebsocketSuccess = !1, this.emitReserved("error", t), this.onClose("transport error", t);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  onClose(t, n) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (Vt('socket close with reason: "%s"', t), this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", t, n), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  filterUpgrades(t) {
    const n = [];
    let r = 0;
    const i = t.length;
    for (; r < i; r++)
      ~this.transports.indexOf(t[r]) && n.push(t[r]);
    return n;
  }
};
Ed.Socket = ek;
ek.protocol = QS.protocol;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.nextTick = e.parse = e.installTimerFunctions = e.transports = e.Transport = e.protocol = e.Socket = void 0;
  const t = Ed;
  Object.defineProperty(e, "Socket", { enumerable: !0, get: function() {
    return t.Socket;
  } }), e.protocol = t.Socket.protocol;
  var n = Io;
  Object.defineProperty(e, "Transport", { enumerable: !0, get: function() {
    return n.Transport;
  } });
  var r = nc;
  Object.defineProperty(e, "transports", { enumerable: !0, get: function() {
    return r.transports;
  } });
  var i = yr;
  Object.defineProperty(e, "installTimerFunctions", { enumerable: !0, get: function() {
    return i.installTimerFunctions;
  } });
  var o = rc;
  Object.defineProperty(e, "parse", { enumerable: !0, get: function() {
    return o.parse;
  } });
  var a = ar;
  Object.defineProperty(e, "nextTick", { enumerable: !0, get: function() {
    return a.nextTick;
  } });
})(Dm);
var k3 = it && it.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(kd, "__esModule", { value: !0 });
kd.url = void 0;
const E3 = Dm, C3 = k3(Xr), nv = C3.default("socket.io-client:url");
function T3(e, t = "", n) {
  let r = e;
  n = n || typeof location < "u" && location, e == null && (e = n.protocol + "//" + n.host), typeof e == "string" && (e.charAt(0) === "/" && (e.charAt(1) === "/" ? e = n.protocol + e : e = n.host + e), /^(https?|wss?):\/\//.test(e) || (nv("protocol-less url %s", e), typeof n < "u" ? e = n.protocol + "//" + e : e = "https://" + e), nv("parse %s", e), r = E3.parse(e)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
  const o = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
  return r.id = r.protocol + "://" + o + ":" + r.port + t, r.href = r.protocol + "://" + o + (n && n.port === r.port ? "" : ":" + r.port), r;
}
kd.url = T3;
var Od = {}, ic = {}, Id = {}, ba = {}, xo = {};
Object.defineProperty(xo, "__esModule", { value: !0 });
xo.hasBinary = xo.isBinary = void 0;
const R3 = typeof ArrayBuffer == "function", A3 = (e) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e.buffer instanceof ArrayBuffer, tk = Object.prototype.toString, O3 = typeof Blob == "function" || typeof Blob < "u" && tk.call(Blob) === "[object BlobConstructor]", I3 = typeof File == "function" || typeof File < "u" && tk.call(File) === "[object FileConstructor]";
function nk(e) {
  return R3 && (e instanceof ArrayBuffer || A3(e)) || O3 && e instanceof Blob || I3 && e instanceof File;
}
xo.isBinary = nk;
function Xc(e, t) {
  if (!e || typeof e != "object")
    return !1;
  if (Array.isArray(e)) {
    for (let n = 0, r = e.length; n < r; n++)
      if (Xc(e[n]))
        return !0;
    return !1;
  }
  if (nk(e))
    return !0;
  if (e.toJSON && typeof e.toJSON == "function" && arguments.length === 1)
    return Xc(e.toJSON(), !0);
  for (const n in e)
    if (Object.prototype.hasOwnProperty.call(e, n) && Xc(e[n]))
      return !0;
  return !1;
}
xo.hasBinary = Xc;
Object.defineProperty(ba, "__esModule", { value: !0 });
ba.reconstructPacket = ba.deconstructPacket = void 0;
const P3 = xo;
function $3(e) {
  const t = [], n = e.data, r = e;
  return r.data = Lp(n, t), r.attachments = t.length, { packet: r, buffers: t };
}
ba.deconstructPacket = $3;
function Lp(e, t) {
  if (!e)
    return e;
  if ((0, P3.isBinary)(e)) {
    const n = { _placeholder: !0, num: t.length };
    return t.push(e), n;
  } else if (Array.isArray(e)) {
    const n = new Array(e.length);
    for (let r = 0; r < e.length; r++)
      n[r] = Lp(e[r], t);
    return n;
  } else if (typeof e == "object" && !(e instanceof Date)) {
    const n = {};
    for (const r in e)
      Object.prototype.hasOwnProperty.call(e, r) && (n[r] = Lp(e[r], t));
    return n;
  }
  return e;
}
function D3(e, t) {
  return e.data = Fp(e.data, t), delete e.attachments, e;
}
ba.reconstructPacket = D3;
function Fp(e, t) {
  if (!e)
    return e;
  if (e && e._placeholder === !0) {
    if (typeof e.num == "number" && e.num >= 0 && e.num < t.length)
      return t[e.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(e))
    for (let n = 0; n < e.length; n++)
      e[n] = Fp(e[n], t);
  else if (typeof e == "object")
    for (const n in e)
      Object.prototype.hasOwnProperty.call(e, n) && (e[n] = Fp(e[n], t));
  return e;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Decoder = e.Encoder = e.PacketType = e.protocol = void 0;
  const t = Ma, n = ba, r = xo, o = (0, Xr.default)("socket.io-parser"), a = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener"
    // used by the Node.js EventEmitter
  ];
  e.protocol = 5;
  var s;
  (function(p) {
    p[p.CONNECT = 0] = "CONNECT", p[p.DISCONNECT = 1] = "DISCONNECT", p[p.EVENT = 2] = "EVENT", p[p.ACK = 3] = "ACK", p[p.CONNECT_ERROR = 4] = "CONNECT_ERROR", p[p.BINARY_EVENT = 5] = "BINARY_EVENT", p[p.BINARY_ACK = 6] = "BINARY_ACK";
  })(s = e.PacketType || (e.PacketType = {}));
  class c {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    constructor(f) {
      this.replacer = f;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(f) {
      return o("encoding packet %j", f), (f.type === s.EVENT || f.type === s.ACK) && (0, r.hasBinary)(f) ? this.encodeAsBinary({
        type: f.type === s.EVENT ? s.BINARY_EVENT : s.BINARY_ACK,
        nsp: f.nsp,
        data: f.data,
        id: f.id
      }) : [this.encodeAsString(f)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(f) {
      let h = "" + f.type;
      return (f.type === s.BINARY_EVENT || f.type === s.BINARY_ACK) && (h += f.attachments + "-"), f.nsp && f.nsp !== "/" && (h += f.nsp + ","), f.id != null && (h += f.id), f.data != null && (h += JSON.stringify(f.data, this.replacer)), o("encoded %j as %s", f, h), h;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(f) {
      const h = (0, n.deconstructPacket)(f), m = this.encodeAsString(h.packet), y = h.buffers;
      return y.unshift(m), y;
    }
  }
  e.Encoder = c;
  function l(p) {
    return Object.prototype.toString.call(p) === "[object Object]";
  }
  class u extends t.Emitter {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    constructor(f) {
      super(), this.reviver = f;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(f) {
      let h;
      if (typeof f == "string") {
        if (this.reconstructor)
          throw new Error("got plaintext data when reconstructing a packet");
        h = this.decodeString(f);
        const m = h.type === s.BINARY_EVENT;
        m || h.type === s.BINARY_ACK ? (h.type = m ? s.EVENT : s.ACK, this.reconstructor = new d(h), h.attachments === 0 && super.emitReserved("decoded", h)) : super.emitReserved("decoded", h);
      } else if ((0, r.isBinary)(f) || f.base64)
        if (this.reconstructor)
          h = this.reconstructor.takeBinaryData(f), h && (this.reconstructor = null, super.emitReserved("decoded", h));
        else
          throw new Error("got binary data when not reconstructing a packet");
      else
        throw new Error("Unknown type: " + f);
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(f) {
      let h = 0;
      const m = {
        type: Number(f.charAt(0))
      };
      if (s[m.type] === void 0)
        throw new Error("unknown packet type " + m.type);
      if (m.type === s.BINARY_EVENT || m.type === s.BINARY_ACK) {
        const g = h + 1;
        for (; f.charAt(++h) !== "-" && h != f.length; )
          ;
        const v = f.substring(g, h);
        if (v != Number(v) || f.charAt(h) !== "-")
          throw new Error("Illegal attachments");
        m.attachments = Number(v);
      }
      if (f.charAt(h + 1) === "/") {
        const g = h + 1;
        for (; ++h && !(f.charAt(h) === "," || h === f.length); )
          ;
        m.nsp = f.substring(g, h);
      } else
        m.nsp = "/";
      const y = f.charAt(h + 1);
      if (y !== "" && Number(y) == y) {
        const g = h + 1;
        for (; ++h; ) {
          const v = f.charAt(h);
          if (v == null || Number(v) != v) {
            --h;
            break;
          }
          if (h === f.length)
            break;
        }
        m.id = Number(f.substring(g, h + 1));
      }
      if (f.charAt(++h)) {
        const g = this.tryParse(f.substr(h));
        if (u.isPayloadValid(m.type, g))
          m.data = g;
        else
          throw new Error("invalid payload");
      }
      return o("decoded %s as %j", f, m), m;
    }
    tryParse(f) {
      try {
        return JSON.parse(f, this.reviver);
      } catch {
        return !1;
      }
    }
    static isPayloadValid(f, h) {
      switch (f) {
        case s.CONNECT:
          return l(h);
        case s.DISCONNECT:
          return h === void 0;
        case s.CONNECT_ERROR:
          return typeof h == "string" || l(h);
        case s.EVENT:
        case s.BINARY_EVENT:
          return Array.isArray(h) && (typeof h[0] == "number" || typeof h[0] == "string" && a.indexOf(h[0]) === -1);
        case s.ACK:
        case s.BINARY_ACK:
          return Array.isArray(h);
      }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
      this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
    }
  }
  e.Decoder = u;
  class d {
    constructor(f) {
      this.packet = f, this.buffers = [], this.reconPack = f;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(f) {
      if (this.buffers.push(f), this.buffers.length === this.reconPack.attachments) {
        const h = (0, n.reconstructPacket)(this.reconPack, this.buffers);
        return this.finishedReconstruction(), h;
      }
      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
      this.reconPack = null, this.buffers = [];
    }
  }
})(Id);
var oc = {};
Object.defineProperty(oc, "__esModule", { value: !0 });
oc.on = void 0;
function N3(e, t, n) {
  return e.on(t, n), function() {
    e.off(t, n);
  };
}
oc.on = N3;
var j3 = it && it.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ic, "__esModule", { value: !0 });
ic.Socket = void 0;
const xr = Id, Tc = oc, M3 = Ma, q3 = j3(Xr), dn = q3.default("socket.io-client:socket"), L3 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class F3 extends M3.Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(t, n, r) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = n, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      Tc.on(t, "open", this.onopen.bind(this)),
      Tc.on(t, "packet", this.onpacket.bind(this)),
      Tc.on(t, "error", this.onerror.bind(this)),
      Tc.on(t, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(t, ...n) {
    if (L3.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    if (n.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(n), this;
    const r = {
      type: xr.PacketType.EVENT,
      data: n
    };
    if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof n[n.length - 1] == "function") {
      const a = this.ids++;
      dn("emitting packet with ack id %d", a);
      const s = n.pop();
      this._registerAckCallback(a, s), r.id = a;
    }
    const i = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!i || !this.connected) ? dn("discard packet as the transport is not currently writable") : this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(t, n) {
    var r;
    const i = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;
    if (i === void 0) {
      this.acks[t] = n;
      return;
    }
    const o = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let a = 0; a < this.sendBuffer.length; a++)
        this.sendBuffer[a].id === t && (dn("removing packet with ack id %d from the buffer", t), this.sendBuffer.splice(a, 1));
      dn("event with ack id %d has timed out after %d ms", t, i), n.call(this, new Error("operation has timed out"));
    }, i);
    this.acks[t] = (...a) => {
      this.io.clearTimeoutFn(o), n.apply(this, [null, ...a]);
    };
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(t, ...n) {
    const r = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((i, o) => {
      n.push((a, s) => r ? a ? o(a) : i(s) : i(a)), this.emit(t, ...n);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(t) {
    let n;
    typeof t[t.length - 1] == "function" && (n = t.pop());
    const r = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: t,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    t.push((i, ...o) => r !== this._queue[0] ? void 0 : (i !== null ? r.tryCount > this._opts.retries && (dn("packet [%d] is discarded after %d tries", r.id, r.tryCount), this._queue.shift(), n && n(i)) : (dn("packet [%d] was successfully sent", r.id), this._queue.shift(), n && n(null, ...o)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(t = !1) {
    if (dn("draining queue"), !this.connected || this._queue.length === 0)
      return;
    const n = this._queue[0];
    if (n.pending && !t) {
      dn("packet [%d] has already been sent and is waiting for an ack", n.id);
      return;
    }
    n.pending = !0, n.tryCount++, dn("sending packet [%d] (try n%d)", n.id, n.tryCount), this.flags = n.flags, this.emit.apply(this, n.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    dn("transport is open - connecting"), typeof this.auth == "function" ? this.auth((t) => {
      this._sendConnectPacket(t);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(t) {
    this.packet({
      type: xr.PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(t, n) {
    dn("close (%s)", t), this.connected = !1, delete this.id, this.emitReserved("disconnect", t, n);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case xr.PacketType.CONNECT:
          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case xr.PacketType.EVENT:
        case xr.PacketType.BINARY_EVENT:
          this.onevent(t);
          break;
        case xr.PacketType.ACK:
        case xr.PacketType.BINARY_ACK:
          this.onack(t);
          break;
        case xr.PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case xr.PacketType.CONNECT_ERROR:
          this.destroy();
          const r = new Error(t.data.message);
          r.data = t.data.data, this.emitReserved("connect_error", r);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(t) {
    const n = t.data || [];
    dn("emitting event %j", n), t.id != null && (dn("attaching ack callback to event"), n.push(this.ack(t.id))), this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const n = this._anyListeners.slice();
      for (const r of n)
        r.apply(this, t);
    }
    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(t) {
    const n = this;
    let r = !1;
    return function(...i) {
      r || (r = !0, dn("sending ack %j", i), n.packet({
        type: xr.PacketType.ACK,
        id: t,
        data: i
      }));
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(t) {
    const n = this.acks[t.id];
    typeof n == "function" ? (dn("calling ack %s with %j", t.id, t.data), n.apply(this, t.data), delete this.acks[t.id]) : dn("bad ack %s", t.id);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(t, n) {
    dn("socket connected with id %s", t), this.id = t, this.recovered = n && this._pid === n, this._pid = n, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    dn("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && (dn("performing disconnect (%s)", this.nsp), this.packet({ type: xr.PacketType.DISCONNECT })), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(t) {
    return this.flags.compress = t, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const n = this._anyListeners;
      for (let r = 0; r < n.length; r++)
        if (t === n[r])
          return n.splice(r, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const n = this._anyOutgoingListeners;
      for (let r = 0; r < n.length; r++)
        if (t === n[r])
          return n.splice(r, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const n = this._anyOutgoingListeners.slice();
      for (const r of n)
        r.apply(this, t.data);
    }
  }
}
ic.Socket = F3;
var Pd = {};
Object.defineProperty(Pd, "__esModule", { value: !0 });
Pd.Backoff = void 0;
function qa(e) {
  e = e || {}, this.ms = e.min || 100, this.max = e.max || 1e4, this.factor = e.factor || 2, this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0, this.attempts = 0;
}
Pd.Backoff = qa;
qa.prototype.duration = function() {
  var e = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), n = Math.floor(t * this.jitter * e);
    e = Math.floor(t * 10) & 1 ? e + n : e - n;
  }
  return Math.min(e, this.max) | 0;
};
qa.prototype.reset = function() {
  this.attempts = 0;
};
qa.prototype.setMin = function(e) {
  this.ms = e;
};
qa.prototype.setMax = function(e) {
  this.max = e;
};
qa.prototype.setJitter = function(e) {
  this.jitter = e;
};
var U3 = it && it.__createBinding || (Object.create ? function(e, t, n, r) {
  r === void 0 && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function() {
    return t[n];
  } });
} : function(e, t, n, r) {
  r === void 0 && (r = n), e[r] = t[n];
}), B3 = it && it.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), z3 = it && it.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && U3(t, e, n);
  return B3(t, e), t;
}, Z3 = it && it.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Od, "__esModule", { value: !0 });
Od.Manager = void 0;
const kf = Dm, V3 = ic, H3 = z3(Id), to = oc, W3 = Pd, K3 = Ma, J3 = Z3(Xr), Sn = J3.default("socket.io-client:manager");
class Y3 extends K3.Emitter {
  constructor(t, n) {
    var r;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (n = t, t = void 0), n = n || {}, n.path = n.path || "/socket.io", this.opts = n, kf.installTimerFunctions(this, n), this.reconnection(n.reconnection !== !1), this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0), this.reconnectionDelay(n.reconnectionDelay || 1e3), this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3), this.randomizationFactor((r = n.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new W3.Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(n.timeout == null ? 2e4 : n.timeout), this._readyState = "closed", this.uri = t;
    const i = n.parser || H3;
    this.encoder = new i.Encoder(), this.decoder = new i.Decoder(), this._autoConnect = n.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var n;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (n = this.backoff) === null || n === void 0 || n.setMin(t), this);
  }
  randomizationFactor(t) {
    var n;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (n = this.backoff) === null || n === void 0 || n.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var n;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (n = this.backoff) === null || n === void 0 || n.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(t) {
    if (Sn("readyState %s", this._readyState), ~this._readyState.indexOf("open"))
      return this;
    Sn("opening %s", this.uri), this.engine = new kf.Socket(this.uri, this.opts);
    const n = this.engine, r = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const i = to.on(n, "open", function() {
      r.onopen(), t && t();
    }), o = (s) => {
      Sn("error"), this.cleanup(), this._readyState = "closed", this.emitReserved("error", s), t ? t(s) : this.maybeReconnectOnOpen();
    }, a = to.on(n, "error", o);
    if (this._timeout !== !1) {
      const s = this._timeout;
      Sn("connect attempt will timeout after %d", s);
      const c = this.setTimeoutFn(() => {
        Sn("connect attempt timed out after %d", s), i(), o(new Error("timeout")), n.close();
      }, s);
      this.opts.autoUnref && c.unref(), this.subs.push(() => {
        this.clearTimeoutFn(c);
      });
    }
    return this.subs.push(i), this.subs.push(a), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(t) {
    return this.open(t);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    Sn("open"), this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(to.on(t, "ping", this.onping.bind(this)), to.on(t, "data", this.ondata.bind(this)), to.on(t, "error", this.onerror.bind(this)), to.on(t, "close", this.onclose.bind(this)), to.on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch (n) {
      this.onclose("parse error", n);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(t) {
    kf.nextTick(() => {
      this.emitReserved("packet", t);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(t) {
    Sn("error", t), this.emitReserved("error", t);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(t, n) {
    let r = this.nsps[t];
    return r ? this._autoConnect && !r.active && r.connect() : (r = new V3.Socket(this, t, n), this.nsps[t] = r), r;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(t) {
    const n = Object.keys(this.nsps);
    for (const r of n)
      if (this.nsps[r].active) {
        Sn("socket %s is still active, skipping close", r);
        return;
      }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(t) {
    Sn("writing packet %j", t);
    const n = this.encoder.encode(t);
    for (let r = 0; r < n.length; r++)
      this.engine.write(n[r], t.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    Sn("cleanup"), this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    Sn("disconnect"), this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(t, n) {
    Sn("closed due to %s", t), this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, n), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      Sn("reconnect failed"), this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const n = this.backoff.duration();
      Sn("will wait %dms before reconnect attempt", n), this._reconnecting = !0;
      const r = this.setTimeoutFn(() => {
        t.skipReconnect || (Sn("attempting reconnect"), this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((i) => {
          i ? (Sn("reconnect attempt error"), t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", i)) : (Sn("reconnect success"), t.onreconnect());
        }));
      }, n);
      this.opts.autoUnref && r.unref(), this.subs.push(() => {
        this.clearTimeoutFn(r);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
Od.Manager = Y3;
(function(e, t) {
  var n = it && it.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.connect = t.io = t.Socket = t.Manager = t.protocol = void 0;
  const r = kd, i = Od;
  Object.defineProperty(t, "Manager", { enumerable: !0, get: function() {
    return i.Manager;
  } });
  const o = ic;
  Object.defineProperty(t, "Socket", { enumerable: !0, get: function() {
    return o.Socket;
  } });
  const s = n(Xr).default("socket.io-client"), c = {};
  function l(d, p) {
    typeof d == "object" && (p = d, d = void 0), p = p || {};
    const f = r.url(d, p.path || "/socket.io"), h = f.source, m = f.id, y = f.path, g = c[m] && y in c[m].nsps, v = p.forceNew || p["force new connection"] || p.multiplex === !1 || g;
    let b;
    return v ? (s("ignoring socket cache for %s", h), b = new i.Manager(h, p)) : (c[m] || (s("new io instance for %s", h), c[m] = new i.Manager(h, p)), b = c[m]), f.query && !p.query && (p.query = f.queryKey), b.socket(f.path, p);
  }
  t.io = l, t.connect = l, t.default = l, Object.assign(l, {
    Manager: i.Manager,
    Socket: o.Socket,
    io: l,
    connect: l
  });
  var u = Id;
  Object.defineProperty(t, "protocol", { enumerable: !0, get: function() {
    return u.protocol;
  } }), e.exports = l;
})(jp, jp.exports);
var G3 = jp.exports;
(function(e) {
  var t = it && it.__awaiter || function(c, l, u, d) {
    function p(f) {
      return f instanceof u ? f : new u(function(h) {
        h(f);
      });
    }
    return new (u || (u = Promise))(function(f, h) {
      function m(v) {
        try {
          g(d.next(v));
        } catch (b) {
          h(b);
        }
      }
      function y(v) {
        try {
          g(d.throw(v));
        } catch (b) {
          h(b);
        }
      }
      function g(v) {
        v.done ? f(v.value) : p(v.value).then(m, y);
      }
      g((d = d.apply(c, l || [])).next());
    });
  }, n = it && it.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SocketComEmitter = e.SocketComEvents = e.SocketCom = void 0;
  const r = $m, i = n(G3);
  class o {
    constructor(l) {
      this.url = l, this.pending = {}, this.emitter = new s(), this.events = this.emitter;
    }
    connect(l, u) {
      return t(this, void 0, void 0, function* () {
        return new Promise((d, p) => {
          this.disconnect(), this.socket = (0, i.default)(this.url, {
            transports: ["websocket"],
            auth: l,
            autoConnect: !1,
            query: u
          });
          const f = setTimeout(() => {
            p("connection timed out");
          }, 5e3);
          this.socket.on("login", (h) => t(this, void 0, void 0, function* () {
            clearTimeout(f), d(h);
          })), this.socket.on("connect_error", (h) => {
            var m;
            (m = this.socket) === null || m === void 0 || m.close(), clearTimeout(f), p(h.message);
          }), this.socket.on("message", (h) => t(this, void 0, void 0, function* () {
            var m;
            this.pending[h.request] && (!((m = h.data) === null || m === void 0) && m.error ? this.pending[h.request].reject(new Error(h.data.message)) : this.pending[h.request].resolve(h.data), delete this.pending[h.request]), yield this.emitter.emit(a.Message, h);
          })), this.socket.connect();
        });
      });
    }
    disconnect() {
      var l;
      this.socket && !(!((l = this.socket) === null || l === void 0) && l.disconnected) && this.socket.disconnect();
    }
    request(l, u) {
      var d;
      return t(this, void 0, void 0, function* () {
        if (!(!((d = this.socket) === null || d === void 0) && d.connected))
          throw new Error("Client is disconnected");
        const p = this.random(32), f = new Promise((h, m) => {
          this.pending[p] = { resolve: h, reject: m };
        });
        return this.socket.send({ request: p, type: l, data: u }), f;
      });
    }
    random(l) {
      const u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      let d = "";
      for (let p = 0; p < l; p++)
        d += u.charAt(Math.floor(Math.random() * u.length));
      return d;
    }
  }
  e.SocketCom = o;
  var a;
  (function(c) {
    c.Message = "message";
  })(a = e.SocketComEvents || (e.SocketComEvents = {}));
  class s extends r.Emitter {
  }
  e.SocketComEmitter = s;
})(zS);
var $d = {}, X3 = it && it.__awaiter || function(e, t, n, r) {
  function i(o) {
    return o instanceof n ? o : new n(function(a) {
      a(o);
    });
  }
  return new (n || (n = Promise))(function(o, a) {
    function s(u) {
      try {
        l(r.next(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function l(u) {
      u.done ? o(u.value) : i(u.value).then(s, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
Object.defineProperty($d, "__esModule", { value: !0 });
$d.SocketEmitter = void 0;
class Q3 {
  constructor() {
    this.listeners = {};
  }
  on(t, n) {
    const r = this.listeners[t];
    r ? r.push(n) : this.listeners[t] = [n];
  }
  removeListeners(t) {
    this.listeners[t] = [];
  }
  emit(t, n) {
    return X3(this, void 0, void 0, function* () {
      const r = this.listeners[t];
      if (r != null && r.length) {
        for (const i of r)
          yield i(n);
        return !0;
      } else
        return !1;
    });
  }
}
$d.SocketEmitter = Q3;
var Kn = it && it.__awaiter || function(e, t, n, r) {
  function i(o) {
    return o instanceof n ? o : new n(function(a) {
      a(o);
    });
  }
  return new (n || (n = Promise))(function(o, a) {
    function s(u) {
      try {
        l(r.next(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function l(u) {
      u.done ? o(u.value) : i(u.value).then(s, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
Object.defineProperty(Sd, "__esModule", { value: !0 });
Sd.MessagingSocket = void 0;
const rv = zS, e5 = $d;
class t5 extends e5.SocketEmitter {
  constructor(t) {
    super(), this.clientId = t.clientId, this.com = new rv.SocketCom(t.url), this.com.events.on(rv.SocketComEvents.Message, (n) => Kn(this, void 0, void 0, function* () {
      n.type === "message.new" && (yield this.emit("message", n.data.message));
    }));
  }
  get creds() {
    return this._creds;
  }
  get userId() {
    var t;
    return (t = this._creds) === null || t === void 0 ? void 0 : t.userId;
  }
  get conversationId() {
    return this._conversationId;
  }
  connect(t, n) {
    return Kn(this, void 0, void 0, function* () {
      const r = n ? { userData: JSON.stringify(n) } : void 0, i = yield this.com.connect({ clientId: this.clientId, creds: t }, r);
      return i.userId === (t == null ? void 0 : t.userId) && !i.userToken && (i.userToken = t.userToken), this._creds = i, yield this.emit("connect", this._creds), yield this.emit("user", this._creds.userId), i;
    });
  }
  disconnect() {
    return Kn(this, void 0, void 0, function* () {
      this.com.disconnect(), yield this.emit("disconnect", void 0);
    });
  }
  getUser() {
    return Kn(this, void 0, void 0, function* () {
      return this.request("users.get", {});
    });
  }
  switchConversation(t) {
    return Kn(this, void 0, void 0, function* () {
      this._conversationId = t, yield this.emit("conversation", this._conversationId);
    });
  }
  createConversation(t) {
    return Kn(this, void 0, void 0, function* () {
      const n = yield this.request("conversations.create", {});
      return (t == null ? void 0 : t.switch) !== !1 && (yield this.switchConversation(n.id)), n;
    });
  }
  startConversation(t) {
    return Kn(this, void 0, void 0, function* () {
      yield this.request("conversations.start", { id: t || this._conversationId });
    });
  }
  getConversation(t) {
    return Kn(this, void 0, void 0, function* () {
      return this.request("conversations.get", {
        id: t || this._conversationId
      });
    });
  }
  deleteConversation(t) {
    return Kn(this, void 0, void 0, function* () {
      const n = yield this.request("conversations.delete", {
        id: t || this._conversationId
      });
      return n && (yield this.switchConversation(void 0)), n;
    });
  }
  listConversations(t) {
    return Kn(this, void 0, void 0, function* () {
      return this.request("conversations.list", {
        limit: t || 20
      });
    });
  }
  sendText(t) {
    return Kn(this, void 0, void 0, function* () {
      return this.request("messages.create", {
        conversationId: this._conversationId,
        payload: { type: "text", text: t }
      });
    });
  }
  sendPayload(t) {
    return Kn(this, void 0, void 0, function* () {
      return this.request("messages.create", {
        conversationId: this._conversationId,
        payload: t
      });
    });
  }
  listMessages(t) {
    return Kn(this, void 0, void 0, function* () {
      return this.request("messages.list", {
        conversationId: this._conversationId,
        limit: t || 20
      });
    });
  }
  sendFeedback(t, n) {
    return Kn(this, void 0, void 0, function* () {
      yield this.request("messages.feedback", {
        messageId: t,
        feedback: n
      });
    });
  }
  request(t, n) {
    return this.com.request(t, n);
  }
}
Sd.MessagingSocket = t5;
(function(e) {
  var t = it && it.__createBinding || (Object.create ? function(r, i, o, a) {
    a === void 0 && (a = o), Object.defineProperty(r, a, { enumerable: !0, get: function() {
      return i[o];
    } });
  } : function(r, i, o, a) {
    a === void 0 && (a = o), r[a] = i[o];
  }), n = it && it.__exportStar || function(r, i) {
    for (var o in r)
      o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, r, o);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n($m, e), n(Sd, e);
})(NS);
class n5 {
  constructor(t) {
    k(this, "socket");
    k(this, "clientId");
    k(this, "apiUrl");
    k(this, "userId");
    k(this, "conversationId");
    k(this, "userToken");
    k(this, "connected", !1);
    k(this, "emitter");
    k(this, "on");
    k(this, "mode", "messaging");
    this.socket = new NS.MessagingSocket(t), this.emitter = new hm(), this.clientId = t.clientId, this.apiUrl = t.url, this.on = this.emitter.on.bind(this.emitter), this.socket.on("message", (n) => {
      const r = n.payload;
      if (r.type === "trigger")
        switch (r.trigger.type) {
          case "webchat-visibility":
            this.emitter.emit("webchatVisibility", r.trigger.visibility);
            break;
          case "webchat-config":
            this.emitter.emit("webchatConfig", r.trigger.config);
            break;
          case "custom-event":
            this.emitter.emit("customEvent", r.trigger.event);
            break;
        }
      else {
        const i = au.parse(r), { payload: o, disableInput: a } = Sp(i);
        this.emitter.emit("message", {
          ...n,
          payload: o,
          disableInput: a
        });
      }
    }), this.socket.on("conversation", (n) => {
      this.emitter.emit("conversation", n);
    });
  }
  async connect(t, n) {
    if (this.connected)
      return;
    this.connected = !0;
    const r = await this.socket.connect(t, n).catch((i) => {
      throw this.connected = !1, i;
    });
    return this.userId = r.userId, this.userToken = r.userToken, r;
  }
  async disconnect() {
    await this.socket.disconnect(), this.connected = !1;
  }
  async getUser() {
    throw new Error("Get user is not supported in messaging mode");
  }
  async updateUser() {
    throw new Error("Update user is not supported in messaging mode");
  }
  async sendFile(t) {
    throw new Error("Send file is not supported in messaging mode");
  }
  async sendMessage(t) {
    this.conversationId || await this.newConversation(), await this.socket.sendText(t), this.emitter.emit("messageSent", t);
  }
  async sendEvent(t) {
    this.conversationId || await this.newConversation(), await this.socket.sendPayload({ type: "trigger", payload: t });
  }
  async switchConversation(t) {
    await this.socket.switchConversation(t), this.conversationId = t;
  }
  async conversationExists(t) {
    return (await this.socket.listConversations()).some((r) => r.id === t);
  }
  async newConversation() {
    const { id: t } = await this.socket.createConversation();
    await this.socket.startConversation(), this.conversationId = t;
  }
  async listMessages(t) {
    return (await this.socket.listMessages(t)).map((r) => {
      const i = au.parse(r.payload), { payload: o, disableInput: a } = Sp(i);
      return {
        ...r,
        payload: o,
        disableInput: a
      };
    });
  }
}
function rk(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: ik } = Object.prototype, { getPrototypeOf: jm } = Object, Mm = ((e) => (t) => {
  const n = ik.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), gi = (e) => (e = e.toLowerCase(), (t) => Mm(t) === e), Dd = (e) => (t) => typeof t === e, { isArray: La } = Array, bs = Dd("undefined");
function r5(e) {
  return e !== null && !bs(e) && e.constructor !== null && !bs(e.constructor) && _o(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const ok = gi("ArrayBuffer");
function i5(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && ok(e.buffer), t;
}
const o5 = Dd("string"), _o = Dd("function"), ak = Dd("number"), qm = (e) => e !== null && typeof e == "object", a5 = (e) => e === !0 || e === !1, Qc = (e) => {
  if (Mm(e) !== "object")
    return !1;
  const t = jm(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, s5 = gi("Date"), c5 = gi("File"), l5 = gi("Blob"), u5 = gi("FileList"), d5 = (e) => qm(e) && _o(e.pipe), f5 = (e) => {
  const t = "[object FormData]";
  return e && (typeof FormData == "function" && e instanceof FormData || ik.call(e) === t || _o(e.toString) && e.toString() === t);
}, p5 = gi("URLSearchParams"), h5 = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ac(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), La(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e), a = o.length;
    let s;
    for (r = 0; r < a; r++)
      s = o[r], t.call(null, e[s], s, e);
  }
}
function sk(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const ck = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), lk = (e) => !bs(e) && e !== ck;
function Up() {
  const { caseless: e } = lk(this) && this || {}, t = {}, n = (r, i) => {
    const o = e && sk(t, i) || i;
    Qc(t[o]) && Qc(r) ? t[o] = Up(t[o], r) : Qc(r) ? t[o] = Up({}, r) : La(r) ? t[o] = r.slice() : t[o] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && ac(arguments[r], n);
  return t;
}
const m5 = (e, t, n, { allOwnKeys: r } = {}) => (ac(t, (i, o) => {
  n && _o(i) ? e[o] = rk(i, n) : e[o] = i;
}, { allOwnKeys: r }), e), y5 = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), g5 = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, v5 = (e, t, n, r) => {
  let i, o, a;
  const s = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (i = Object.getOwnPropertyNames(e), o = i.length; o-- > 0; )
      a = i[o], (!r || r(a, e, t)) && !s[a] && (t[a] = e[a], s[a] = !0);
    e = n !== !1 && jm(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, b5 = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, w5 = (e) => {
  if (!e)
    return null;
  if (La(e))
    return e;
  let t = e.length;
  if (!ak(t))
    return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, x5 = ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && jm(Uint8Array)), _5 = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const o = i.value;
    t.call(e, o[0], o[1]);
  }
}, S5 = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, k5 = gi("HTMLFormElement"), E5 = (e) => e.toLowerCase().replace(
  /[_-\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), iv = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), C5 = gi("RegExp"), uk = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  ac(n, (i, o) => {
    t(i, o, e) !== !1 && (r[o] = i);
  }), Object.defineProperties(e, r);
}, T5 = (e) => {
  uk(e, (t, n) => {
    if (_o(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (_o(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, R5 = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((o) => {
      n[o] = !0;
    });
  };
  return La(e) ? r(e) : r(String(e).split(t)), n;
}, A5 = () => {
}, O5 = (e, t) => (e = +e, Number.isFinite(e) ? e : t), I5 = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (qm(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const o = La(r) ? [] : {};
        return ac(r, (a, s) => {
          const c = n(a, i + 1);
          !bs(c) && (o[s] = c);
        }), t[i] = void 0, o;
      }
    }
    return r;
  };
  return n(e, 0);
}, oe = {
  isArray: La,
  isArrayBuffer: ok,
  isBuffer: r5,
  isFormData: f5,
  isArrayBufferView: i5,
  isString: o5,
  isNumber: ak,
  isBoolean: a5,
  isObject: qm,
  isPlainObject: Qc,
  isUndefined: bs,
  isDate: s5,
  isFile: c5,
  isBlob: l5,
  isRegExp: C5,
  isFunction: _o,
  isStream: d5,
  isURLSearchParams: p5,
  isTypedArray: x5,
  isFileList: u5,
  forEach: ac,
  merge: Up,
  extend: m5,
  trim: h5,
  stripBOM: y5,
  inherits: g5,
  toFlatObject: v5,
  kindOf: Mm,
  kindOfTest: gi,
  endsWith: b5,
  toArray: w5,
  forEachEntry: _5,
  matchAll: S5,
  isHTMLForm: k5,
  hasOwnProperty: iv,
  hasOwnProp: iv,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: uk,
  freezeMethods: T5,
  toObjectSet: R5,
  toCamelCase: E5,
  noop: A5,
  toFiniteNumber: O5,
  findKey: sk,
  global: ck,
  isContextDefined: lk,
  toJSONObject: I5
};
function Rt(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i);
}
oe.inherits(Rt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: oe.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const dk = Rt.prototype, fk = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  fk[e] = { value: e };
});
Object.defineProperties(Rt, fk);
Object.defineProperty(dk, "isAxiosError", { value: !0 });
Rt.from = (e, t, n, r, i, o) => {
  const a = Object.create(dk);
  return oe.toFlatObject(e, a, function(c) {
    return c !== Error.prototype;
  }, (s) => s !== "isAxiosError"), Rt.call(a, e.message, t, n, r, i), a.cause = e, a.name = e.name, o && Object.assign(a, o), a;
};
var P5 = typeof self == "object" ? self.FormData : window.FormData;
const $5 = /* @__PURE__ */ Vi(P5);
function Bp(e) {
  return oe.isPlainObject(e) || oe.isArray(e);
}
function pk(e) {
  return oe.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function ov(e, t, n) {
  return e ? e.concat(t).map(function(i, o) {
    return i = pk(i), !n && o ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function D5(e) {
  return oe.isArray(e) && !e.some(Bp);
}
const N5 = oe.toFlatObject(oe, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function j5(e) {
  return e && oe.isFunction(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator];
}
function Nd(e, t, n) {
  if (!oe.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new ($5 || FormData)(), n = oe.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(m, y) {
    return !oe.isUndefined(y[m]);
  });
  const r = n.metaTokens, i = n.visitor || u, o = n.dots, a = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && j5(t);
  if (!oe.isFunction(i))
    throw new TypeError("visitor must be a function");
  function l(h) {
    if (h === null)
      return "";
    if (oe.isDate(h))
      return h.toISOString();
    if (!c && oe.isBlob(h))
      throw new Rt("Blob is not supported. Use a Buffer instead.");
    return oe.isArrayBuffer(h) || oe.isTypedArray(h) ? c && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
  }
  function u(h, m, y) {
    let g = h;
    if (h && !y && typeof h == "object") {
      if (oe.endsWith(m, "{}"))
        m = r ? m : m.slice(0, -2), h = JSON.stringify(h);
      else if (oe.isArray(h) && D5(h) || oe.isFileList(h) || oe.endsWith(m, "[]") && (g = oe.toArray(h)))
        return m = pk(m), g.forEach(function(b, _) {
          !(oe.isUndefined(b) || b === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            a === !0 ? ov([m], _, o) : a === null ? m : m + "[]",
            l(b)
          );
        }), !1;
    }
    return Bp(h) ? !0 : (t.append(ov(y, m, o), l(h)), !1);
  }
  const d = [], p = Object.assign(N5, {
    defaultVisitor: u,
    convertValue: l,
    isVisitable: Bp
  });
  function f(h, m) {
    if (!oe.isUndefined(h)) {
      if (d.indexOf(h) !== -1)
        throw Error("Circular reference detected in " + m.join("."));
      d.push(h), oe.forEach(h, function(g, v) {
        (!(oe.isUndefined(g) || g === null) && i.call(
          t,
          g,
          oe.isString(v) ? v.trim() : v,
          m,
          p
        )) === !0 && f(g, m ? m.concat(v) : [v]);
      }), d.pop();
    }
  }
  if (!oe.isObject(e))
    throw new TypeError("data must be an object");
  return f(e), t;
}
function av(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function Lm(e, t) {
  this._pairs = [], e && Nd(e, this, t);
}
const hk = Lm.prototype;
hk.append = function(t, n) {
  this._pairs.push([t, n]);
};
hk.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, av);
  } : av;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function M5(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function mk(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || M5, i = n && n.serialize;
  let o;
  if (i ? o = i(t, n) : o = oe.isURLSearchParams(t) ? t.toString() : new Lm(t, n).toString(r), o) {
    const a = e.indexOf("#");
    a !== -1 && (e = e.slice(0, a)), e += (e.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return e;
}
class q5 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    oe.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const sv = q5, yk = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, L5 = typeof URLSearchParams < "u" ? URLSearchParams : Lm, F5 = FormData, U5 = (() => {
  let e;
  return typeof navigator < "u" && ((e = navigator.product) === "ReactNative" || e === "NativeScript" || e === "NS") ? !1 : typeof window < "u" && typeof document < "u";
})(), B5 = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), Br = {
  isBrowser: !0,
  classes: {
    URLSearchParams: L5,
    FormData: F5,
    Blob
  },
  isStandardBrowserEnv: U5,
  isStandardBrowserWebWorkerEnv: B5,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function z5(e, t) {
  return Nd(e, new Br.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, o) {
      return Br.isNode && oe.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function Z5(e) {
  return oe.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function V5(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let o;
  for (r = 0; r < i; r++)
    o = n[r], t[o] = e[o];
  return t;
}
function gk(e) {
  function t(n, r, i, o) {
    let a = n[o++];
    const s = Number.isFinite(+a), c = o >= n.length;
    return a = !a && oe.isArray(i) ? i.length : a, c ? (oe.hasOwnProp(i, a) ? i[a] = [i[a], r] : i[a] = r, !s) : ((!i[a] || !oe.isObject(i[a])) && (i[a] = []), t(n, r, i[a], o) && oe.isArray(i[a]) && (i[a] = V5(i[a])), !s);
  }
  if (oe.isFormData(e) && oe.isFunction(e.entries)) {
    const n = {};
    return oe.forEachEntry(e, (r, i) => {
      t(Z5(r), i, n, 0);
    }), n;
  }
  return null;
}
const H5 = {
  "Content-Type": void 0
};
function W5(e, t, n) {
  if (oe.isString(e))
    try {
      return (t || JSON.parse)(e), oe.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const jd = {
  transitional: yk,
  adapter: ["xhr", "http"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, o = oe.isObject(t);
    if (o && oe.isHTMLForm(t) && (t = new FormData(t)), oe.isFormData(t))
      return i && i ? JSON.stringify(gk(t)) : t;
    if (oe.isArrayBuffer(t) || oe.isBuffer(t) || oe.isStream(t) || oe.isFile(t) || oe.isBlob(t))
      return t;
    if (oe.isArrayBufferView(t))
      return t.buffer;
    if (oe.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let s;
    if (o) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return z5(t, this.formSerializer).toString();
      if ((s = oe.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return Nd(
          s ? { "files[]": t } : t,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return o || i ? (n.setContentType("application/json", !1), W5(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || jd.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (t && oe.isString(t) && (r && !this.responseType || i)) {
      const a = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (s) {
        if (a)
          throw s.name === "SyntaxError" ? Rt.from(s, Rt.ERR_BAD_RESPONSE, this, null, this.response) : s;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Br.classes.FormData,
    Blob: Br.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
oe.forEach(["delete", "get", "head"], function(t) {
  jd.headers[t] = {};
});
oe.forEach(["post", "put", "patch"], function(t) {
  jd.headers[t] = oe.merge(H5);
});
const Fm = jd, K5 = oe.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), J5 = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(a) {
    i = a.indexOf(":"), n = a.substring(0, i).trim().toLowerCase(), r = a.substring(i + 1).trim(), !(!n || t[n] && K5[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, cv = Symbol("internals");
function Wa(e) {
  return e && String(e).trim().toLowerCase();
}
function el(e) {
  return e === !1 || e == null ? e : oe.isArray(e) ? e.map(el) : String(e);
}
function Y5(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
function G5(e) {
  return /^[-_a-zA-Z]+$/.test(e.trim());
}
function lv(e, t, n, r) {
  if (oe.isFunction(r))
    return r.call(this, t, n);
  if (oe.isString(t)) {
    if (oe.isString(r))
      return t.indexOf(r) !== -1;
    if (oe.isRegExp(r))
      return r.test(t);
  }
}
function X5(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function Q5(e, t) {
  const n = oe.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, o, a) {
        return this[r].call(this, t, i, o, a);
      },
      configurable: !0
    });
  });
}
class Md {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function o(s, c, l) {
      const u = Wa(c);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const d = oe.findKey(i, u);
      (!d || i[d] === void 0 || l === !0 || l === void 0 && i[d] !== !1) && (i[d || c] = el(s));
    }
    const a = (s, c) => oe.forEach(s, (l, u) => o(l, u, c));
    return oe.isPlainObject(t) || t instanceof this.constructor ? a(t, n) : oe.isString(t) && (t = t.trim()) && !G5(t) ? a(J5(t), n) : t != null && o(n, t, r), this;
  }
  get(t, n) {
    if (t = Wa(t), t) {
      const r = oe.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return Y5(i);
        if (oe.isFunction(n))
          return n.call(this, i, r);
        if (oe.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = Wa(t), t) {
      const r = oe.findKey(this, t);
      return !!(r && (!n || lv(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function o(a) {
      if (a = Wa(a), a) {
        const s = oe.findKey(r, a);
        s && (!n || lv(r, r[s], s, n)) && (delete r[s], i = !0);
      }
    }
    return oe.isArray(t) ? t.forEach(o) : o(t), i;
  }
  clear() {
    return Object.keys(this).forEach(this.delete.bind(this));
  }
  normalize(t) {
    const n = this, r = {};
    return oe.forEach(this, (i, o) => {
      const a = oe.findKey(r, o);
      if (a) {
        n[a] = el(i), delete n[o];
        return;
      }
      const s = t ? X5(o) : String(o).trim();
      s !== o && delete n[o], n[s] = el(i), r[s] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return oe.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && oe.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[cv] = this[cv] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function o(a) {
      const s = Wa(a);
      r[s] || (Q5(i, a), r[s] = !0);
    }
    return oe.isArray(t) ? t.forEach(o) : o(t), this;
  }
}
Md.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]);
oe.freezeMethods(Md.prototype);
oe.freezeMethods(Md);
const ci = Md;
function Ef(e, t) {
  const n = this || Fm, r = t || n, i = ci.from(r.headers);
  let o = r.data;
  return oe.forEach(e, function(s) {
    o = s.call(n, o, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), o;
}
function vk(e) {
  return !!(e && e.__CANCEL__);
}
function sc(e, t, n) {
  Rt.call(this, e ?? "canceled", Rt.ERR_CANCELED, t, n), this.name = "CanceledError";
}
oe.inherits(sc, Rt, {
  __CANCEL__: !0
});
const eU = null;
function tU(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new Rt(
    "Request failed with status code " + n.status,
    [Rt.ERR_BAD_REQUEST, Rt.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
const nU = Br.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function() {
    return {
      write: function(n, r, i, o, a, s) {
        const c = [];
        c.push(n + "=" + encodeURIComponent(r)), oe.isNumber(i) && c.push("expires=" + new Date(i).toGMTString()), oe.isString(o) && c.push("path=" + o), oe.isString(a) && c.push("domain=" + a), s === !0 && c.push("secure"), document.cookie = c.join("; ");
      },
      read: function(n) {
        const r = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
        return r ? decodeURIComponent(r[3]) : null;
      },
      remove: function(n) {
        this.write(n, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }()
);
function rU(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function iU(e, t) {
  return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function bk(e, t) {
  return e && !rU(t) ? iU(e, t) : t;
}
const oU = Br.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a");
    let r;
    function i(o) {
      let a = o;
      return t && (n.setAttribute("href", a), a = n.href), n.setAttribute("href", a), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return r = i(window.location.href), function(a) {
      const s = oe.isString(a) ? i(a) : a;
      return s.protocol === r.protocol && s.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return !0;
    };
  }()
);
function aU(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function sU(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, o = 0, a;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const l = Date.now(), u = r[o];
    a || (a = l), n[i] = c, r[i] = l;
    let d = o, p = 0;
    for (; d !== i; )
      p += n[d++], d = d % e;
    if (i = (i + 1) % e, i === o && (o = (o + 1) % e), l - a < t)
      return;
    const f = u && l - u;
    return f ? Math.round(p * 1e3 / f) : void 0;
  };
}
function uv(e, t) {
  let n = 0;
  const r = sU(50, 250);
  return (i) => {
    const o = i.loaded, a = i.lengthComputable ? i.total : void 0, s = o - n, c = r(s), l = o <= a;
    n = o;
    const u = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: s,
      rate: c || void 0,
      estimated: c && a && l ? (a - o) / c : void 0,
      event: i
    };
    u[t ? "download" : "upload"] = !0, e(u);
  };
}
const cU = typeof XMLHttpRequest < "u", lU = cU && function(e) {
  return new Promise(function(n, r) {
    let i = e.data;
    const o = ci.from(e.headers).normalize(), a = e.responseType;
    let s;
    function c() {
      e.cancelToken && e.cancelToken.unsubscribe(s), e.signal && e.signal.removeEventListener("abort", s);
    }
    oe.isFormData(i) && (Br.isStandardBrowserEnv || Br.isStandardBrowserWebWorkerEnv) && o.setContentType(!1);
    let l = new XMLHttpRequest();
    if (e.auth) {
      const f = e.auth.username || "", h = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      o.set("Authorization", "Basic " + btoa(f + ":" + h));
    }
    const u = bk(e.baseURL, e.url);
    l.open(e.method.toUpperCase(), mk(u, e.params, e.paramsSerializer), !0), l.timeout = e.timeout;
    function d() {
      if (!l)
        return;
      const f = ci.from(
        "getAllResponseHeaders" in l && l.getAllResponseHeaders()
      ), m = {
        data: !a || a === "text" || a === "json" ? l.responseText : l.response,
        status: l.status,
        statusText: l.statusText,
        headers: f,
        config: e,
        request: l
      };
      tU(function(g) {
        n(g), c();
      }, function(g) {
        r(g), c();
      }, m), l = null;
    }
    if ("onloadend" in l ? l.onloadend = d : l.onreadystatechange = function() {
      !l || l.readyState !== 4 || l.status === 0 && !(l.responseURL && l.responseURL.indexOf("file:") === 0) || setTimeout(d);
    }, l.onabort = function() {
      l && (r(new Rt("Request aborted", Rt.ECONNABORTED, e, l)), l = null);
    }, l.onerror = function() {
      r(new Rt("Network Error", Rt.ERR_NETWORK, e, l)), l = null;
    }, l.ontimeout = function() {
      let h = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const m = e.transitional || yk;
      e.timeoutErrorMessage && (h = e.timeoutErrorMessage), r(new Rt(
        h,
        m.clarifyTimeoutError ? Rt.ETIMEDOUT : Rt.ECONNABORTED,
        e,
        l
      )), l = null;
    }, Br.isStandardBrowserEnv) {
      const f = (e.withCredentials || oU(u)) && e.xsrfCookieName && nU.read(e.xsrfCookieName);
      f && o.set(e.xsrfHeaderName, f);
    }
    i === void 0 && o.setContentType(null), "setRequestHeader" in l && oe.forEach(o.toJSON(), function(h, m) {
      l.setRequestHeader(m, h);
    }), oe.isUndefined(e.withCredentials) || (l.withCredentials = !!e.withCredentials), a && a !== "json" && (l.responseType = e.responseType), typeof e.onDownloadProgress == "function" && l.addEventListener("progress", uv(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && l.upload && l.upload.addEventListener("progress", uv(e.onUploadProgress)), (e.cancelToken || e.signal) && (s = (f) => {
      l && (r(!f || f.type ? new sc(null, e, l) : f), l.abort(), l = null);
    }, e.cancelToken && e.cancelToken.subscribe(s), e.signal && (e.signal.aborted ? s() : e.signal.addEventListener("abort", s)));
    const p = aU(u);
    if (p && Br.protocols.indexOf(p) === -1) {
      r(new Rt("Unsupported protocol " + p + ":", Rt.ERR_BAD_REQUEST, e));
      return;
    }
    l.send(i || null);
  });
}, tl = {
  http: eU,
  xhr: lU
};
oe.forEach(tl, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const uU = {
  getAdapter: (e) => {
    e = oe.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    for (let i = 0; i < t && (n = e[i], !(r = oe.isString(n) ? tl[n.toLowerCase()] : n)); i++)
      ;
    if (!r)
      throw r === !1 ? new Rt(
        `Adapter ${n} is not supported by the environment`,
        "ERR_NOT_SUPPORT"
      ) : new Error(
        oe.hasOwnProp(tl, n) ? `Adapter '${n}' is not available in the build` : `Unknown adapter '${n}'`
      );
    if (!oe.isFunction(r))
      throw new TypeError("adapter is not a function");
    return r;
  },
  adapters: tl
};
function Cf(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new sc(null, e);
}
function dv(e) {
  return Cf(e), e.headers = ci.from(e.headers), e.data = Ef.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), uU.getAdapter(e.adapter || Fm.adapter)(e).then(function(r) {
    return Cf(e), r.data = Ef.call(
      e,
      e.transformResponse,
      r
    ), r.headers = ci.from(r.headers), r;
  }, function(r) {
    return vk(r) || (Cf(e), r && r.response && (r.response.data = Ef.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = ci.from(r.response.headers))), Promise.reject(r);
  });
}
const fv = (e) => e instanceof ci ? e.toJSON() : e;
function wa(e, t) {
  t = t || {};
  const n = {};
  function r(l, u, d) {
    return oe.isPlainObject(l) && oe.isPlainObject(u) ? oe.merge.call({ caseless: d }, l, u) : oe.isPlainObject(u) ? oe.merge({}, u) : oe.isArray(u) ? u.slice() : u;
  }
  function i(l, u, d) {
    if (oe.isUndefined(u)) {
      if (!oe.isUndefined(l))
        return r(void 0, l, d);
    } else
      return r(l, u, d);
  }
  function o(l, u) {
    if (!oe.isUndefined(u))
      return r(void 0, u);
  }
  function a(l, u) {
    if (oe.isUndefined(u)) {
      if (!oe.isUndefined(l))
        return r(void 0, l);
    } else
      return r(void 0, u);
  }
  function s(l, u, d) {
    if (d in t)
      return r(l, u);
    if (d in e)
      return r(void 0, l);
  }
  const c = {
    url: o,
    method: o,
    data: o,
    baseURL: a,
    transformRequest: a,
    transformResponse: a,
    paramsSerializer: a,
    timeout: a,
    timeoutMessage: a,
    withCredentials: a,
    adapter: a,
    responseType: a,
    xsrfCookieName: a,
    xsrfHeaderName: a,
    onUploadProgress: a,
    onDownloadProgress: a,
    decompress: a,
    maxContentLength: a,
    maxBodyLength: a,
    beforeRedirect: a,
    transport: a,
    httpAgent: a,
    httpsAgent: a,
    cancelToken: a,
    socketPath: a,
    responseEncoding: a,
    validateStatus: s,
    headers: (l, u) => i(fv(l), fv(u), !0)
  };
  return oe.forEach(Object.keys(e).concat(Object.keys(t)), function(u) {
    const d = c[u] || i, p = d(e[u], t[u], u);
    oe.isUndefined(p) && d !== s || (n[u] = p);
  }), n;
}
const wk = "1.2.5", Um = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Um[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const pv = {};
Um.transitional = function(t, n, r) {
  function i(o, a) {
    return "[Axios v" + wk + "] Transitional option '" + o + "'" + a + (r ? ". " + r : "");
  }
  return (o, a, s) => {
    if (t === !1)
      throw new Rt(
        i(a, " has been removed" + (n ? " in " + n : "")),
        Rt.ERR_DEPRECATED
      );
    return n && !pv[a] && (pv[a] = !0, console.warn(
      i(
        a,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(o, a, s) : !0;
  };
};
function dU(e, t, n) {
  if (typeof e != "object")
    throw new Rt("options must be an object", Rt.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const o = r[i], a = t[o];
    if (a) {
      const s = e[o], c = s === void 0 || a(s, o, e);
      if (c !== !0)
        throw new Rt("option " + o + " must be " + c, Rt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new Rt("Unknown option " + o, Rt.ERR_BAD_OPTION);
  }
}
const zp = {
  assertOptions: dU,
  validators: Um
}, ki = zp.validators;
class hu {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new sv(),
      response: new sv()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = wa(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: o } = n;
    r !== void 0 && zp.assertOptions(r, {
      silentJSONParsing: ki.transitional(ki.boolean),
      forcedJSONParsing: ki.transitional(ki.boolean),
      clarifyTimeoutError: ki.transitional(ki.boolean)
    }, !1), i !== void 0 && zp.assertOptions(i, {
      encode: ki.function,
      serialize: ki.function
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let a;
    a = o && oe.merge(
      o.common,
      o[n.method]
    ), a && oe.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (h) => {
        delete o[h];
      }
    ), n.headers = ci.concat(a, o);
    const s = [];
    let c = !0;
    this.interceptors.request.forEach(function(m) {
      typeof m.runWhen == "function" && m.runWhen(n) === !1 || (c = c && m.synchronous, s.unshift(m.fulfilled, m.rejected));
    });
    const l = [];
    this.interceptors.response.forEach(function(m) {
      l.push(m.fulfilled, m.rejected);
    });
    let u, d = 0, p;
    if (!c) {
      const h = [dv.bind(this), void 0];
      for (h.unshift.apply(h, s), h.push.apply(h, l), p = h.length, u = Promise.resolve(n); d < p; )
        u = u.then(h[d++], h[d++]);
      return u;
    }
    p = s.length;
    let f = n;
    for (d = 0; d < p; ) {
      const h = s[d++], m = s[d++];
      try {
        f = h(f);
      } catch (y) {
        m.call(this, y);
        break;
      }
    }
    try {
      u = dv.call(this, f);
    } catch (h) {
      return Promise.reject(h);
    }
    for (d = 0, p = l.length; d < p; )
      u = u.then(l[d++], l[d++]);
    return u;
  }
  getUri(t) {
    t = wa(this.defaults, t);
    const n = bk(t.baseURL, t.url);
    return mk(n, t.params, t.paramsSerializer);
  }
}
oe.forEach(["delete", "get", "head", "options"], function(t) {
  hu.prototype[t] = function(n, r) {
    return this.request(wa(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
oe.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(o, a, s) {
      return this.request(wa(s || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: a
      }));
    };
  }
  hu.prototype[t] = n(), hu.prototype[t + "Form"] = n(!0);
});
const nl = hu;
class Bm {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(o) {
      n = o;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners)
        return;
      let o = r._listeners.length;
      for (; o-- > 0; )
        r._listeners[o](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let o;
      const a = new Promise((s) => {
        r.subscribe(s), o = s;
      }).then(i);
      return a.cancel = function() {
        r.unsubscribe(o);
      }, a;
    }, t(function(o, a, s) {
      r.reason || (r.reason = new sc(o, a, s), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new Bm(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
}
const fU = Bm;
function pU(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function hU(e) {
  return oe.isObject(e) && e.isAxiosError === !0;
}
const Zp = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Zp).forEach(([e, t]) => {
  Zp[t] = e;
});
const mU = Zp;
function xk(e) {
  const t = new nl(e), n = rk(nl.prototype.request, t);
  return oe.extend(n, nl.prototype, t, { allOwnKeys: !0 }), oe.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return xk(wa(e, i));
  }, n;
}
const pn = xk(Fm);
pn.Axios = nl;
pn.CanceledError = sc;
pn.CancelToken = fU;
pn.isCancel = vk;
pn.VERSION = wk;
pn.toFormData = Nd;
pn.AxiosError = Rt;
pn.Cancel = pn.CanceledError;
pn.all = function(t) {
  return Promise.all(t);
};
pn.spread = pU;
pn.isAxiosError = hU;
pn.mergeConfig = wa;
pn.AxiosHeaders = ci;
pn.formToJSON = (e) => gk(oe.isHTMLForm(e) ? new FormData(e) : e);
pn.HttpStatusCode = mU;
pn.default = pn;
const _k = pn, yU = {
  // Fallback in case crypto isn't available.
  getRandomValues: (e) => new Uint8Array(e.map(() => Math.floor(Math.random() * 256)))
};
let Vp = typeof window < "u" && typeof window.document < "u" ? window.crypto : Bh;
Vp.getRandomValues || (Vp = yU);
class qt extends Error {
  constructor(n, r, i, o, a, s) {
    super(o);
    k(this, "isApiError", !0);
    this.code = n, this.description = r, this.type = i, this.message = o, this.error = a, this.id = s, this.id || (this.id = qt.generateId());
  }
  format() {
    return `[${this.type}] ${this.message} (Error ID: ${this.id})`;
  }
  toJSON() {
    return {
      id: this.id,
      code: this.code,
      type: this.type,
      message: this.message
    };
  }
  static generateId() {
    const n = this.getPrefix(), r = (/* @__PURE__ */ new Date()).toISOString().replace(/[\-:TZ]/g, "").split(".")[0], i = 4, o = Array.from(Vp.getRandomValues(new Uint8Array(i))).map((a) => a.toString(16).padStart(2, "0")).join("").toUpperCase();
    return `${n}_${r}x${o}`;
  }
  static getPrefix() {
    return typeof window < "u" && typeof window.document < "u" ? "err_bwsr" : "err";
  }
}
const gU = (e) => typeof e == "object" && !Array.isArray(e) && e !== null, Hp = (e) => e instanceof qt || gU(e) && e.isApiError === !0;
class ws extends qt {
  constructor(t, n, r) {
    super(500, "An unknown error occurred", "Unknown", t, n, r);
  }
}
class vU extends qt {
  constructor(t, n, r) {
    super(500, "An internal error occurred", "Internal", t, n, r);
  }
}
class bU extends qt {
  constructor(t, n, r) {
    super(401, "The request requires to be authenticated.", "Unauthorized", t, n, r);
  }
}
class wU extends qt {
  constructor(t, n, r) {
    super(403, "The requested action can't be peform by this resource.", "Forbidden", t, n, r);
  }
}
class xU extends qt {
  constructor(t, n, r) {
    super(413, "The request payload is too large.", "PayloadTooLarge", t, n, r);
  }
}
class _U extends qt {
  constructor(t, n, r) {
    super(400, "The request payload is invalid.", "InvalidPayload", t, n, r);
  }
}
class SU extends qt {
  constructor(t, n, r) {
    super(415, "The request is invalid because the content-type is not supported.", "UnsupportedMediaType", t, n, r);
  }
}
class kU extends qt {
  constructor(t, n, r) {
    super(405, "The requested method does not exist.", "MethodNotFound", t, n, r);
  }
}
class EU extends qt {
  constructor(t, n, r) {
    super(404, "The requested resource does not exist.", "ResourceNotFound", t, n, r);
  }
}
class CU extends qt {
  constructor(t, n, r) {
    super(400, "The provided JSON schema is invalid.", "InvalidJsonSchema", t, n, r);
  }
}
class TU extends qt {
  constructor(t, n, r) {
    super(400, "The provided data doesn't respect the provided JSON schema.", "InvalidDataFormat", t, n, r);
  }
}
class RU extends qt {
  constructor(t, n, r) {
    super(400, "The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.", "InvalidIdentifier", t, n, r);
  }
}
class AU extends qt {
  constructor(t, n, r) {
    super(409, "The resource is related with a different resource that the one referenced in the request. This is usually caused when providing two resource identifiers that aren't linked together.", "RelationConflict", t, n, r);
  }
}
class OU extends qt {
  constructor(t, n, r) {
    super(409, "The resource cannot be deleted because it's referenced by another resource", "ReferenceConstraint", t, n, r);
  }
}
class IU extends qt {
  constructor(t, n, r) {
    super(409, "The resource is current locked and cannot be operated on until the lock is released.", "ResourceLockedConflict", t, n, r);
  }
}
class PU extends qt {
  constructor(t, n, r) {
    super(400, "The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.", "ReferenceNotFound", t, n, r);
  }
}
class $U extends qt {
  constructor(t, n, r) {
    super(400, "The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.", "InvalidQuery", t, n, r);
  }
}
class DU extends qt {
  constructor(t, n, r) {
    super(400, "An error happened during the execution of a runtime (bot or integration).", "Runtime", t, n, r);
  }
}
class NU extends qt {
  constructor(t, n, r) {
    super(409, "The record attempted to be created already exists.", "AlreadyExists", t, n, r);
  }
}
class jU extends qt {
  constructor(t, n, r) {
    super(429, "The request has been rate limited.", "RateLimited", t, n, r);
  }
}
class MU extends qt {
  constructor(t, n, r) {
    super(402, "A payment is required to perform this request.", "PaymentRequired", t, n, r);
  }
}
class qU extends qt {
  constructor(t, n, r) {
    super(403, "The request exceeds the allowed quota. Quotas are a soft limit that can be increased.", "QuotaExceeded", t, n, r);
  }
}
class LU extends qt {
  constructor(t, n, r) {
    super(413, "The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.", "LimitExceeded", t, n, r);
  }
}
class FU extends qt {
  constructor(t, n, r) {
    super(400, "Request payload contains breaking changes which is not allowed for this resource without a version increment.", "BreakingChanges", t, n, r);
  }
}
const UU = {
  Unknown: ws,
  Internal: vU,
  Unauthorized: bU,
  Forbidden: wU,
  PayloadTooLarge: xU,
  InvalidPayload: _U,
  UnsupportedMediaType: SU,
  MethodNotFound: kU,
  ResourceNotFound: EU,
  InvalidJsonSchema: CU,
  InvalidDataFormat: TU,
  InvalidIdentifier: RU,
  RelationConflict: AU,
  ReferenceConstraint: OU,
  ResourceLockedConflict: IU,
  ReferenceNotFound: PU,
  InvalidQuery: $U,
  Runtime: DU,
  AlreadyExists: NU,
  RateLimited: jU,
  PaymentRequired: MU,
  QuotaExceeded: qU,
  LimitExceeded: LU,
  BreakingChanges: FU
}, hv = (e) => Hp(e) ? e : e instanceof Error ? new ws(e.message, e) : typeof e == "string" ? new ws(e) : BU(e);
function BU(e) {
  if (typeof e == "object" && "code" in e && "type" in e && "id" in e && "message" in e && typeof e.type == "string" && typeof e.message == "string") {
    const t = UU[e.type];
    return t ? new t(e.message, void 0, e.id || "UNKNOWN") : new ws(`An unclassified API error occurred: ${e.message} (Type: ${e.type}, Code: ${e.code})`);
  }
  return new ws("An invalid error occurred: " + JSON.stringify(e));
}
var zU = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, n = Symbol("test"), r = Object(n);
  if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
    return !1;
  var i = 42;
  t[n] = i;
  for (n in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var o = Object.getOwnPropertySymbols(t);
  if (o.length !== 1 || o[0] !== n || !Object.prototype.propertyIsEnumerable.call(t, n))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var a = Object.getOwnPropertyDescriptor(t, n);
    if (a.value !== i || a.enumerable !== !0)
      return !1;
  }
  return !0;
}, mv = typeof Symbol < "u" && Symbol, ZU = zU, VU = function() {
  return typeof mv != "function" || typeof Symbol != "function" || typeof mv("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : ZU();
}, yv = {
  foo: {}
}, HU = Object, WU = function() {
  return { __proto__: yv }.foo === yv.foo && !({ __proto__: null } instanceof HU);
}, KU = "Function.prototype.bind called on incompatible ", JU = Object.prototype.toString, YU = Math.max, GU = "[object Function]", gv = function(t, n) {
  for (var r = [], i = 0; i < t.length; i += 1)
    r[i] = t[i];
  for (var o = 0; o < n.length; o += 1)
    r[o + t.length] = n[o];
  return r;
}, XU = function(t, n) {
  for (var r = [], i = n || 0, o = 0; i < t.length; i += 1, o += 1)
    r[o] = t[i];
  return r;
}, QU = function(e, t) {
  for (var n = "", r = 0; r < e.length; r += 1)
    n += e[r], r + 1 < e.length && (n += t);
  return n;
}, eB = function(t) {
  var n = this;
  if (typeof n != "function" || JU.apply(n) !== GU)
    throw new TypeError(KU + n);
  for (var r = XU(arguments, 1), i, o = function() {
    if (this instanceof i) {
      var u = n.apply(
        this,
        gv(r, arguments)
      );
      return Object(u) === u ? u : this;
    }
    return n.apply(
      t,
      gv(r, arguments)
    );
  }, a = YU(0, n.length - r.length), s = [], c = 0; c < a; c++)
    s[c] = "$" + c;
  if (i = Function("binder", "return function (" + QU(s, ",") + "){ return binder.apply(this,arguments); }")(o), n.prototype) {
    var l = function() {
    };
    l.prototype = n.prototype, i.prototype = new l(), l.prototype = null;
  }
  return i;
}, tB = eB, zm = Function.prototype.bind || tB, nB = zm, rB = nB.call(Function.call, Object.prototype.hasOwnProperty), xt, xa = SyntaxError, Sk = Function, na = TypeError, Tf = function(e) {
  try {
    return Sk('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, uo = Object.getOwnPropertyDescriptor;
if (uo)
  try {
    uo({}, "");
  } catch {
    uo = null;
  }
var Rf = function() {
  throw new na();
}, iB = uo ? function() {
  try {
    return arguments.callee, Rf;
  } catch {
    try {
      return uo(arguments, "callee").get;
    } catch {
      return Rf;
    }
  }
}() : Rf, Mo = VU(), oB = WU(), vn = Object.getPrototypeOf || (oB ? function(e) {
  return e.__proto__;
} : null), Ho = {}, aB = typeof Uint8Array > "u" || !vn ? xt : vn(Uint8Array), fo = {
  "%AggregateError%": typeof AggregateError > "u" ? xt : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? xt : ArrayBuffer,
  "%ArrayIteratorPrototype%": Mo && vn ? vn([][Symbol.iterator]()) : xt,
  "%AsyncFromSyncIteratorPrototype%": xt,
  "%AsyncFunction%": Ho,
  "%AsyncGenerator%": Ho,
  "%AsyncGeneratorFunction%": Ho,
  "%AsyncIteratorPrototype%": Ho,
  "%Atomics%": typeof Atomics > "u" ? xt : Atomics,
  "%BigInt%": typeof BigInt > "u" ? xt : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? xt : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? xt : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? xt : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? xt : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? xt : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? xt : FinalizationRegistry,
  "%Function%": Sk,
  "%GeneratorFunction%": Ho,
  "%Int8Array%": typeof Int8Array > "u" ? xt : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? xt : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? xt : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Mo && vn ? vn(vn([][Symbol.iterator]())) : xt,
  "%JSON%": typeof JSON == "object" ? JSON : xt,
  "%Map%": typeof Map > "u" ? xt : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Mo || !vn ? xt : vn((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? xt : Promise,
  "%Proxy%": typeof Proxy > "u" ? xt : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? xt : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? xt : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Mo || !vn ? xt : vn((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? xt : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Mo && vn ? vn(""[Symbol.iterator]()) : xt,
  "%Symbol%": Mo ? Symbol : xt,
  "%SyntaxError%": xa,
  "%ThrowTypeError%": iB,
  "%TypedArray%": aB,
  "%TypeError%": na,
  "%Uint8Array%": typeof Uint8Array > "u" ? xt : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? xt : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? xt : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? xt : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? xt : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? xt : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? xt : WeakSet
};
if (vn)
  try {
    null.error;
  } catch (e) {
    var sB = vn(vn(e));
    fo["%Error.prototype%"] = sB;
  }
var cB = function e(t) {
  var n;
  if (t === "%AsyncFunction%")
    n = Tf("async function () {}");
  else if (t === "%GeneratorFunction%")
    n = Tf("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    n = Tf("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var r = e("%AsyncGeneratorFunction%");
    r && (n = r.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var i = e("%AsyncGenerator%");
    i && vn && (n = vn(i.prototype));
  }
  return fo[t] = n, n;
}, vv = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, cc = zm, mu = rB, lB = cc.call(Function.call, Array.prototype.concat), uB = cc.call(Function.apply, Array.prototype.splice), bv = cc.call(Function.call, String.prototype.replace), yu = cc.call(Function.call, String.prototype.slice), dB = cc.call(Function.call, RegExp.prototype.exec), fB = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, pB = /\\(\\)?/g, hB = function(t) {
  var n = yu(t, 0, 1), r = yu(t, -1);
  if (n === "%" && r !== "%")
    throw new xa("invalid intrinsic syntax, expected closing `%`");
  if (r === "%" && n !== "%")
    throw new xa("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return bv(t, fB, function(o, a, s, c) {
    i[i.length] = s ? bv(c, pB, "$1") : a || o;
  }), i;
}, mB = function(t, n) {
  var r = t, i;
  if (mu(vv, r) && (i = vv[r], r = "%" + i[0] + "%"), mu(fo, r)) {
    var o = fo[r];
    if (o === Ho && (o = cB(r)), typeof o > "u" && !n)
      throw new na("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: r,
      value: o
    };
  }
  throw new xa("intrinsic " + t + " does not exist!");
}, Zm = function(t, n) {
  if (typeof t != "string" || t.length === 0)
    throw new na("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean")
    throw new na('"allowMissing" argument must be a boolean');
  if (dB(/^%?[^%]*%?$/, t) === null)
    throw new xa("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var r = hB(t), i = r.length > 0 ? r[0] : "", o = mB("%" + i + "%", n), a = o.name, s = o.value, c = !1, l = o.alias;
  l && (i = l[0], uB(r, lB([0, 1], l)));
  for (var u = 1, d = !0; u < r.length; u += 1) {
    var p = r[u], f = yu(p, 0, 1), h = yu(p, -1);
    if ((f === '"' || f === "'" || f === "`" || h === '"' || h === "'" || h === "`") && f !== h)
      throw new xa("property names with quotes must have matching quotes");
    if ((p === "constructor" || !d) && (c = !0), i += "." + p, a = "%" + i + "%", mu(fo, a))
      s = fo[a];
    else if (s != null) {
      if (!(p in s)) {
        if (!n)
          throw new na("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (uo && u + 1 >= r.length) {
        var m = uo(s, p);
        d = !!m, d && "get" in m && !("originalValue" in m.get) ? s = m.get : s = s[p];
      } else
        d = mu(s, p), s = s[p];
      d && !c && (fo[a] = s);
    }
  }
  return s;
}, kk = { exports: {} };
(function(e) {
  var t = zm, n = Zm, r = n("%Function.prototype.apply%"), i = n("%Function.prototype.call%"), o = n("%Reflect.apply%", !0) || t.call(i, r), a = n("%Object.getOwnPropertyDescriptor%", !0), s = n("%Object.defineProperty%", !0), c = n("%Math.max%");
  if (s)
    try {
      s({}, "a", { value: 1 });
    } catch {
      s = null;
    }
  e.exports = function(d) {
    var p = o(t, i, arguments);
    if (a && s) {
      var f = a(p, "length");
      f.configurable && s(
        p,
        "length",
        { value: 1 + c(0, d.length - (arguments.length - 1)) }
      );
    }
    return p;
  };
  var l = function() {
    return o(t, r, arguments);
  };
  s ? s(e.exports, "apply", { value: l }) : e.exports.apply = l;
})(kk);
var yB = kk.exports, Ek = Zm, Ck = yB, gB = Ck(Ek("String.prototype.indexOf")), vB = function(t, n) {
  var r = Ek(t, !!n);
  return typeof r == "function" && gB(t, ".prototype.") > -1 ? Ck(r) : r;
}, Vm = typeof Map == "function" && Map.prototype, Af = Object.getOwnPropertyDescriptor && Vm ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, gu = Vm && Af && typeof Af.get == "function" ? Af.get : null, wv = Vm && Map.prototype.forEach, Hm = typeof Set == "function" && Set.prototype, Of = Object.getOwnPropertyDescriptor && Hm ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, vu = Hm && Of && typeof Of.get == "function" ? Of.get : null, xv = Hm && Set.prototype.forEach, bB = typeof WeakMap == "function" && WeakMap.prototype, os = bB ? WeakMap.prototype.has : null, wB = typeof WeakSet == "function" && WeakSet.prototype, as = wB ? WeakSet.prototype.has : null, xB = typeof WeakRef == "function" && WeakRef.prototype, _v = xB ? WeakRef.prototype.deref : null, _B = Boolean.prototype.valueOf, SB = Object.prototype.toString, kB = Function.prototype.toString, EB = String.prototype.match, Wm = String.prototype.slice, Pi = String.prototype.replace, CB = String.prototype.toUpperCase, Sv = String.prototype.toLowerCase, Tk = RegExp.prototype.test, kv = Array.prototype.concat, Fr = Array.prototype.join, TB = Array.prototype.slice, Ev = Math.floor, Wp = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, If = Object.getOwnPropertySymbols, Kp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, _a = typeof Symbol == "function" && typeof Symbol.iterator == "object", Mn = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === _a || "symbol") ? Symbol.toStringTag : null, Rk = Object.prototype.propertyIsEnumerable, Cv = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
  return e.__proto__;
} : null);
function Tv(e, t) {
  if (e === 1 / 0 || e === -1 / 0 || e !== e || e && e > -1e3 && e < 1e3 || Tk.call(/e/, t))
    return t;
  var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof e == "number") {
    var r = e < 0 ? -Ev(-e) : Ev(e);
    if (r !== e) {
      var i = String(r), o = Wm.call(t, i.length + 1);
      return Pi.call(i, n, "$&_") + "." + Pi.call(Pi.call(o, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return Pi.call(t, n, "$&_");
}
var Jp = fp, Rv = Jp.custom, Av = Ok(Rv) ? Rv : null, RB = function e(t, n, r, i) {
  var o = n || {};
  if (Ti(o, "quoteStyle") && o.quoteStyle !== "single" && o.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (Ti(o, "maxStringLength") && (typeof o.maxStringLength == "number" ? o.maxStringLength < 0 && o.maxStringLength !== 1 / 0 : o.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var a = Ti(o, "customInspect") ? o.customInspect : !0;
  if (typeof a != "boolean" && a !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (Ti(o, "indent") && o.indent !== null && o.indent !== "	" && !(parseInt(o.indent, 10) === o.indent && o.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (Ti(o, "numericSeparator") && typeof o.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var s = o.numericSeparator;
  if (typeof t > "u")
    return "undefined";
  if (t === null)
    return "null";
  if (typeof t == "boolean")
    return t ? "true" : "false";
  if (typeof t == "string")
    return Pk(t, o);
  if (typeof t == "number") {
    if (t === 0)
      return 1 / 0 / t > 0 ? "0" : "-0";
    var c = String(t);
    return s ? Tv(t, c) : c;
  }
  if (typeof t == "bigint") {
    var l = String(t) + "n";
    return s ? Tv(t, l) : l;
  }
  var u = typeof o.depth > "u" ? 5 : o.depth;
  if (typeof r > "u" && (r = 0), r >= u && u > 0 && typeof t == "object")
    return Yp(t) ? "[Array]" : "[Object]";
  var d = HB(o, r);
  if (typeof i > "u")
    i = [];
  else if (Ik(i, t) >= 0)
    return "[Circular]";
  function p(U, L, $) {
    if (L && (i = TB.call(i), i.push(L)), $) {
      var j = {
        depth: o.depth
      };
      return Ti(o, "quoteStyle") && (j.quoteStyle = o.quoteStyle), e(U, j, r + 1, i);
    }
    return e(U, o, r + 1, i);
  }
  if (typeof t == "function" && !Ov(t)) {
    var f = MB(t), h = Rc(t, p);
    return "[Function" + (f ? ": " + f : " (anonymous)") + "]" + (h.length > 0 ? " { " + Fr.call(h, ", ") + " }" : "");
  }
  if (Ok(t)) {
    var m = _a ? Pi.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : Kp.call(t);
    return typeof t == "object" && !_a ? Ka(m) : m;
  }
  if (zB(t)) {
    for (var y = "<" + Sv.call(String(t.nodeName)), g = t.attributes || [], v = 0; v < g.length; v++)
      y += " " + g[v].name + "=" + Ak(AB(g[v].value), "double", o);
    return y += ">", t.childNodes && t.childNodes.length && (y += "..."), y += "</" + Sv.call(String(t.nodeName)) + ">", y;
  }
  if (Yp(t)) {
    if (t.length === 0)
      return "[]";
    var b = Rc(t, p);
    return d && !VB(b) ? "[" + Gp(b, d) + "]" : "[ " + Fr.call(b, ", ") + " ]";
  }
  if (IB(t)) {
    var _ = Rc(t, p);
    return !("cause" in Error.prototype) && "cause" in t && !Rk.call(t, "cause") ? "{ [" + String(t) + "] " + Fr.call(kv.call("[cause]: " + p(t.cause), _), ", ") + " }" : _.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + Fr.call(_, ", ") + " }";
  }
  if (typeof t == "object" && a) {
    if (Av && typeof t[Av] == "function" && Jp)
      return Jp(t, { depth: u - r });
    if (a !== "symbol" && typeof t.inspect == "function")
      return t.inspect();
  }
  if (qB(t)) {
    var S = [];
    return wv && wv.call(t, function(U, L) {
      S.push(p(L, t, !0) + " => " + p(U, t));
    }), Iv("Map", gu.call(t), S, d);
  }
  if (UB(t)) {
    var x = [];
    return xv && xv.call(t, function(U) {
      x.push(p(U, t));
    }), Iv("Set", vu.call(t), x, d);
  }
  if (LB(t))
    return Pf("WeakMap");
  if (BB(t))
    return Pf("WeakSet");
  if (FB(t))
    return Pf("WeakRef");
  if ($B(t))
    return Ka(p(Number(t)));
  if (NB(t))
    return Ka(p(Wp.call(t)));
  if (DB(t))
    return Ka(_B.call(t));
  if (PB(t))
    return Ka(p(String(t)));
  if (!OB(t) && !Ov(t)) {
    var A = Rc(t, p), I = Cv ? Cv(t) === Object.prototype : t instanceof Object || t.constructor === Object, P = t instanceof Object ? "" : "null prototype", R = !I && Mn && Object(t) === t && Mn in t ? Wm.call(Ki(t), 8, -1) : P ? "Object" : "", M = I || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : "", V = M + (R || P ? "[" + Fr.call(kv.call([], R || [], P || []), ": ") + "] " : "");
    return A.length === 0 ? V + "{}" : d ? V + "{" + Gp(A, d) + "}" : V + "{ " + Fr.call(A, ", ") + " }";
  }
  return String(t);
};
function Ak(e, t, n) {
  var r = (n.quoteStyle || t) === "double" ? '"' : "'";
  return r + e + r;
}
function AB(e) {
  return Pi.call(String(e), /"/g, "&quot;");
}
function Yp(e) {
  return Ki(e) === "[object Array]" && (!Mn || !(typeof e == "object" && Mn in e));
}
function OB(e) {
  return Ki(e) === "[object Date]" && (!Mn || !(typeof e == "object" && Mn in e));
}
function Ov(e) {
  return Ki(e) === "[object RegExp]" && (!Mn || !(typeof e == "object" && Mn in e));
}
function IB(e) {
  return Ki(e) === "[object Error]" && (!Mn || !(typeof e == "object" && Mn in e));
}
function PB(e) {
  return Ki(e) === "[object String]" && (!Mn || !(typeof e == "object" && Mn in e));
}
function $B(e) {
  return Ki(e) === "[object Number]" && (!Mn || !(typeof e == "object" && Mn in e));
}
function DB(e) {
  return Ki(e) === "[object Boolean]" && (!Mn || !(typeof e == "object" && Mn in e));
}
function Ok(e) {
  if (_a)
    return e && typeof e == "object" && e instanceof Symbol;
  if (typeof e == "symbol")
    return !0;
  if (!e || typeof e != "object" || !Kp)
    return !1;
  try {
    return Kp.call(e), !0;
  } catch {
  }
  return !1;
}
function NB(e) {
  if (!e || typeof e != "object" || !Wp)
    return !1;
  try {
    return Wp.call(e), !0;
  } catch {
  }
  return !1;
}
var jB = Object.prototype.hasOwnProperty || function(e) {
  return e in this;
};
function Ti(e, t) {
  return jB.call(e, t);
}
function Ki(e) {
  return SB.call(e);
}
function MB(e) {
  if (e.name)
    return e.name;
  var t = EB.call(kB.call(e), /^function\s*([\w$]+)/);
  return t ? t[1] : null;
}
function Ik(e, t) {
  if (e.indexOf)
    return e.indexOf(t);
  for (var n = 0, r = e.length; n < r; n++)
    if (e[n] === t)
      return n;
  return -1;
}
function qB(e) {
  if (!gu || !e || typeof e != "object")
    return !1;
  try {
    gu.call(e);
    try {
      vu.call(e);
    } catch {
      return !0;
    }
    return e instanceof Map;
  } catch {
  }
  return !1;
}
function LB(e) {
  if (!os || !e || typeof e != "object")
    return !1;
  try {
    os.call(e, os);
    try {
      as.call(e, as);
    } catch {
      return !0;
    }
    return e instanceof WeakMap;
  } catch {
  }
  return !1;
}
function FB(e) {
  if (!_v || !e || typeof e != "object")
    return !1;
  try {
    return _v.call(e), !0;
  } catch {
  }
  return !1;
}
function UB(e) {
  if (!vu || !e || typeof e != "object")
    return !1;
  try {
    vu.call(e);
    try {
      gu.call(e);
    } catch {
      return !0;
    }
    return e instanceof Set;
  } catch {
  }
  return !1;
}
function BB(e) {
  if (!as || !e || typeof e != "object")
    return !1;
  try {
    as.call(e, as);
    try {
      os.call(e, os);
    } catch {
      return !0;
    }
    return e instanceof WeakSet;
  } catch {
  }
  return !1;
}
function zB(e) {
  return !e || typeof e != "object" ? !1 : typeof HTMLElement < "u" && e instanceof HTMLElement ? !0 : typeof e.nodeName == "string" && typeof e.getAttribute == "function";
}
function Pk(e, t) {
  if (e.length > t.maxStringLength) {
    var n = e.length - t.maxStringLength, r = "... " + n + " more character" + (n > 1 ? "s" : "");
    return Pk(Wm.call(e, 0, t.maxStringLength), t) + r;
  }
  var i = Pi.call(Pi.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, ZB);
  return Ak(i, "single", t);
}
function ZB(e) {
  var t = e.charCodeAt(0), n = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[t];
  return n ? "\\" + n : "\\x" + (t < 16 ? "0" : "") + CB.call(t.toString(16));
}
function Ka(e) {
  return "Object(" + e + ")";
}
function Pf(e) {
  return e + " { ? }";
}
function Iv(e, t, n, r) {
  var i = r ? Gp(n, r) : Fr.call(n, ", ");
  return e + " (" + t + ") {" + i + "}";
}
function VB(e) {
  for (var t = 0; t < e.length; t++)
    if (Ik(e[t], `
`) >= 0)
      return !1;
  return !0;
}
function HB(e, t) {
  var n;
  if (e.indent === "	")
    n = "	";
  else if (typeof e.indent == "number" && e.indent > 0)
    n = Fr.call(Array(e.indent + 1), " ");
  else
    return null;
  return {
    base: n,
    prev: Fr.call(Array(t + 1), n)
  };
}
function Gp(e, t) {
  if (e.length === 0)
    return "";
  var n = `
` + t.prev + t.base;
  return n + Fr.call(e, "," + n) + `
` + t.prev;
}
function Rc(e, t) {
  var n = Yp(e), r = [];
  if (n) {
    r.length = e.length;
    for (var i = 0; i < e.length; i++)
      r[i] = Ti(e, i) ? t(e[i], e) : "";
  }
  var o = typeof If == "function" ? If(e) : [], a;
  if (_a) {
    a = {};
    for (var s = 0; s < o.length; s++)
      a["$" + o[s]] = o[s];
  }
  for (var c in e)
    Ti(e, c) && (n && String(Number(c)) === c && c < e.length || _a && a["$" + c] instanceof Symbol || (Tk.call(/[^\w$]/, c) ? r.push(t(c, e) + ": " + t(e[c], e)) : r.push(c + ": " + t(e[c], e))));
  if (typeof If == "function")
    for (var l = 0; l < o.length; l++)
      Rk.call(e, o[l]) && r.push("[" + t(o[l]) + "]: " + t(e[o[l]], e));
  return r;
}
var Km = Zm, Fa = vB, WB = RB, KB = Km("%TypeError%"), Ac = Km("%WeakMap%", !0), Oc = Km("%Map%", !0), JB = Fa("WeakMap.prototype.get", !0), YB = Fa("WeakMap.prototype.set", !0), GB = Fa("WeakMap.prototype.has", !0), XB = Fa("Map.prototype.get", !0), QB = Fa("Map.prototype.set", !0), ez = Fa("Map.prototype.has", !0), Jm = function(e, t) {
  for (var n = e, r; (r = n.next) !== null; n = r)
    if (r.key === t)
      return n.next = r.next, r.next = e.next, e.next = r, r;
}, tz = function(e, t) {
  var n = Jm(e, t);
  return n && n.value;
}, nz = function(e, t, n) {
  var r = Jm(e, t);
  r ? r.value = n : e.next = {
    // eslint-disable-line no-param-reassign
    key: t,
    next: e.next,
    value: n
  };
}, rz = function(e, t) {
  return !!Jm(e, t);
}, iz = function() {
  var t, n, r, i = {
    assert: function(o) {
      if (!i.has(o))
        throw new KB("Side channel does not contain " + WB(o));
    },
    get: function(o) {
      if (Ac && o && (typeof o == "object" || typeof o == "function")) {
        if (t)
          return JB(t, o);
      } else if (Oc) {
        if (n)
          return XB(n, o);
      } else if (r)
        return tz(r, o);
    },
    has: function(o) {
      if (Ac && o && (typeof o == "object" || typeof o == "function")) {
        if (t)
          return GB(t, o);
      } else if (Oc) {
        if (n)
          return ez(n, o);
      } else if (r)
        return rz(r, o);
      return !1;
    },
    set: function(o, a) {
      Ac && o && (typeof o == "object" || typeof o == "function") ? (t || (t = new Ac()), YB(t, o, a)) : Oc ? (n || (n = new Oc()), QB(n, o, a)) : (r || (r = { key: {}, next: null }), nz(r, o, a));
    }
  };
  return i;
}, oz = String.prototype.replace, az = /%20/g, $f = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
}, Ym = {
  default: $f.RFC3986,
  formatters: {
    RFC1738: function(e) {
      return oz.call(e, az, "+");
    },
    RFC3986: function(e) {
      return String(e);
    }
  },
  RFC1738: $f.RFC1738,
  RFC3986: $f.RFC3986
}, sz = Ym, Df = Object.prototype.hasOwnProperty, ao = Array.isArray, jr = function() {
  for (var e = [], t = 0; t < 256; ++t)
    e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
  return e;
}(), cz = function(t) {
  for (; t.length > 1; ) {
    var n = t.pop(), r = n.obj[n.prop];
    if (ao(r)) {
      for (var i = [], o = 0; o < r.length; ++o)
        typeof r[o] < "u" && i.push(r[o]);
      n.obj[n.prop] = i;
    }
  }
}, $k = function(t, n) {
  for (var r = n && n.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, i = 0; i < t.length; ++i)
    typeof t[i] < "u" && (r[i] = t[i]);
  return r;
}, lz = function e(t, n, r) {
  if (!n)
    return t;
  if (typeof n != "object") {
    if (ao(t))
      t.push(n);
    else if (t && typeof t == "object")
      (r && (r.plainObjects || r.allowPrototypes) || !Df.call(Object.prototype, n)) && (t[n] = !0);
    else
      return [t, n];
    return t;
  }
  if (!t || typeof t != "object")
    return [t].concat(n);
  var i = t;
  return ao(t) && !ao(n) && (i = $k(t, r)), ao(t) && ao(n) ? (n.forEach(function(o, a) {
    if (Df.call(t, a)) {
      var s = t[a];
      s && typeof s == "object" && o && typeof o == "object" ? t[a] = e(s, o, r) : t.push(o);
    } else
      t[a] = o;
  }), t) : Object.keys(n).reduce(function(o, a) {
    var s = n[a];
    return Df.call(o, a) ? o[a] = e(o[a], s, r) : o[a] = s, o;
  }, i);
}, uz = function(t, n) {
  return Object.keys(n).reduce(function(r, i) {
    return r[i] = n[i], r;
  }, t);
}, dz = function(e, t, n) {
  var r = e.replace(/\+/g, " ");
  if (n === "iso-8859-1")
    return r.replace(/%[0-9a-f]{2}/gi, unescape);
  try {
    return decodeURIComponent(r);
  } catch {
    return r;
  }
}, fz = function(t, n, r, i, o) {
  if (t.length === 0)
    return t;
  var a = t;
  if (typeof t == "symbol" ? a = Symbol.prototype.toString.call(t) : typeof t != "string" && (a = String(t)), r === "iso-8859-1")
    return escape(a).replace(/%u[0-9a-f]{4}/gi, function(u) {
      return "%26%23" + parseInt(u.slice(2), 16) + "%3B";
    });
  for (var s = "", c = 0; c < a.length; ++c) {
    var l = a.charCodeAt(c);
    if (l === 45 || l === 46 || l === 95 || l === 126 || l >= 48 && l <= 57 || l >= 65 && l <= 90 || l >= 97 && l <= 122 || o === sz.RFC1738 && (l === 40 || l === 41)) {
      s += a.charAt(c);
      continue;
    }
    if (l < 128) {
      s = s + jr[l];
      continue;
    }
    if (l < 2048) {
      s = s + (jr[192 | l >> 6] + jr[128 | l & 63]);
      continue;
    }
    if (l < 55296 || l >= 57344) {
      s = s + (jr[224 | l >> 12] + jr[128 | l >> 6 & 63] + jr[128 | l & 63]);
      continue;
    }
    c += 1, l = 65536 + ((l & 1023) << 10 | a.charCodeAt(c) & 1023), s += jr[240 | l >> 18] + jr[128 | l >> 12 & 63] + jr[128 | l >> 6 & 63] + jr[128 | l & 63];
  }
  return s;
}, pz = function(t) {
  for (var n = [{ obj: { o: t }, prop: "o" }], r = [], i = 0; i < n.length; ++i)
    for (var o = n[i], a = o.obj[o.prop], s = Object.keys(a), c = 0; c < s.length; ++c) {
      var l = s[c], u = a[l];
      typeof u == "object" && u !== null && r.indexOf(u) === -1 && (n.push({ obj: a, prop: l }), r.push(u));
    }
  return cz(n), t;
}, hz = function(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}, mz = function(t) {
  return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
}, yz = function(t, n) {
  return [].concat(t, n);
}, gz = function(t, n) {
  if (ao(t)) {
    for (var r = [], i = 0; i < t.length; i += 1)
      r.push(n(t[i]));
    return r;
  }
  return n(t);
}, Dk = {
  arrayToObject: $k,
  assign: uz,
  combine: yz,
  compact: pz,
  decode: dz,
  encode: fz,
  isBuffer: mz,
  isRegExp: hz,
  maybeMap: gz,
  merge: lz
}, Nk = iz, rl = Dk, ss = Ym, vz = Object.prototype.hasOwnProperty, Pv = {
  brackets: function(t) {
    return t + "[]";
  },
  comma: "comma",
  indices: function(t, n) {
    return t + "[" + n + "]";
  },
  repeat: function(t) {
    return t;
  }
}, ri = Array.isArray, bz = Array.prototype.push, jk = function(e, t) {
  bz.apply(e, ri(t) ? t : [t]);
}, wz = Date.prototype.toISOString, $v = ss.default, On = {
  addQueryPrefix: !1,
  allowDots: !1,
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encoder: rl.encode,
  encodeValuesOnly: !1,
  format: $v,
  formatter: ss.formatters[$v],
  // deprecated
  indices: !1,
  serializeDate: function(t) {
    return wz.call(t);
  },
  skipNulls: !1,
  strictNullHandling: !1
}, xz = function(t) {
  return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint";
}, Nf = {}, _z = function e(t, n, r, i, o, a, s, c, l, u, d, p, f, h, m, y) {
  for (var g = t, v = y, b = 0, _ = !1; (v = v.get(Nf)) !== void 0 && !_; ) {
    var S = v.get(t);
    if (b += 1, typeof S < "u") {
      if (S === b)
        throw new RangeError("Cyclic object value");
      _ = !0;
    }
    typeof v.get(Nf) > "u" && (b = 0);
  }
  if (typeof c == "function" ? g = c(n, g) : g instanceof Date ? g = d(g) : r === "comma" && ri(g) && (g = rl.maybeMap(g, function(j) {
    return j instanceof Date ? d(j) : j;
  })), g === null) {
    if (o)
      return s && !h ? s(n, On.encoder, m, "key", p) : n;
    g = "";
  }
  if (xz(g) || rl.isBuffer(g)) {
    if (s) {
      var x = h ? n : s(n, On.encoder, m, "key", p);
      return [f(x) + "=" + f(s(g, On.encoder, m, "value", p))];
    }
    return [f(n) + "=" + f(String(g))];
  }
  var A = [];
  if (typeof g > "u")
    return A;
  var I;
  if (r === "comma" && ri(g))
    h && s && (g = rl.maybeMap(g, s)), I = [{ value: g.length > 0 ? g.join(",") || null : void 0 }];
  else if (ri(c))
    I = c;
  else {
    var P = Object.keys(g);
    I = l ? P.sort(l) : P;
  }
  for (var R = i && ri(g) && g.length === 1 ? n + "[]" : n, M = 0; M < I.length; ++M) {
    var V = I[M], U = typeof V == "object" && typeof V.value < "u" ? V.value : g[V];
    if (!(a && U === null)) {
      var L = ri(g) ? typeof r == "function" ? r(R, V) : R : R + (u ? "." + V : "[" + V + "]");
      y.set(t, b);
      var $ = Nk();
      $.set(Nf, y), jk(A, e(
        U,
        L,
        r,
        i,
        o,
        a,
        r === "comma" && h && ri(g) ? null : s,
        c,
        l,
        u,
        d,
        p,
        f,
        h,
        m,
        $
      ));
    }
  }
  return A;
}, Sz = function(t) {
  if (!t)
    return On;
  if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  var n = t.charset || On.charset;
  if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var r = ss.default;
  if (typeof t.format < "u") {
    if (!vz.call(ss.formatters, t.format))
      throw new TypeError("Unknown format option provided.");
    r = t.format;
  }
  var i = ss.formatters[r], o = On.filter;
  return (typeof t.filter == "function" || ri(t.filter)) && (o = t.filter), {
    addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : On.addQueryPrefix,
    allowDots: typeof t.allowDots > "u" ? On.allowDots : !!t.allowDots,
    charset: n,
    charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : On.charsetSentinel,
    delimiter: typeof t.delimiter > "u" ? On.delimiter : t.delimiter,
    encode: typeof t.encode == "boolean" ? t.encode : On.encode,
    encoder: typeof t.encoder == "function" ? t.encoder : On.encoder,
    encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : On.encodeValuesOnly,
    filter: o,
    format: r,
    formatter: i,
    serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : On.serializeDate,
    skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : On.skipNulls,
    sort: typeof t.sort == "function" ? t.sort : null,
    strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : On.strictNullHandling
  };
}, kz = function(e, t) {
  var n = e, r = Sz(t), i, o;
  typeof r.filter == "function" ? (o = r.filter, n = o("", n)) : ri(r.filter) && (o = r.filter, i = o);
  var a = [];
  if (typeof n != "object" || n === null)
    return "";
  var s;
  t && t.arrayFormat in Pv ? s = t.arrayFormat : t && "indices" in t ? s = t.indices ? "indices" : "repeat" : s = "indices";
  var c = Pv[s];
  if (t && "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  var l = c === "comma" && t && t.commaRoundTrip;
  i || (i = Object.keys(n)), r.sort && i.sort(r.sort);
  for (var u = Nk(), d = 0; d < i.length; ++d) {
    var p = i[d];
    r.skipNulls && n[p] === null || jk(a, _z(
      n[p],
      p,
      c,
      l,
      r.strictNullHandling,
      r.skipNulls,
      r.encode ? r.encoder : null,
      r.filter,
      r.sort,
      r.allowDots,
      r.serializeDate,
      r.format,
      r.formatter,
      r.encodeValuesOnly,
      r.charset,
      u
    ));
  }
  var f = a.join(r.delimiter), h = r.addQueryPrefix === !0 ? "?" : "";
  return r.charsetSentinel && (r.charset === "iso-8859-1" ? h += "utf8=%26%2310003%3B&" : h += "utf8=%E2%9C%93&"), f.length > 0 ? h + f : "";
}, Sa = Dk, Xp = Object.prototype.hasOwnProperty, Ez = Array.isArray, gn = {
  allowDots: !1,
  allowPrototypes: !1,
  allowSparse: !1,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: !1,
  comma: !1,
  decoder: Sa.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: !1,
  interpretNumericEntities: !1,
  parameterLimit: 1e3,
  parseArrays: !0,
  plainObjects: !1,
  strictNullHandling: !1
}, Cz = function(e) {
  return e.replace(/&#(\d+);/g, function(t, n) {
    return String.fromCharCode(parseInt(n, 10));
  });
}, Mk = function(e, t) {
  return e && typeof e == "string" && t.comma && e.indexOf(",") > -1 ? e.split(",") : e;
}, Tz = "utf8=%26%2310003%3B", Rz = "utf8=%E2%9C%93", Az = function(t, n) {
  var r = { __proto__: null }, i = n.ignoreQueryPrefix ? t.replace(/^\?/, "") : t, o = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit, a = i.split(n.delimiter, o), s = -1, c, l = n.charset;
  if (n.charsetSentinel)
    for (c = 0; c < a.length; ++c)
      a[c].indexOf("utf8=") === 0 && (a[c] === Rz ? l = "utf-8" : a[c] === Tz && (l = "iso-8859-1"), s = c, c = a.length);
  for (c = 0; c < a.length; ++c)
    if (c !== s) {
      var u = a[c], d = u.indexOf("]="), p = d === -1 ? u.indexOf("=") : d + 1, f, h;
      p === -1 ? (f = n.decoder(u, gn.decoder, l, "key"), h = n.strictNullHandling ? null : "") : (f = n.decoder(u.slice(0, p), gn.decoder, l, "key"), h = Sa.maybeMap(
        Mk(u.slice(p + 1), n),
        function(m) {
          return n.decoder(m, gn.decoder, l, "value");
        }
      )), h && n.interpretNumericEntities && l === "iso-8859-1" && (h = Cz(h)), u.indexOf("[]=") > -1 && (h = Ez(h) ? [h] : h), Xp.call(r, f) ? r[f] = Sa.combine(r[f], h) : r[f] = h;
    }
  return r;
}, Oz = function(e, t, n, r) {
  for (var i = r ? t : Mk(t, n), o = e.length - 1; o >= 0; --o) {
    var a, s = e[o];
    if (s === "[]" && n.parseArrays)
      a = [].concat(i);
    else {
      a = n.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var c = s.charAt(0) === "[" && s.charAt(s.length - 1) === "]" ? s.slice(1, -1) : s, l = parseInt(c, 10);
      !n.parseArrays && c === "" ? a = { 0: i } : !isNaN(l) && s !== c && String(l) === c && l >= 0 && n.parseArrays && l <= n.arrayLimit ? (a = [], a[l] = i) : c !== "__proto__" && (a[c] = i);
    }
    i = a;
  }
  return i;
}, Iz = function(t, n, r, i) {
  if (t) {
    var o = r.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t, a = /(\[[^[\]]*])/, s = /(\[[^[\]]*])/g, c = r.depth > 0 && a.exec(o), l = c ? o.slice(0, c.index) : o, u = [];
    if (l) {
      if (!r.plainObjects && Xp.call(Object.prototype, l) && !r.allowPrototypes)
        return;
      u.push(l);
    }
    for (var d = 0; r.depth > 0 && (c = s.exec(o)) !== null && d < r.depth; ) {
      if (d += 1, !r.plainObjects && Xp.call(Object.prototype, c[1].slice(1, -1)) && !r.allowPrototypes)
        return;
      u.push(c[1]);
    }
    return c && u.push("[" + o.slice(c.index) + "]"), Oz(u, n, r, i);
  }
}, Pz = function(t) {
  if (!t)
    return gn;
  if (t.decoder !== null && t.decoder !== void 0 && typeof t.decoder != "function")
    throw new TypeError("Decoder has to be a function.");
  if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var n = typeof t.charset > "u" ? gn.charset : t.charset;
  return {
    allowDots: typeof t.allowDots > "u" ? gn.allowDots : !!t.allowDots,
    allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : gn.allowPrototypes,
    allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : gn.allowSparse,
    arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : gn.arrayLimit,
    charset: n,
    charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : gn.charsetSentinel,
    comma: typeof t.comma == "boolean" ? t.comma : gn.comma,
    decoder: typeof t.decoder == "function" ? t.decoder : gn.decoder,
    delimiter: typeof t.delimiter == "string" || Sa.isRegExp(t.delimiter) ? t.delimiter : gn.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : gn.depth,
    ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
    interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : gn.interpretNumericEntities,
    parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : gn.parameterLimit,
    parseArrays: t.parseArrays !== !1,
    plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : gn.plainObjects,
    strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : gn.strictNullHandling
  };
}, $z = function(e, t) {
  var n = Pz(t);
  if (e === "" || e === null || typeof e > "u")
    return n.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var r = typeof e == "string" ? Az(e, n) : e, i = n.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, o = Object.keys(r), a = 0; a < o.length; ++a) {
    var s = o[a], c = Iz(s, r[s], n, typeof e == "string");
    i = Sa.merge(i, c, n);
  }
  return n.allowSparse === !0 ? i : Sa.compact(i);
}, Dz = kz, Nz = $z, jz = Ym, Mz = {
  formats: jz,
  parse: Nz,
  stringify: Dz
};
const qz = /* @__PURE__ */ Vi(Mz), Lz = (e) => e[1] !== void 0, tn = (e) => {
  const { method: t, path: n, query: r, headers: i, body: o } = e, a = Object.entries(i).filter(Lz), s = Object.fromEntries(a), c = qz.stringify(r, { encode: !0, arrayFormat: "repeat", allowDots: !0 }), l = c ? [n, c].join("?") : n;
  return {
    method: t,
    url: l,
    headers: s,
    data: o
  };
}, Fz = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: { userId: e.userId }
}), Uz = (e) => ({
  path: "/conversations",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { _: e._ }
}), Bz = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), zz = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), Zz = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants/${encodeURIComponent(e.userId)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id, userId: e.userId },
  body: {}
}), Vz = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/messages`,
  headers: { "x-user-key": e["x-user-key"] },
  query: { nextToken: e.nextToken },
  params: { id: e.id },
  body: {}
}), Hz = (e) => ({
  path: "/conversations",
  headers: { "x-user-key": e["x-user-key"] },
  query: { nextToken: e.nextToken },
  params: {},
  body: {}
}), Wz = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants`,
  headers: { "x-user-key": e["x-user-key"] },
  query: { nextToken: e.nextToken },
  params: { id: e.id },
  body: {}
}), Kz = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/listen`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), Jz = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants/${encodeURIComponent(e.userId)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id, userId: e.userId },
  body: {}
}), Yz = (e) => ({
  path: "/messages",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { payload: e.payload, conversationId: e.conversationId }
}), Gz = (e) => ({
  path: `/messages/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), Xz = (e) => ({
  path: `/messages/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), Qz = (e) => ({
  path: "/users",
  headers: {},
  query: {},
  params: {},
  body: { name: e.name, pictureUrl: e.pictureUrl, userData: e.userData }
}), e4 = (e) => ({
  path: "/users/me",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: {}
}), t4 = (e) => ({
  path: "/users/me",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: {}
}), n4 = (e) => ({
  path: "/users/me",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { name: e.name, pictureUrl: e.pictureUrl, userData: e.userData }
}), r4 = (e) => ({
  path: "/events",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { payload: e.payload, conversationId: e.conversationId }
}), i4 = (e) => ({
  path: `/events/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), o4 = (e) => ({
  path: "/files",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { key: e.key, size: e.size, accessPolicies: e.accessPolicies, index: e.index, contentType: e.contentType, tags: e.tags }
});
let a4 = class {
  constructor(t, n = {}) {
    k(this, "addParticipant", async (t) => {
      const { path: n, headers: r, query: i, body: o } = Fz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "post",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "createConversation", async (t) => {
      const { path: n, headers: r, query: i, body: o } = Uz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "post",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "deleteConversation", async (t) => {
      const { path: n, headers: r, query: i, body: o } = Bz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "delete",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "getConversation", async (t) => {
      const { path: n, headers: r, query: i, body: o } = zz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "getParticipant", async (t) => {
      const { path: n, headers: r, query: i, body: o } = Zz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "listConversationMessages", async (t) => {
      const { path: n, headers: r, query: i, body: o } = Vz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "listConversations", async (t) => {
      const { path: n, headers: r, query: i, body: o } = Hz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "listParticipants", async (t) => {
      const { path: n, headers: r, query: i, body: o } = Wz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "listenConversation", async (t) => {
      const { path: n, headers: r, query: i, body: o } = Kz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "removeParticipant", async (t) => {
      const { path: n, headers: r, query: i, body: o } = Jz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "delete",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "createMessage", async (t) => {
      const { path: n, headers: r, query: i, body: o } = Yz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "post",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "deleteMessage", async (t) => {
      const { path: n, headers: r, query: i, body: o } = Gz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "delete",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "getMessage", async (t) => {
      const { path: n, headers: r, query: i, body: o } = Xz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "createUser", async (t) => {
      const { path: n, headers: r, query: i, body: o } = Qz(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "post",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "deleteUser", async (t) => {
      const { path: n, headers: r, query: i, body: o } = e4(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "delete",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "getUser", async (t) => {
      const { path: n, headers: r, query: i, body: o } = t4(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "updateUser", async (t) => {
      const { path: n, headers: r, query: i, body: o } = n4(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "put",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "createEvent", async (t) => {
      const { path: n, headers: r, query: i, body: o } = r4(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "post",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "getEvent", async (t) => {
      const { path: n, headers: r, query: i, body: o } = i4(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    k(this, "createFile", async (t) => {
      const { path: n, headers: r, query: i, body: o } = o4(t), s = (this.props.toAxiosRequest ?? tn)({
        method: "post",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: o
      });
      return this.axiosInstance.request(s).then((c) => c.data).catch((c) => {
        throw nn(c);
      });
    });
    this.axiosInstance = t, this.props = n;
  }
};
function nn(e) {
  var t;
  return _k.isAxiosError(e) && ((t = e.response) != null && t.data) ? hv(e.response.data) : hv(e);
}
class qk {
  constructor() {
    k(this, "listeners", {});
  }
  emit(t, n) {
    const r = this.listeners[t];
    if (r)
      for (const i of [...r])
        i(n);
  }
  onceOrMore(t, n) {
    const r = (i) => {
      n(i) === "stop-listening" && this.off(t, r);
    };
    this.on(t, r);
  }
  once(t, n) {
    const r = (i) => {
      this.off(t, r), n(i);
    };
    this.on(t, r);
  }
  on(t, n) {
    this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push(n);
  }
  off(t, n) {
    const r = this.listeners[t];
    if (!r)
      return;
    const i = r.indexOf(n);
    i !== -1 && r.splice(i, 1);
  }
  cleanup() {
    this.listeners = {};
  }
}
var Qp = { exports: {} };
/** @license
 * eventsource.js
 * Available under MIT License (MIT)
 * https://github.com/Yaffle/EventSource/
 */
(function(e, t) {
  (function(n) {
    var r = n.setTimeout, i = n.clearTimeout, o = n.XMLHttpRequest, a = n.XDomainRequest, s = n.ActiveXObject, c = n.EventSource, l = n.document, u = n.Promise, d = n.fetch, p = n.Response, f = n.TextDecoder, h = n.TextEncoder, m = n.AbortController;
    if (typeof window < "u" && typeof l < "u" && !("readyState" in l) && l.body == null && (l.readyState = "loading", window.addEventListener("load", function(q) {
      l.readyState = "complete";
    }, !1)), o == null && s != null && (o = function() {
      return new s("Microsoft.XMLHTTP");
    }), Object.create == null && (Object.create = function(q) {
      function ie() {
      }
      return ie.prototype = q, new ie();
    }), Date.now || (Date.now = function() {
      return (/* @__PURE__ */ new Date()).getTime();
    }), m == null) {
      var y = d;
      d = function(q, ie) {
        var se = ie.signal;
        return y(q, { headers: ie.headers, credentials: ie.credentials, cache: ie.cache }).then(function(le) {
          var De = le.body.getReader();
          return se._reader = De, se._aborted && se._reader.cancel(), {
            status: le.status,
            statusText: le.statusText,
            headers: le.headers,
            body: {
              getReader: function() {
                return De;
              }
            }
          };
        });
      }, m = function() {
        this.signal = {
          _reader: null,
          _aborted: !1
        }, this.abort = function() {
          this.signal._reader != null && this.signal._reader.cancel(), this.signal._aborted = !0;
        };
      };
    }
    function g() {
      this.bitsNeeded = 0, this.codePoint = 0;
    }
    g.prototype.decode = function(q) {
      function ie(W, re, ae) {
        if (ae === 1)
          return W >= 128 >> re && W << re <= 2047;
        if (ae === 2)
          return W >= 2048 >> re && W << re <= 55295 || W >= 57344 >> re && W << re <= 65535;
        if (ae === 3)
          return W >= 65536 >> re && W << re <= 1114111;
        throw new Error();
      }
      function se(W, re) {
        if (W === 6 * 1)
          return re >> 6 > 15 ? 3 : re > 31 ? 2 : 1;
        if (W === 6 * 2)
          return re > 15 ? 3 : 2;
        if (W === 6 * 3)
          return 3;
        throw new Error();
      }
      for (var le = 65533, De = "", _e = this.bitsNeeded, Ze = this.codePoint, yt = 0; yt < q.length; yt += 1) {
        var et = q[yt];
        _e !== 0 && (et < 128 || et > 191 || !ie(Ze << 6 | et & 63, _e - 6, se(_e, Ze))) && (_e = 0, Ze = le, De += String.fromCharCode(Ze)), _e === 0 ? (et >= 0 && et <= 127 ? (_e = 0, Ze = et) : et >= 192 && et <= 223 ? (_e = 6 * 1, Ze = et & 31) : et >= 224 && et <= 239 ? (_e = 6 * 2, Ze = et & 15) : et >= 240 && et <= 247 ? (_e = 6 * 3, Ze = et & 7) : (_e = 0, Ze = le), _e !== 0 && !ie(Ze, _e, se(_e, Ze)) && (_e = 0, Ze = le)) : (_e -= 6, Ze = Ze << 6 | et & 63), _e === 0 && (Ze <= 65535 ? De += String.fromCharCode(Ze) : (De += String.fromCharCode(55296 + (Ze - 65535 - 1 >> 10)), De += String.fromCharCode(56320 + (Ze - 65535 - 1 & 1023))));
      }
      return this.bitsNeeded = _e, this.codePoint = Ze, De;
    };
    var v = function() {
      try {
        return new f().decode(new h().encode("test"), { stream: !0 }) === "test";
      } catch (q) {
        console.debug("TextDecoder does not support streaming option. Using polyfill instead: " + q);
      }
      return !1;
    };
    (f == null || h == null || !v()) && (f = g);
    var b = function() {
    };
    function _(q) {
      this.withCredentials = !1, this.readyState = 0, this.status = 0, this.statusText = "", this.responseText = "", this.onprogress = b, this.onload = b, this.onerror = b, this.onreadystatechange = b, this._contentType = "", this._xhr = q, this._sendTimeout = 0, this._abort = b;
    }
    _.prototype.open = function(q, ie) {
      this._abort(!0);
      var se = this, le = this._xhr, De = 1, _e = 0;
      this._abort = function(ae) {
        se._sendTimeout !== 0 && (i(se._sendTimeout), se._sendTimeout = 0), (De === 1 || De === 2 || De === 3) && (De = 4, le.onload = b, le.onerror = b, le.onabort = b, le.onprogress = b, le.onreadystatechange = b, le.abort(), _e !== 0 && (i(_e), _e = 0), ae || (se.readyState = 4, se.onabort(null), se.onreadystatechange())), De = 0;
      };
      var Ze = function() {
        if (De === 1) {
          var ae = 0, Te = "", Xe = void 0;
          if ("contentType" in le)
            ae = 200, Te = "OK", Xe = le.contentType;
          else
            try {
              ae = le.status, Te = le.statusText, Xe = le.getResponseHeader("Content-Type");
            } catch {
              ae = 0, Te = "", Xe = void 0;
            }
          ae !== 0 && (De = 2, se.readyState = 2, se.status = ae, se.statusText = Te, se._contentType = Xe, se.onreadystatechange());
        }
      }, yt = function() {
        if (Ze(), De === 2 || De === 3) {
          De = 3;
          var ae = "";
          try {
            ae = le.responseText;
          } catch {
          }
          se.readyState = 3, se.responseText = ae, se.onprogress();
        }
      }, et = function(ae, Te) {
        if ((Te == null || Te.preventDefault == null) && (Te = {
          preventDefault: b
        }), yt(), De === 1 || De === 2 || De === 3) {
          if (De = 4, _e !== 0 && (i(_e), _e = 0), se.readyState = 4, ae === "load")
            se.onload(Te);
          else if (ae === "error")
            se.onerror(Te);
          else if (ae === "abort")
            se.onabort(Te);
          else
            throw new TypeError();
          se.onreadystatechange();
        }
      }, W = function(ae) {
        le != null && (le.readyState === 4 ? (!("onload" in le) || !("onerror" in le) || !("onabort" in le)) && et(le.responseText === "" ? "error" : "load", ae) : le.readyState === 3 ? "onprogress" in le || yt() : le.readyState === 2 && Ze());
      }, re = function() {
        _e = r(function() {
          re();
        }, 500), le.readyState === 3 && yt();
      };
      "onload" in le && (le.onload = function(ae) {
        et("load", ae);
      }), "onerror" in le && (le.onerror = function(ae) {
        et("error", ae);
      }), "onabort" in le && (le.onabort = function(ae) {
        et("abort", ae);
      }), "onprogress" in le && (le.onprogress = yt), "onreadystatechange" in le && (le.onreadystatechange = function(ae) {
        W(ae);
      }), ("contentType" in le || !("ontimeout" in o.prototype)) && (ie += (ie.indexOf("?") === -1 ? "?" : "&") + "padding=true"), le.open(q, ie, !0), "readyState" in le && (_e = r(function() {
        re();
      }, 0));
    }, _.prototype.abort = function() {
      this._abort(!1);
    }, _.prototype.getResponseHeader = function(q) {
      return this._contentType;
    }, _.prototype.setRequestHeader = function(q, ie) {
      var se = this._xhr;
      "setRequestHeader" in se && se.setRequestHeader(q, ie);
    }, _.prototype.getAllResponseHeaders = function() {
      return this._xhr.getAllResponseHeaders != null && this._xhr.getAllResponseHeaders() || "";
    }, _.prototype.send = function() {
      if ((!("ontimeout" in o.prototype) || !("sendAsBinary" in o.prototype) && !("mozAnon" in o.prototype)) && l != null && l.readyState != null && l.readyState !== "complete") {
        var q = this;
        q._sendTimeout = r(function() {
          q._sendTimeout = 0, q.send();
        }, 4);
        return;
      }
      var ie = this._xhr;
      "withCredentials" in ie && (ie.withCredentials = this.withCredentials);
      try {
        ie.send(void 0);
      } catch (se) {
        throw se;
      }
    };
    function S(q) {
      return q.replace(/[A-Z]/g, function(ie) {
        return String.fromCharCode(ie.charCodeAt(0) + 32);
      });
    }
    function x(q) {
      for (var ie = /* @__PURE__ */ Object.create(null), se = q.split(`\r
`), le = 0; le < se.length; le += 1) {
        var De = se[le], _e = De.split(": "), Ze = _e.shift(), yt = _e.join(": ");
        ie[S(Ze)] = yt;
      }
      this._map = ie;
    }
    x.prototype.get = function(q) {
      return this._map[S(q)];
    }, o != null && o.HEADERS_RECEIVED == null && (o.HEADERS_RECEIVED = 2);
    function A() {
    }
    A.prototype.open = function(q, ie, se, le, De, _e, Ze) {
      q.open("GET", De);
      var yt = 0;
      q.onprogress = function() {
        var W = q.responseText, re = W.slice(yt);
        yt += re.length, se(re);
      }, q.onerror = function(W) {
        W.preventDefault(), le(new Error("NetworkError"));
      }, q.onload = function() {
        le(null);
      }, q.onabort = function() {
        le(null);
      }, q.onreadystatechange = function() {
        if (q.readyState === o.HEADERS_RECEIVED) {
          var W = q.status, re = q.statusText, ae = q.getResponseHeader("Content-Type"), Te = q.getAllResponseHeaders();
          ie(W, re, ae, new x(Te));
        }
      }, q.withCredentials = _e;
      for (var et in Ze)
        Object.prototype.hasOwnProperty.call(Ze, et) && q.setRequestHeader(et, Ze[et]);
      return q.send(), q;
    };
    function I(q) {
      this._headers = q;
    }
    I.prototype.get = function(q) {
      return this._headers.get(q);
    };
    function P() {
    }
    P.prototype.open = function(q, ie, se, le, De, _e, Ze) {
      var yt = null, et = new m(), W = et.signal, re = new f();
      return d(De, {
        headers: Ze,
        credentials: _e ? "include" : "same-origin",
        signal: W,
        cache: "no-store"
      }).then(function(ae) {
        return yt = ae.body.getReader(), ie(ae.status, ae.statusText, ae.headers.get("Content-Type"), new I(ae.headers)), new u(function(Te, Xe) {
          var Lt = function() {
            yt.read().then(function(Pt) {
              if (Pt.done)
                Te(void 0);
              else {
                var Ct = re.decode(Pt.value, { stream: !0 });
                se(Ct), Lt();
              }
            }).catch(function(Pt) {
              Xe(Pt);
            });
          };
          Lt();
        });
      }).catch(function(ae) {
        if (ae.name !== "AbortError")
          return ae;
      }).then(function(ae) {
        le(ae);
      }), {
        abort: function() {
          yt != null && yt.cancel(), et.abort();
        }
      };
    };
    function R() {
      this._listeners = /* @__PURE__ */ Object.create(null);
    }
    function M(q) {
      r(function() {
        throw q;
      }, 0);
    }
    R.prototype.dispatchEvent = function(q) {
      q.target = this;
      var ie = this._listeners[q.type];
      if (ie != null)
        for (var se = ie.length, le = 0; le < se; le += 1) {
          var De = ie[le];
          try {
            typeof De.handleEvent == "function" ? De.handleEvent(q) : De.call(this, q);
          } catch (_e) {
            M(_e);
          }
        }
    }, R.prototype.addEventListener = function(q, ie) {
      q = String(q);
      var se = this._listeners, le = se[q];
      le == null && (le = [], se[q] = le);
      for (var De = !1, _e = 0; _e < le.length; _e += 1)
        le[_e] === ie && (De = !0);
      De || le.push(ie);
    }, R.prototype.removeEventListener = function(q, ie) {
      q = String(q);
      var se = this._listeners, le = se[q];
      if (le != null) {
        for (var De = [], _e = 0; _e < le.length; _e += 1)
          le[_e] !== ie && De.push(le[_e]);
        De.length === 0 ? delete se[q] : se[q] = De;
      }
    };
    function V(q) {
      this.type = q, this.target = void 0;
    }
    function U(q, ie) {
      V.call(this, q), this.data = ie.data, this.lastEventId = ie.lastEventId;
    }
    U.prototype = Object.create(V.prototype);
    function L(q, ie) {
      V.call(this, q), this.status = ie.status, this.statusText = ie.statusText, this.headers = ie.headers;
    }
    L.prototype = Object.create(V.prototype);
    function $(q, ie) {
      V.call(this, q), this.error = ie.error;
    }
    $.prototype = Object.create(V.prototype);
    var j = -1, z = 0, H = 1, X = 2, E = -1, ee = 0, de = 1, T = 2, be = 3, ke = /^text\/event\-stream(;.*)?$/i, Se = 1e3, Pe = 18e6, Be = function(q, ie) {
      var se = q == null ? ie : parseInt(q, 10);
      return se !== se && (se = ie), Ae(se);
    }, Ae = function(q) {
      return Math.min(Math.max(q, Se), Pe);
    }, pe = function(q, ie, se) {
      try {
        typeof ie == "function" && ie.call(q, se);
      } catch (le) {
        M(le);
      }
    };
    function ue(q, ie) {
      R.call(this), ie = ie || {}, this.onopen = void 0, this.onmessage = void 0, this.onerror = void 0, this.url = void 0, this.readyState = void 0, this.withCredentials = void 0, this.headers = void 0, this._close = void 0, $e(this, q, ie);
    }
    function xe() {
      return o != null && "withCredentials" in o.prototype || a == null ? new o() : new a();
    }
    var fe = d != null && p != null && "body" in p.prototype;
    function $e(q, ie, se) {
      ie = String(ie);
      var le = !!se.withCredentials, De = se.lastEventIdQueryParameterName || "lastEventId", _e = Ae(1e3), Ze = Be(se.heartbeatTimeout, 45e3), yt = "", et = _e, W = !1, re = 0, ae = se.headers || {}, Te = se.Transport, Xe = fe && Te == null ? void 0 : new _(Te != null ? new Te() : xe()), Lt = Te != null && typeof Te != "string" ? new Te() : Xe == null ? new P() : new A(), Pt = void 0, Ct = 0, jt = j, Qt = "", B = "", K = "", tt = "", at = ee, It = 0, Qe = 0, ln = function($t, St, Kt, Zt) {
        if (jt === z)
          if ($t === 200 && Kt != null && ke.test(Kt)) {
            jt = H, W = Date.now(), et = _e, q.readyState = H;
            var Jt = new L("open", {
              status: $t,
              statusText: St,
              headers: Zt
            });
            q.dispatchEvent(Jt), pe(q, q.onopen, Jt);
          } else {
            var Nt = "";
            $t !== 200 ? (St && (St = St.replace(/\s+/g, " ")), Nt = "EventSource's response has a status " + $t + " " + St + " that is not 200. Aborting the connection.") : Nt = "EventSource's response has a Content-Type specifying an unsupported type: " + (Kt == null ? "-" : Kt.replace(/\s+/g, " ")) + ". Aborting the connection.", wn();
            var Jt = new L("error", {
              status: $t,
              statusText: St,
              headers: Zt
            });
            q.dispatchEvent(Jt), pe(q, q.onerror, Jt), console.error(Nt);
          }
      }, Un = function($t) {
        if (jt === H) {
          for (var St = -1, Kt = 0; Kt < $t.length; Kt += 1) {
            var Zt = $t.charCodeAt(Kt);
            (Zt === `
`.charCodeAt(0) || Zt === "\r".charCodeAt(0)) && (St = Kt);
          }
          var Jt = (St !== -1 ? tt : "") + $t.slice(0, St + 1);
          tt = (St === -1 ? tt : "") + $t.slice(St + 1), $t !== "" && (W = Date.now(), re += $t.length);
          for (var Nt = 0; Nt < Jt.length; Nt += 1) {
            var Zt = Jt.charCodeAt(Nt);
            if (at === E && Zt === `
`.charCodeAt(0))
              at = ee;
            else if (at === E && (at = ee), Zt === "\r".charCodeAt(0) || Zt === `
`.charCodeAt(0)) {
              if (at !== ee) {
                at === de && (Qe = Nt + 1);
                var hn = Jt.slice(It, Qe - 1), mn = Jt.slice(Qe + (Qe < Nt && Jt.charCodeAt(Qe) === " ".charCodeAt(0) ? 1 : 0), Nt);
                hn === "data" ? (Qt += `
`, Qt += mn) : hn === "id" ? B = mn : hn === "event" ? K = mn : hn === "retry" ? (_e = Be(mn, _e), et = _e) : hn === "heartbeatTimeout" && (Ze = Be(mn, Ze), Ct !== 0 && (i(Ct), Ct = r(function() {
                  er();
                }, Ze)));
              }
              if (at === ee) {
                if (Qt !== "") {
                  yt = B, K === "" && (K = "message");
                  var An = new U(K, {
                    data: Qt.slice(1),
                    lastEventId: B
                  });
                  if (q.dispatchEvent(An), K === "open" ? pe(q, q.onopen, An) : K === "message" ? pe(q, q.onmessage, An) : K === "error" && pe(q, q.onerror, An), jt === X)
                    return;
                }
                Qt = "", K = "";
              }
              at = Zt === "\r".charCodeAt(0) ? E : ee;
            } else
              at === ee && (It = Nt, at = de), at === de ? Zt === ":".charCodeAt(0) && (Qe = Nt + 1, at = T) : at === T && (at = be);
          }
        }
      }, Wt = function($t) {
        if (jt === H || jt === z) {
          jt = j, Ct !== 0 && (i(Ct), Ct = 0), Ct = r(function() {
            er();
          }, et), et = Ae(Math.min(_e * 16, et * 2)), q.readyState = z;
          var St = new $("error", { error: $t });
          q.dispatchEvent(St), pe(q, q.onerror, St), $t != null && console.error($t);
        }
      }, wn = function() {
        jt = X, Pt != null && (Pt.abort(), Pt = void 0), Ct !== 0 && (i(Ct), Ct = 0), q.readyState = X;
      }, er = function() {
        if (Ct = 0, jt !== j) {
          if (!W && Pt != null)
            Wt(new Error("No activity within " + Ze + " milliseconds. " + (jt === z ? "No response received." : re + " chars received.") + " Reconnecting.")), Pt != null && (Pt.abort(), Pt = void 0);
          else {
            var $t = Math.max((W || Date.now()) + Ze - Date.now(), 1);
            W = !1, Ct = r(function() {
              er();
            }, $t);
          }
          return;
        }
        W = !1, re = 0, Ct = r(function() {
          er();
        }, Ze), jt = z, Qt = "", K = "", B = yt, tt = "", It = 0, Qe = 0, at = ee;
        var St = ie;
        if (ie.slice(0, 5) !== "data:" && ie.slice(0, 5) !== "blob:" && yt !== "") {
          var Kt = ie.indexOf("?");
          St = Kt === -1 ? ie : ie.slice(0, Kt + 1) + ie.slice(Kt + 1).replace(/(?:^|&)([^=&]*)(?:=[^&]*)?/g, function(mn, An) {
            return An === De ? "" : mn;
          }), St += (ie.indexOf("?") === -1 ? "?" : "&") + De + "=" + encodeURIComponent(yt);
        }
        var Zt = q.withCredentials, Jt = {};
        Jt.Accept = "text/event-stream";
        var Nt = q.headers;
        if (Nt != null)
          for (var hn in Nt)
            Object.prototype.hasOwnProperty.call(Nt, hn) && (Jt[hn] = Nt[hn]);
        try {
          Pt = Lt.open(Xe, ln, Un, Wt, St, Zt, Jt);
        } catch (mn) {
          throw wn(), mn;
        }
      };
      q.url = ie, q.readyState = z, q.withCredentials = le, q.headers = ae, q._close = wn, er();
    }
    ue.prototype = Object.create(R.prototype), ue.prototype.CONNECTING = z, ue.prototype.OPEN = H, ue.prototype.CLOSED = X, ue.prototype.close = function() {
      this._close();
    }, ue.CONNECTING = z, ue.OPEN = H, ue.CLOSED = X, ue.prototype.withCredentials = void 0;
    var nt = c;
    o != null && (c == null || !("withCredentials" in c.prototype)) && (nt = ue), function(q) {
      {
        var ie = q(t);
        ie !== void 0 && (e.exports = ie);
      }
    }(function(q) {
      q.EventSourcePolyfill = ue, q.NativeEventSource = c, q.EventSource = nt;
    });
  })(typeof globalThis > "u" ? typeof window < "u" ? window : typeof self < "u" ? self : it : globalThis);
})(Qp, Qp.exports);
var s4 = Qp.exports;
const c4 = /* @__PURE__ */ Vi(s4), l4 = (e, t = {}) => {
  const n = new c4.EventSourcePolyfill(e, { headers: t.headers }), r = new qk();
  return n.onopen = (i) => r.emit("open", i), n.onmessage = (i) => r.emit("message", i), n.onerror = (i) => r.emit("error", i), {
    emitter: r,
    source: n
  };
}, u4 = async (e, t = {}) => {
  const { emitter: n, source: r } = l4(e, t);
  return await new Promise((i, o) => {
    n.on("open", () => {
      i();
    }), n.on("error", (a) => {
      o(a);
    });
  }).finally(() => n.cleanup()), {
    on: n.on.bind(n),
    close: () => {
      n.cleanup(), r.close();
    }
  };
};
var At;
(function(e) {
  e.assertEqual = (i) => i;
  function t(i) {
  }
  e.assertIs = t;
  function n(i) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (i) => {
    const o = {};
    for (const a of i)
      o[a] = a;
    return o;
  }, e.getValidEnumValues = (i) => {
    const o = e.objectKeys(i).filter((s) => typeof i[i[s]] != "number"), a = {};
    for (const s of o)
      a[s] = i[s];
    return e.objectValues(a);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(o) {
    return i[o];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const o = [];
    for (const a in i)
      Object.prototype.hasOwnProperty.call(i, a) && o.push(a);
    return o;
  }, e.find = (i, o) => {
    for (const a of i)
      if (o(a))
        return a;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function r(i, o = " | ") {
    return i.map((a) => typeof a == "string" ? `'${a}'` : a).join(o);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (i, o) => typeof o == "bigint" ? o.toString() : o;
})(At || (At = {}));
var eh;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(eh || (eh = {}));
const Re = At.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Ri = (e) => {
  switch (typeof e) {
    case "undefined":
      return Re.undefined;
    case "string":
      return Re.string;
    case "number":
      return isNaN(e) ? Re.nan : Re.number;
    case "boolean":
      return Re.boolean;
    case "function":
      return Re.function;
    case "bigint":
      return Re.bigint;
    case "symbol":
      return Re.symbol;
    case "object":
      return Array.isArray(e) ? Re.array : e === null ? Re.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Re.promise : typeof Map < "u" && e instanceof Map ? Re.map : typeof Set < "u" && e instanceof Set ? Re.set : typeof Date < "u" && e instanceof Date ? Re.date : Re.object;
    default:
      return Re.unknown;
  }
}, ve = At.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), d4 = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class Rr extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(o) {
      return o.message;
    }, r = { _errors: [] }, i = (o) => {
      for (const a of o.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(i);
        else if (a.code === "invalid_return_type")
          i(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          i(a.argumentsError);
        else if (a.path.length === 0)
          r._errors.push(n(a));
        else {
          let s = r, c = 0;
          for (; c < a.path.length; ) {
            const l = a.path[c];
            c === a.path.length - 1 ? (s[l] = s[l] || { _errors: [] }, s[l]._errors.push(n(a))) : s[l] = s[l] || { _errors: [] }, s = s[l], c++;
          }
        }
    };
    return i(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, At.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const i of this.issues)
      i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
Rr.create = (e) => new Rr(e);
const xs = (e, t) => {
  let n;
  switch (e.code) {
    case ve.invalid_type:
      e.received === Re.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case ve.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, At.jsonStringifyReplacer)}`;
      break;
    case ve.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${At.joinValues(e.keys, ", ")}`;
      break;
    case ve.invalid_union:
      n = "Invalid input";
      break;
    case ve.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${At.joinValues(e.options)}`;
      break;
    case ve.invalid_enum_value:
      n = `Invalid enum value. Expected ${At.joinValues(e.options)}, received '${e.received}'`;
      break;
    case ve.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case ve.invalid_return_type:
      n = "Invalid function return type";
      break;
    case ve.invalid_date:
      n = "Invalid date";
      break;
    case ve.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : At.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case ve.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case ve.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case ve.custom:
      n = "Invalid input";
      break;
    case ve.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case ve.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case ve.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, At.assertNever(e);
  }
  return { message: n };
};
let Lk = xs;
function f4(e) {
  Lk = e;
}
function bu() {
  return Lk;
}
const wu = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: i } = e, o = [...n, ...i.path || []], a = {
    ...i,
    path: o
  };
  let s = "";
  const c = r.filter((l) => !!l).slice().reverse();
  for (const l of c)
    s = l(a, { data: t, defaultError: s }).message;
  return {
    ...i,
    path: o,
    message: i.message || s
  };
}, p4 = [];
function Oe(e, t) {
  const n = wu({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      bu(),
      xs
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(n);
}
class qn {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const i of n) {
      if (i.status === "aborted")
        return lt;
      i.status === "dirty" && t.dirty(), r.push(i.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const i of n)
      r.push({
        key: await i.key,
        value: await i.value
      });
    return qn.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const i of n) {
      const { key: o, value: a } = i;
      if (o.status === "aborted" || a.status === "aborted")
        return lt;
      o.status === "dirty" && t.dirty(), a.status === "dirty" && t.dirty(), o.value !== "__proto__" && (typeof a.value < "u" || i.alwaysSet) && (r[o.value] = a.value);
    }
    return { status: t.value, value: r };
  }
}
const lt = Object.freeze({
  status: "aborted"
}), Fk = (e) => ({ status: "dirty", value: e }), Hn = (e) => ({ status: "valid", value: e }), th = (e) => e.status === "aborted", nh = (e) => e.status === "dirty", _s = (e) => e.status === "valid", xu = (e) => typeof Promise < "u" && e instanceof Promise;
var We;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(We || (We = {}));
class Wr {
  constructor(t, n, r, i) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const Dv = (e, t) => {
  if (_s(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new Rr(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function ft(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: i } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (a, s) => a.code !== "invalid_type" ? { message: s.defaultError } : typeof s.data > "u" ? { message: r ?? s.defaultError } : { message: n ?? s.defaultError }, description: i };
}
class mt {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Ri(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: Ri(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new qn(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Ri(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (xu(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const i = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Ri(t)
    }, o = this._parseSync({ data: t, path: i.path, parent: i });
    return Dv(i, o);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Ri(t)
    }, i = this._parse({ data: t, path: r.path, parent: r }), o = await (xu(i) ? i : Promise.resolve(i));
    return Dv(r, o);
  }
  refine(t, n) {
    const r = (i) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(i) : n;
    return this._refinement((i, o) => {
      const a = t(i), s = () => o.addIssue({
        code: ve.custom,
        ...r(i)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((c) => c ? !0 : (s(), !1)) : a ? !0 : (s(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, i) => t(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1));
  }
  _refinement(t) {
    return new Or({
      schema: this,
      typeName: rt.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return li.create(this, this._def);
  }
  nullable() {
    return Eo.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Ar.create(this, this._def);
  }
  promise() {
    return Ea.create(this, this._def);
  }
  or(t) {
    return Cs.create([this, t], this._def);
  }
  and(t) {
    return Ts.create(this, t, this._def);
  }
  transform(t) {
    return new Or({
      ...ft(this._def),
      schema: this,
      typeName: rt.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Ps({
      ...ft(this._def),
      innerType: this,
      defaultValue: n,
      typeName: rt.ZodDefault
    });
  }
  brand() {
    return new Bk({
      typeName: rt.ZodBranded,
      type: this,
      ...ft(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Eu({
      ...ft(this._def),
      innerType: this,
      catchValue: n,
      typeName: rt.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return lc.create(this, t);
  }
  readonly() {
    return Tu.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const h4 = /^c[^\s-]{8,}$/i, m4 = /^[a-z][a-z0-9]*$/, y4 = /^[0-9A-HJKMNP-TV-Z]{26}$/, g4 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, v4 = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, b4 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let jf;
const w4 = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, x4 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, _4 = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function S4(e, t) {
  return !!((t === "v4" || !t) && w4.test(e) || (t === "v6" || !t) && x4.test(e));
}
class Sr extends mt {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Re.string) {
      const o = this._getOrReturnCtx(t);
      return Oe(
        o,
        {
          code: ve.invalid_type,
          expected: Re.string,
          received: o.parsedType
        }
        //
      ), lt;
    }
    const r = new qn();
    let i;
    for (const o of this._def.checks)
      if (o.kind === "min")
        t.data.length < o.value && (i = this._getOrReturnCtx(t, i), Oe(i, {
          code: ve.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), r.dirty());
      else if (o.kind === "max")
        t.data.length > o.value && (i = this._getOrReturnCtx(t, i), Oe(i, {
          code: ve.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), r.dirty());
      else if (o.kind === "length") {
        const a = t.data.length > o.value, s = t.data.length < o.value;
        (a || s) && (i = this._getOrReturnCtx(t, i), a ? Oe(i, {
          code: ve.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }) : s && Oe(i, {
          code: ve.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }), r.dirty());
      } else if (o.kind === "email")
        v4.test(t.data) || (i = this._getOrReturnCtx(t, i), Oe(i, {
          validation: "email",
          code: ve.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "emoji")
        jf || (jf = new RegExp(b4, "u")), jf.test(t.data) || (i = this._getOrReturnCtx(t, i), Oe(i, {
          validation: "emoji",
          code: ve.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "uuid")
        g4.test(t.data) || (i = this._getOrReturnCtx(t, i), Oe(i, {
          validation: "uuid",
          code: ve.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "cuid")
        h4.test(t.data) || (i = this._getOrReturnCtx(t, i), Oe(i, {
          validation: "cuid",
          code: ve.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "cuid2")
        m4.test(t.data) || (i = this._getOrReturnCtx(t, i), Oe(i, {
          validation: "cuid2",
          code: ve.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "ulid")
        y4.test(t.data) || (i = this._getOrReturnCtx(t, i), Oe(i, {
          validation: "ulid",
          code: ve.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), Oe(i, {
            validation: "url",
            code: ve.invalid_string,
            message: o.message
          }), r.dirty();
        }
      else
        o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), Oe(i, {
          validation: "regex",
          code: ve.invalid_string,
          message: o.message
        }), r.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (i = this._getOrReturnCtx(t, i), Oe(i, {
          code: ve.invalid_string,
          validation: { includes: o.value, position: o.position },
          message: o.message
        }), r.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (i = this._getOrReturnCtx(t, i), Oe(i, {
          code: ve.invalid_string,
          validation: { startsWith: o.value },
          message: o.message
        }), r.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (i = this._getOrReturnCtx(t, i), Oe(i, {
          code: ve.invalid_string,
          validation: { endsWith: o.value },
          message: o.message
        }), r.dirty()) : o.kind === "datetime" ? _4(o).test(t.data) || (i = this._getOrReturnCtx(t, i), Oe(i, {
          code: ve.invalid_string,
          validation: "datetime",
          message: o.message
        }), r.dirty()) : o.kind === "ip" ? S4(t.data, o.version) || (i = this._getOrReturnCtx(t, i), Oe(i, {
          validation: "ip",
          code: ve.invalid_string,
          message: o.message
        }), r.dirty()) : At.assertNever(o);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((i) => t.test(i), {
      validation: n,
      code: ve.invalid_string,
      ...We.errToObj(r)
    });
  }
  _addCheck(t) {
    return new Sr({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...We.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...We.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...We.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...We.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...We.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...We.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...We.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...We.errToObj(t) });
  }
  datetime(t) {
    var n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1,
      ...We.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...We.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...We.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...We.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...We.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...We.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...We.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...We.errToObj(n)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, We.errToObj(t));
  }
  trim() {
    return new Sr({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Sr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Sr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
Sr.create = (e) => {
  var t;
  return new Sr({
    checks: [],
    typeName: rt.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...ft(e)
  });
};
function k4(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, i = n > r ? n : r, o = parseInt(e.toFixed(i).replace(".", "")), a = parseInt(t.toFixed(i).replace(".", ""));
  return o % a / Math.pow(10, i);
}
class Li extends mt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Re.number) {
      const o = this._getOrReturnCtx(t);
      return Oe(o, {
        code: ve.invalid_type,
        expected: Re.number,
        received: o.parsedType
      }), lt;
    }
    let r;
    const i = new qn();
    for (const o of this._def.checks)
      o.kind === "int" ? At.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), Oe(r, {
        code: ve.invalid_type,
        expected: "integer",
        received: "float",
        message: o.message
      }), i.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), Oe(r, {
        code: ve.too_small,
        minimum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), Oe(r, {
        code: ve.too_big,
        maximum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), i.dirty()) : o.kind === "multipleOf" ? k4(t.data, o.value) !== 0 && (r = this._getOrReturnCtx(t, r), Oe(r, {
        code: ve.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), i.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), Oe(r, {
        code: ve.not_finite,
        message: o.message
      }), i.dirty()) : At.assertNever(o);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, We.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, We.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, We.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, We.toString(n));
  }
  setLimit(t, n, r, i) {
    return new Li({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: We.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Li({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: We.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: We.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: We.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: We.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: We.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: We.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: We.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: We.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: We.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && At.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
}
Li.create = (e) => new Li({
  checks: [],
  typeName: rt.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...ft(e)
});
class Fi extends mt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== Re.bigint) {
      const o = this._getOrReturnCtx(t);
      return Oe(o, {
        code: ve.invalid_type,
        expected: Re.bigint,
        received: o.parsedType
      }), lt;
    }
    let r;
    const i = new qn();
    for (const o of this._def.checks)
      o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), Oe(r, {
        code: ve.too_small,
        type: "bigint",
        minimum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), Oe(r, {
        code: ve.too_big,
        type: "bigint",
        maximum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), i.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), Oe(r, {
        code: ve.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), i.dirty()) : At.assertNever(o);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, We.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, We.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, We.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, We.toString(n));
  }
  setLimit(t, n, r, i) {
    return new Fi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: We.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Fi({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: We.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: We.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: We.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: We.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: We.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
Fi.create = (e) => {
  var t;
  return new Fi({
    checks: [],
    typeName: rt.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...ft(e)
  });
};
class Ss extends mt {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Re.boolean) {
      const r = this._getOrReturnCtx(t);
      return Oe(r, {
        code: ve.invalid_type,
        expected: Re.boolean,
        received: r.parsedType
      }), lt;
    }
    return Hn(t.data);
  }
}
Ss.create = (e) => new Ss({
  typeName: rt.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...ft(e)
});
class So extends mt {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Re.date) {
      const o = this._getOrReturnCtx(t);
      return Oe(o, {
        code: ve.invalid_type,
        expected: Re.date,
        received: o.parsedType
      }), lt;
    }
    if (isNaN(t.data.getTime())) {
      const o = this._getOrReturnCtx(t);
      return Oe(o, {
        code: ve.invalid_date
      }), lt;
    }
    const r = new qn();
    let i;
    for (const o of this._def.checks)
      o.kind === "min" ? t.data.getTime() < o.value && (i = this._getOrReturnCtx(t, i), Oe(i, {
        code: ve.too_small,
        message: o.message,
        inclusive: !0,
        exact: !1,
        minimum: o.value,
        type: "date"
      }), r.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (i = this._getOrReturnCtx(t, i), Oe(i, {
        code: ve.too_big,
        message: o.message,
        inclusive: !0,
        exact: !1,
        maximum: o.value,
        type: "date"
      }), r.dirty()) : At.assertNever(o);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new So({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: We.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: We.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
}
So.create = (e) => new So({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: rt.ZodDate,
  ...ft(e)
});
class _u extends mt {
  _parse(t) {
    if (this._getType(t) !== Re.symbol) {
      const r = this._getOrReturnCtx(t);
      return Oe(r, {
        code: ve.invalid_type,
        expected: Re.symbol,
        received: r.parsedType
      }), lt;
    }
    return Hn(t.data);
  }
}
_u.create = (e) => new _u({
  typeName: rt.ZodSymbol,
  ...ft(e)
});
class ks extends mt {
  _parse(t) {
    if (this._getType(t) !== Re.undefined) {
      const r = this._getOrReturnCtx(t);
      return Oe(r, {
        code: ve.invalid_type,
        expected: Re.undefined,
        received: r.parsedType
      }), lt;
    }
    return Hn(t.data);
  }
}
ks.create = (e) => new ks({
  typeName: rt.ZodUndefined,
  ...ft(e)
});
class Es extends mt {
  _parse(t) {
    if (this._getType(t) !== Re.null) {
      const r = this._getOrReturnCtx(t);
      return Oe(r, {
        code: ve.invalid_type,
        expected: Re.null,
        received: r.parsedType
      }), lt;
    }
    return Hn(t.data);
  }
}
Es.create = (e) => new Es({
  typeName: rt.ZodNull,
  ...ft(e)
});
class ka extends mt {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Hn(t.data);
  }
}
ka.create = (e) => new ka({
  typeName: rt.ZodAny,
  ...ft(e)
});
class po extends mt {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Hn(t.data);
  }
}
po.create = (e) => new po({
  typeName: rt.ZodUnknown,
  ...ft(e)
});
class hi extends mt {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return Oe(n, {
      code: ve.invalid_type,
      expected: Re.never,
      received: n.parsedType
    }), lt;
  }
}
hi.create = (e) => new hi({
  typeName: rt.ZodNever,
  ...ft(e)
});
class Su extends mt {
  _parse(t) {
    if (this._getType(t) !== Re.undefined) {
      const r = this._getOrReturnCtx(t);
      return Oe(r, {
        code: ve.invalid_type,
        expected: Re.void,
        received: r.parsedType
      }), lt;
    }
    return Hn(t.data);
  }
}
Su.create = (e) => new Su({
  typeName: rt.ZodVoid,
  ...ft(e)
});
class Ar extends mt {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), i = this._def;
    if (n.parsedType !== Re.array)
      return Oe(n, {
        code: ve.invalid_type,
        expected: Re.array,
        received: n.parsedType
      }), lt;
    if (i.exactLength !== null) {
      const a = n.data.length > i.exactLength.value, s = n.data.length < i.exactLength.value;
      (a || s) && (Oe(n, {
        code: a ? ve.too_big : ve.too_small,
        minimum: s ? i.exactLength.value : void 0,
        maximum: a ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), r.dirty());
    }
    if (i.minLength !== null && n.data.length < i.minLength.value && (Oe(n, {
      code: ve.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), r.dirty()), i.maxLength !== null && n.data.length > i.maxLength.value && (Oe(n, {
      code: ve.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((a, s) => i.type._parseAsync(new Wr(n, a, n.path, s)))).then((a) => qn.mergeArray(r, a));
    const o = [...n.data].map((a, s) => i.type._parseSync(new Wr(n, a, n.path, s)));
    return qn.mergeArray(r, o);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new Ar({
      ...this._def,
      minLength: { value: t, message: We.toString(n) }
    });
  }
  max(t, n) {
    return new Ar({
      ...this._def,
      maxLength: { value: t, message: We.toString(n) }
    });
  }
  length(t, n) {
    return new Ar({
      ...this._def,
      exactLength: { value: t, message: We.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Ar.create = (e, t) => new Ar({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: rt.ZodArray,
  ...ft(t)
});
function Wo(e) {
  if (e instanceof Ht) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = li.create(Wo(r));
    }
    return new Ht({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof Ar ? new Ar({
      ...e._def,
      type: Wo(e.element)
    }) : e instanceof li ? li.create(Wo(e.unwrap())) : e instanceof Eo ? Eo.create(Wo(e.unwrap())) : e instanceof Kr ? Kr.create(e.items.map((t) => Wo(t))) : e;
}
class Ht extends mt {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = At.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== Re.object) {
      const l = this._getOrReturnCtx(t);
      return Oe(l, {
        code: ve.invalid_type,
        expected: Re.object,
        received: l.parsedType
      }), lt;
    }
    const { status: r, ctx: i } = this._processInputParams(t), { shape: o, keys: a } = this._getCached(), s = [];
    if (!(this._def.catchall instanceof hi && this._def.unknownKeys === "strip"))
      for (const l in i.data)
        a.includes(l) || s.push(l);
    const c = [];
    for (const l of a) {
      const u = o[l], d = i.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: u._parse(new Wr(i, d, i.path, l)),
        alwaysSet: l in i.data
      });
    }
    if (this._def.catchall instanceof hi) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const u of s)
          c.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: i.data[u] }
          });
      else if (l === "strict")
        s.length > 0 && (Oe(i, {
          code: ve.unrecognized_keys,
          keys: s
        }), r.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const u of s) {
        const d = i.data[u];
        c.push({
          key: { status: "valid", value: u },
          value: l._parse(
            new Wr(i, d, i.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const u of c) {
        const d = await u.key;
        l.push({
          key: d,
          value: await u.value,
          alwaysSet: u.alwaysSet
        });
      }
      return l;
    }).then((l) => qn.mergeObjectSync(r, l)) : qn.mergeObjectSync(r, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return We.errToObj, new Ht({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var i, o, a, s;
          const c = (a = (o = (i = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(i, n, r).message) !== null && a !== void 0 ? a : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (s = We.errToObj(t).message) !== null && s !== void 0 ? s : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new Ht({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Ht({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new Ht({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new Ht({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: rt.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new Ht({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return At.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new Ht({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return At.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new Ht({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Wo(this);
  }
  partial(t) {
    const n = {};
    return At.objectKeys(this.shape).forEach((r) => {
      const i = this.shape[r];
      t && !t[r] ? n[r] = i : n[r] = i.optional();
    }), new Ht({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return At.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let o = this.shape[r];
        for (; o instanceof li; )
          o = o._def.innerType;
        n[r] = o;
      }
    }), new Ht({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return Uk(At.objectKeys(this.shape));
  }
}
Ht.create = (e, t) => new Ht({
  shape: () => e,
  unknownKeys: "strip",
  catchall: hi.create(),
  typeName: rt.ZodObject,
  ...ft(t)
});
Ht.strictCreate = (e, t) => new Ht({
  shape: () => e,
  unknownKeys: "strict",
  catchall: hi.create(),
  typeName: rt.ZodObject,
  ...ft(t)
});
Ht.lazycreate = (e, t) => new Ht({
  shape: e,
  unknownKeys: "strip",
  catchall: hi.create(),
  typeName: rt.ZodObject,
  ...ft(t)
});
class Cs extends mt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function i(o) {
      for (const s of o)
        if (s.result.status === "valid")
          return s.result;
      for (const s of o)
        if (s.result.status === "dirty")
          return n.common.issues.push(...s.ctx.common.issues), s.result;
      const a = o.map((s) => new Rr(s.ctx.common.issues));
      return Oe(n, {
        code: ve.invalid_union,
        unionErrors: a
      }), lt;
    }
    if (n.common.async)
      return Promise.all(r.map(async (o) => {
        const a = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await o._parseAsync({
            data: n.data,
            path: n.path,
            parent: a
          }),
          ctx: a
        };
      })).then(i);
    {
      let o;
      const a = [];
      for (const c of r) {
        const l = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, u = c._parseSync({
          data: n.data,
          path: n.path,
          parent: l
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !o && (o = { result: u, ctx: l }), l.common.issues.length && a.push(l.common.issues);
      }
      if (o)
        return n.common.issues.push(...o.ctx.common.issues), o.result;
      const s = a.map((c) => new Rr(c));
      return Oe(n, {
        code: ve.invalid_union,
        unionErrors: s
      }), lt;
    }
  }
  get options() {
    return this._def.options;
  }
}
Cs.create = (e, t) => new Cs({
  options: e,
  typeName: rt.ZodUnion,
  ...ft(t)
});
const il = (e) => e instanceof As ? il(e.schema) : e instanceof Or ? il(e.innerType()) : e instanceof Os ? [e.value] : e instanceof Ui ? e.options : e instanceof Is ? Object.keys(e.enum) : e instanceof Ps ? il(e._def.innerType) : e instanceof ks ? [void 0] : e instanceof Es ? [null] : null;
class qd extends mt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Re.object)
      return Oe(n, {
        code: ve.invalid_type,
        expected: Re.object,
        received: n.parsedType
      }), lt;
    const r = this.discriminator, i = n.data[r], o = this.optionsMap.get(i);
    return o ? n.common.async ? o._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : o._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (Oe(n, {
      code: ve.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), lt);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, r) {
    const i = /* @__PURE__ */ new Map();
    for (const o of n) {
      const a = il(o.shape[t]);
      if (!a)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const s of a) {
        if (i.has(s))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
        i.set(s, o);
      }
    }
    return new qd({
      typeName: rt.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: i,
      ...ft(r)
    });
  }
}
function rh(e, t) {
  const n = Ri(e), r = Ri(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === Re.object && r === Re.object) {
    const i = At.objectKeys(t), o = At.objectKeys(e).filter((s) => i.indexOf(s) !== -1), a = { ...e, ...t };
    for (const s of o) {
      const c = rh(e[s], t[s]);
      if (!c.valid)
        return { valid: !1 };
      a[s] = c.data;
    }
    return { valid: !0, data: a };
  } else if (n === Re.array && r === Re.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let o = 0; o < e.length; o++) {
      const a = e[o], s = t[o], c = rh(a, s);
      if (!c.valid)
        return { valid: !1 };
      i.push(c.data);
    }
    return { valid: !0, data: i };
  } else
    return n === Re.date && r === Re.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class Ts extends mt {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = (o, a) => {
      if (th(o) || th(a))
        return lt;
      const s = rh(o.value, a.value);
      return s.valid ? ((nh(o) || nh(a)) && n.dirty(), { status: n.value, value: s.data }) : (Oe(r, {
        code: ve.invalid_intersection_types
      }), lt);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([o, a]) => i(o, a)) : i(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
Ts.create = (e, t, n) => new Ts({
  left: e,
  right: t,
  typeName: rt.ZodIntersection,
  ...ft(n)
});
class Kr extends mt {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Re.array)
      return Oe(r, {
        code: ve.invalid_type,
        expected: Re.array,
        received: r.parsedType
      }), lt;
    if (r.data.length < this._def.items.length)
      return Oe(r, {
        code: ve.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), lt;
    !this._def.rest && r.data.length > this._def.items.length && (Oe(r, {
      code: ve.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const o = [...r.data].map((a, s) => {
      const c = this._def.items[s] || this._def.rest;
      return c ? c._parse(new Wr(r, a, r.path, s)) : null;
    }).filter((a) => !!a);
    return r.common.async ? Promise.all(o).then((a) => qn.mergeArray(n, a)) : qn.mergeArray(n, o);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new Kr({
      ...this._def,
      rest: t
    });
  }
}
Kr.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Kr({
    items: e,
    typeName: rt.ZodTuple,
    rest: null,
    ...ft(t)
  });
};
class Rs extends mt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Re.object)
      return Oe(r, {
        code: ve.invalid_type,
        expected: Re.object,
        received: r.parsedType
      }), lt;
    const i = [], o = this._def.keyType, a = this._def.valueType;
    for (const s in r.data)
      i.push({
        key: o._parse(new Wr(r, s, r.path, s)),
        value: a._parse(new Wr(r, r.data[s], r.path, s))
      });
    return r.common.async ? qn.mergeObjectAsync(n, i) : qn.mergeObjectSync(n, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof mt ? new Rs({
      keyType: t,
      valueType: n,
      typeName: rt.ZodRecord,
      ...ft(r)
    }) : new Rs({
      keyType: Sr.create(),
      valueType: t,
      typeName: rt.ZodRecord,
      ...ft(n)
    });
  }
}
class ku extends mt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Re.map)
      return Oe(r, {
        code: ve.invalid_type,
        expected: Re.map,
        received: r.parsedType
      }), lt;
    const i = this._def.keyType, o = this._def.valueType, a = [...r.data.entries()].map(([s, c], l) => ({
      key: i._parse(new Wr(r, s, r.path, [l, "key"])),
      value: o._parse(new Wr(r, c, r.path, [l, "value"]))
    }));
    if (r.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of a) {
          const l = await c.key, u = await c.value;
          if (l.status === "aborted" || u.status === "aborted")
            return lt;
          (l.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(l.value, u.value);
        }
        return { status: n.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const c of a) {
        const l = c.key, u = c.value;
        if (l.status === "aborted" || u.status === "aborted")
          return lt;
        (l.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(l.value, u.value);
      }
      return { status: n.value, value: s };
    }
  }
}
ku.create = (e, t, n) => new ku({
  valueType: t,
  keyType: e,
  typeName: rt.ZodMap,
  ...ft(n)
});
class ko extends mt {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Re.set)
      return Oe(r, {
        code: ve.invalid_type,
        expected: Re.set,
        received: r.parsedType
      }), lt;
    const i = this._def;
    i.minSize !== null && r.data.size < i.minSize.value && (Oe(r, {
      code: ve.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), n.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (Oe(r, {
      code: ve.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), n.dirty());
    const o = this._def.valueType;
    function a(c) {
      const l = /* @__PURE__ */ new Set();
      for (const u of c) {
        if (u.status === "aborted")
          return lt;
        u.status === "dirty" && n.dirty(), l.add(u.value);
      }
      return { status: n.value, value: l };
    }
    const s = [...r.data.values()].map((c, l) => o._parse(new Wr(r, c, r.path, l)));
    return r.common.async ? Promise.all(s).then((c) => a(c)) : a(s);
  }
  min(t, n) {
    return new ko({
      ...this._def,
      minSize: { value: t, message: We.toString(n) }
    });
  }
  max(t, n) {
    return new ko({
      ...this._def,
      maxSize: { value: t, message: We.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
ko.create = (e, t) => new ko({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: rt.ZodSet,
  ...ft(t)
});
class ra extends mt {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Re.function)
      return Oe(n, {
        code: ve.invalid_type,
        expected: Re.function,
        received: n.parsedType
      }), lt;
    function r(s, c) {
      return wu({
        data: s,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          bu(),
          xs
        ].filter((l) => !!l),
        issueData: {
          code: ve.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function i(s, c) {
      return wu({
        data: s,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          bu(),
          xs
        ].filter((l) => !!l),
        issueData: {
          code: ve.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const o = { errorMap: n.common.contextualErrorMap }, a = n.data;
    if (this._def.returns instanceof Ea) {
      const s = this;
      return Hn(async function(...c) {
        const l = new Rr([]), u = await s._def.args.parseAsync(c, o).catch((f) => {
          throw l.addIssue(r(c, f)), l;
        }), d = await Reflect.apply(a, this, u);
        return await s._def.returns._def.type.parseAsync(d, o).catch((f) => {
          throw l.addIssue(i(d, f)), l;
        });
      });
    } else {
      const s = this;
      return Hn(function(...c) {
        const l = s._def.args.safeParse(c, o);
        if (!l.success)
          throw new Rr([r(c, l.error)]);
        const u = Reflect.apply(a, this, l.data), d = s._def.returns.safeParse(u, o);
        if (!d.success)
          throw new Rr([i(u, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new ra({
      ...this._def,
      args: Kr.create(t).rest(po.create())
    });
  }
  returns(t) {
    return new ra({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new ra({
      args: t || Kr.create([]).rest(po.create()),
      returns: n || po.create(),
      typeName: rt.ZodFunction,
      ...ft(r)
    });
  }
}
class As extends mt {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
As.create = (e, t) => new As({
  getter: e,
  typeName: rt.ZodLazy,
  ...ft(t)
});
class Os extends mt {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return Oe(n, {
        received: n.data,
        code: ve.invalid_literal,
        expected: this._def.value
      }), lt;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
Os.create = (e, t) => new Os({
  value: e,
  typeName: rt.ZodLiteral,
  ...ft(t)
});
function Uk(e, t) {
  return new Ui({
    values: e,
    typeName: rt.ZodEnum,
    ...ft(t)
  });
}
class Ui extends mt {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return Oe(n, {
        expected: At.joinValues(r),
        received: n.parsedType,
        code: ve.invalid_type
      }), lt;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return Oe(n, {
        received: n.data,
        code: ve.invalid_enum_value,
        options: r
      }), lt;
    }
    return Hn(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t) {
    return Ui.create(t);
  }
  exclude(t) {
    return Ui.create(this.options.filter((n) => !t.includes(n)));
  }
}
Ui.create = Uk;
class Is extends mt {
  _parse(t) {
    const n = At.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== Re.string && r.parsedType !== Re.number) {
      const i = At.objectValues(n);
      return Oe(r, {
        expected: At.joinValues(i),
        received: r.parsedType,
        code: ve.invalid_type
      }), lt;
    }
    if (n.indexOf(t.data) === -1) {
      const i = At.objectValues(n);
      return Oe(r, {
        received: r.data,
        code: ve.invalid_enum_value,
        options: i
      }), lt;
    }
    return Hn(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Is.create = (e, t) => new Is({
  values: e,
  typeName: rt.ZodNativeEnum,
  ...ft(t)
});
class Ea extends mt {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Re.promise && n.common.async === !1)
      return Oe(n, {
        code: ve.invalid_type,
        expected: Re.promise,
        received: n.parsedType
      }), lt;
    const r = n.parsedType === Re.promise ? n.data : Promise.resolve(n.data);
    return Hn(r.then((i) => this._def.type.parseAsync(i, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
Ea.create = (e, t) => new Ea({
  type: e,
  typeName: rt.ZodPromise,
  ...ft(t)
});
class Or extends mt {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === rt.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = this._def.effect || null, o = {
      addIssue: (a) => {
        Oe(r, a), a.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (o.addIssue = o.addIssue.bind(o), i.type === "preprocess") {
      const a = i.transform(r.data, o);
      return r.common.issues.length ? {
        status: "dirty",
        value: r.data
      } : r.common.async ? Promise.resolve(a).then((s) => this._def.schema._parseAsync({
        data: s,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: a,
        path: r.path,
        parent: r
      });
    }
    if (i.type === "refinement") {
      const a = (s) => {
        const c = i.refinement(s, o);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      };
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? lt : (s.status === "dirty" && n.dirty(), a(s.value), { status: n.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => s.status === "aborted" ? lt : (s.status === "dirty" && n.dirty(), a(s.value).then(() => ({ status: n.value, value: s.value }))));
    }
    if (i.type === "transform")
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!_s(a))
          return a;
        const s = i.transform(a.value, o);
        if (s instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((a) => _s(a) ? Promise.resolve(i.transform(a.value, o)).then((s) => ({ status: n.value, value: s })) : a);
    At.assertNever(i);
  }
}
Or.create = (e, t, n) => new Or({
  schema: e,
  typeName: rt.ZodEffects,
  effect: t,
  ...ft(n)
});
Or.createWithPreprocess = (e, t, n) => new Or({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: rt.ZodEffects,
  ...ft(n)
});
class li extends mt {
  _parse(t) {
    return this._getType(t) === Re.undefined ? Hn(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
li.create = (e, t) => new li({
  innerType: e,
  typeName: rt.ZodOptional,
  ...ft(t)
});
class Eo extends mt {
  _parse(t) {
    return this._getType(t) === Re.null ? Hn(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Eo.create = (e, t) => new Eo({
  innerType: e,
  typeName: rt.ZodNullable,
  ...ft(t)
});
class Ps extends mt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === Re.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Ps.create = (e, t) => new Ps({
  innerType: e,
  typeName: rt.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...ft(t)
});
class Eu extends mt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return xu(i) ? i.then((o) => ({
      status: "valid",
      value: o.status === "valid" ? o.value : this._def.catchValue({
        get error() {
          return new Rr(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Rr(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Eu.create = (e, t) => new Eu({
  innerType: e,
  typeName: rt.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...ft(t)
});
class Cu extends mt {
  _parse(t) {
    if (this._getType(t) !== Re.nan) {
      const r = this._getOrReturnCtx(t);
      return Oe(r, {
        code: ve.invalid_type,
        expected: Re.nan,
        received: r.parsedType
      }), lt;
    }
    return { status: "valid", value: t.data };
  }
}
Cu.create = (e) => new Cu({
  typeName: rt.ZodNaN,
  ...ft(e)
});
const E4 = Symbol("zod_brand");
class Bk extends mt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class lc extends mt {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const o = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? lt : o.status === "dirty" ? (n.dirty(), Fk(o.value)) : this._def.out._parseAsync({
          data: o.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return i.status === "aborted" ? lt : i.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new lc({
      in: t,
      out: n,
      typeName: rt.ZodPipeline
    });
  }
}
class Tu extends mt {
  _parse(t) {
    const n = this._def.innerType._parse(t);
    return _s(n) && (n.value = Object.freeze(n.value)), n;
  }
}
Tu.create = (e, t) => new Tu({
  innerType: e,
  typeName: rt.ZodReadonly,
  ...ft(t)
});
const zk = (e, t = {}, n) => e ? ka.create().superRefine((r, i) => {
  var o, a;
  if (!e(r)) {
    const s = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t, c = (a = (o = s.fatal) !== null && o !== void 0 ? o : n) !== null && a !== void 0 ? a : !0, l = typeof s == "string" ? { message: s } : s;
    i.addIssue({ code: "custom", ...l, fatal: c });
  }
}) : ka.create(), C4 = {
  object: Ht.lazycreate
};
var rt;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(rt || (rt = {}));
const T4 = (e, t = {
  message: `Input not instance of ${e.name}`
}) => zk((n) => n instanceof e, t), Zk = Sr.create, Vk = Li.create, R4 = Cu.create, A4 = Fi.create, Hk = Ss.create, O4 = So.create, I4 = _u.create, P4 = ks.create, $4 = Es.create, D4 = ka.create, N4 = po.create, j4 = hi.create, M4 = Su.create, q4 = Ar.create, L4 = Ht.create, F4 = Ht.strictCreate, U4 = Cs.create, B4 = qd.create, z4 = Ts.create, Z4 = Kr.create, V4 = Rs.create, H4 = ku.create, W4 = ko.create, K4 = ra.create, J4 = As.create, Y4 = Os.create, G4 = Ui.create, X4 = Is.create, Q4 = Ea.create, Nv = Or.create, e6 = li.create, t6 = Eo.create, n6 = Or.createWithPreprocess, r6 = lc.create, i6 = () => Zk().optional(), o6 = () => Vk().optional(), a6 = () => Hk().optional(), s6 = {
  string: (e) => Sr.create({ ...e, coerce: !0 }),
  number: (e) => Li.create({ ...e, coerce: !0 }),
  boolean: (e) => Ss.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Fi.create({ ...e, coerce: !0 }),
  date: (e) => So.create({ ...e, coerce: !0 })
}, c6 = lt;
var Z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: xs,
  setErrorMap: f4,
  getErrorMap: bu,
  makeIssue: wu,
  EMPTY_PATH: p4,
  addIssueToContext: Oe,
  ParseStatus: qn,
  INVALID: lt,
  DIRTY: Fk,
  OK: Hn,
  isAborted: th,
  isDirty: nh,
  isValid: _s,
  isAsync: xu,
  get util() {
    return At;
  },
  get objectUtil() {
    return eh;
  },
  ZodParsedType: Re,
  getParsedType: Ri,
  ZodType: mt,
  ZodString: Sr,
  ZodNumber: Li,
  ZodBigInt: Fi,
  ZodBoolean: Ss,
  ZodDate: So,
  ZodSymbol: _u,
  ZodUndefined: ks,
  ZodNull: Es,
  ZodAny: ka,
  ZodUnknown: po,
  ZodNever: hi,
  ZodVoid: Su,
  ZodArray: Ar,
  ZodObject: Ht,
  ZodUnion: Cs,
  ZodDiscriminatedUnion: qd,
  ZodIntersection: Ts,
  ZodTuple: Kr,
  ZodRecord: Rs,
  ZodMap: ku,
  ZodSet: ko,
  ZodFunction: ra,
  ZodLazy: As,
  ZodLiteral: Os,
  ZodEnum: Ui,
  ZodNativeEnum: Is,
  ZodPromise: Ea,
  ZodEffects: Or,
  ZodTransformer: Or,
  ZodOptional: li,
  ZodNullable: Eo,
  ZodDefault: Ps,
  ZodCatch: Eu,
  ZodNaN: Cu,
  BRAND: E4,
  ZodBranded: Bk,
  ZodPipeline: lc,
  ZodReadonly: Tu,
  custom: zk,
  Schema: mt,
  ZodSchema: mt,
  late: C4,
  get ZodFirstPartyTypeKind() {
    return rt;
  },
  coerce: s6,
  any: D4,
  array: q4,
  bigint: A4,
  boolean: Hk,
  date: O4,
  discriminatedUnion: B4,
  effect: Nv,
  enum: G4,
  function: K4,
  instanceof: T4,
  intersection: z4,
  lazy: J4,
  literal: Y4,
  map: H4,
  nan: R4,
  nativeEnum: X4,
  never: j4,
  null: $4,
  nullable: t6,
  number: Vk,
  object: L4,
  oboolean: a6,
  onumber: o6,
  optional: e6,
  ostring: i6,
  pipeline: r6,
  preprocess: n6,
  promise: Q4,
  record: V4,
  set: W4,
  strictObject: F4,
  string: Zk,
  symbol: I4,
  transformer: Nv,
  tuple: Z4,
  undefined: P4,
  union: U4,
  unknown: N4,
  void: M4,
  NEVER: c6,
  ZodIssueCode: ve,
  quotelessJson: d4,
  ZodError: Rr
});
const l6 = Z.object({
  type: Z.literal("message_created"),
  data: Z.object({
    id: Z.string().describe("Id of the [Message](#schema_message)"),
    createdAt: Z.string().datetime().describe(
      "Creation date of the [Message](#schema_message) in ISO 8601 format"
    ),
    payload: Z.union([
      Z.object({
        audioUrl: Z.string().min(1),
        className: Z.string().describe("CSS className to apply to the message").optional(),
        type: Z.literal("audio")
      }),
      Z.object({
        title: Z.string().min(1),
        subtitle: Z.string().optional(),
        imageUrl: Z.string().optional(),
        actions: Z.array(
          Z.object({
            action: Z.enum(["postback", "url", "say"]),
            label: Z.string().min(1),
            value: Z.string().min(1)
          })
        ),
        type: Z.literal("card"),
        className: Z.string().describe("CSS className to apply to the message").optional()
      }),
      Z.object({
        items: Z.array(
          Z.object({
            title: Z.string().min(1),
            subtitle: Z.string().optional(),
            imageUrl: Z.string().optional(),
            actions: Z.array(
              Z.object({
                action: Z.enum(["postback", "url", "say"]),
                label: Z.string().min(1),
                value: Z.string().min(1)
              })
            ),
            className: Z.string().describe("CSS className to apply to the message").optional()
          })
        ),
        className: Z.string().describe("CSS className to apply to the message").optional(),
        type: Z.literal("carousel")
      }),
      Z.object({
        text: Z.string(),
        options: Z.array(
          Z.object({ label: Z.string().min(1), value: Z.string().min(1) })
        ),
        className: Z.string().describe("CSS className to apply to the message").optional(),
        type: Z.literal("choice"),
        disableFreeText: Z.boolean().optional()
      }),
      Z.object({
        text: Z.string(),
        options: Z.array(
          Z.object({ label: Z.string().min(1), value: Z.string().min(1) })
        ),
        className: Z.string().describe("CSS className to apply to the message").optional(),
        type: Z.literal("dropdown")
      }),
      Z.object({
        fileUrl: Z.string().min(1),
        title: Z.string().min(1).optional(),
        className: Z.string().describe("CSS className to apply to the message").optional(),
        type: Z.literal("file")
      }),
      Z.object({
        imageUrl: Z.string().min(1),
        className: Z.string().describe("CSS className to apply to the message").optional(),
        type: Z.literal("image")
      }),
      Z.object({
        latitude: Z.number(),
        longitude: Z.number(),
        address: Z.string().optional(),
        title: Z.string().optional(),
        className: Z.string().describe("CSS className to apply to the message").optional(),
        type: Z.literal("location")
      }),
      Z.object({
        markdown: Z.string().min(1),
        className: Z.string().describe("CSS className to apply to the message").optional(),
        type: Z.literal("markdown")
      }),
      Z.object({
        text: Z.string().min(1),
        className: Z.string().describe("CSS className to apply to the message").optional(),
        type: Z.literal("text")
      }),
      Z.object({
        videoUrl: Z.string().min(1),
        className: Z.string().describe("CSS className to apply to the message").optional(),
        type: Z.literal("video")
      })
    ]).describe("Payload is the content type of the message."),
    userId: Z.string().describe("ID of the [User](#schema_user)"),
    conversationId: Z.string().describe("ID of the [Conversation](#schema_conversation)")
  }).describe(
    "The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user)."
  )
}), u6 = Z.object({
  type: Z.literal("webchat_visibility"),
  data: Z.object({
    visibility: Z.union([
      Z.literal("show"),
      Z.literal("hide"),
      Z.literal("toggle")
    ])
  })
}), d6 = Z.object({
  type: Z.literal("webchat_config"),
  data: Z.object({ config: Z.record(Z.union([Z.any(), Z.null()])) })
}), f6 = Z.object({
  type: Z.literal("custom"),
  data: Z.object({ event: Z.record(Z.union([Z.any(), Z.null()])) })
}), p6 = Z.object({
  type: Z.literal("typing_started"),
  data: Z.object({ timeout: Z.number().optional() })
}), h6 = Z.object({ type: Z.literal("typing_stopped"), data: Z.record(Z.never()) }), m6 = {
  messageCreated: l6,
  webchatVisibility: u6,
  webchatConfig: d6,
  custom: f6,
  typingStarted: p6,
  typingStopped: h6
}, jv = "unknown error", Fu = class Fu extends qk {
  constructor(n) {
    super();
    k(this, "_state", { status: "disconnected" });
    k(this, "connect", async () => {
      if (this._state.status === "connected")
        return;
      if (this._state.status === "connecting") {
        await this._state.connectionPromise;
        return;
      }
      const n = this._connect();
      this._state = { status: "connecting", connectionPromise: n }, await n;
    });
    k(this, "disconnect", async () => {
      if (this._state.status === "disconnected")
        return;
      let n;
      this._state.status === "connecting" ? n = await this._state.connectionPromise : n = this._state.source, this._disconnectSync(n);
    });
    k(this, "_connect", async () => {
      const n = await u4(`${this._props.url}/conversations/${this._props.conversationId}/listen`, {
        headers: { "x-user-key": this._props.userKey }
      });
      return n.on("message", this._handleMessage), n.on("error", this._handleError(n)), this._state = { status: "connected", source: n }, n;
    });
    k(this, "_disconnectSync", (n) => {
      n.close(), this._state = { status: "disconnected" };
    });
    k(this, "_handleMessage", (n) => {
      const r = this._parseSignal(n.data);
      this.emit(r.type, r.data);
    });
    k(this, "_handleError", (n) => (r) => {
      this._disconnectSync(n);
      const i = this._toError(r);
      this.emit("error", i);
    });
    k(this, "_parseSignal", (n) => {
      for (const r of Object.values(m6)) {
        const i = this._safeJsonParse(n), o = r.safeParse(i);
        if (o.success)
          return o.data;
      }
      return {
        type: "unknown",
        data: n
      };
    });
    k(this, "_safeJsonParse", (n) => {
      try {
        return JSON.parse(n);
      } catch {
        return n;
      }
    });
    k(this, "_toError", (n) => {
      if (n instanceof Error)
        return n;
      if (typeof n == "string")
        return new Error(n);
      if (n === null)
        return new Error(jv);
      if (typeof n == "object" && "message" in n)
        return this._toError(n.message);
      try {
        const r = JSON.stringify(n);
        return new Error(r);
      } catch {
        return new Error(jv);
      }
    });
    this._props = n;
  }
  get status() {
    return this._state.status;
  }
};
k(Fu, "listen", async (n) => {
  const r = new Fu(n);
  return await r.connect(), r;
});
let ih = Fu;
const Wk = 100 * 1024 * 1024, y6 = Wk, g6 = Wk, v6 = 6e4;
class b6 {
  constructor(t) {
    k(this, "_auto");
    k(this, "createConversation", (t) => this._auto.createConversation(t));
    k(this, "getConversation", (t) => this._auto.getConversation(t));
    k(this, "deleteConversation", (t) => this._auto.deleteConversation(t));
    k(this, "listConversations", (t) => this._auto.listConversations(t));
    k(this, "listConversationMessages", (t) => this._auto.listConversationMessages(t));
    k(this, "addParticipant", (t) => this._auto.addParticipant(t));
    k(this, "removeParticipant", (t) => this._auto.removeParticipant(t));
    k(this, "getParticipant", (t) => this._auto.getParticipant(t));
    k(this, "listParticipants", (t) => this._auto.listParticipants(t));
    k(this, "createMessage", (t) => this._auto.createMessage(t));
    k(this, "getMessage", (t) => this._auto.getMessage(t));
    k(this, "deleteMessage", (t) => this._auto.deleteMessage(t));
    k(this, "createFile", (t) => this._auto.createFile(t));
    k(this, "createUser", (t) => this._auto.createUser(t));
    k(this, "getUser", (t) => this._auto.getUser(t));
    k(this, "updateUser", (t) => this._auto.updateUser(t));
    k(this, "deleteUser", (t) => this._auto.deleteUser(t));
    k(this, "createEvent", (t) => this._auto.createEvent(t));
    k(this, "getEvent", (t) => this._auto.getEvent(t));
    k(this, "listenConversation", async ({
      id: t,
      "x-user-key": n
    }) => await ih.listen({
      url: this.props.apiUrl,
      conversationId: t,
      userKey: n
    }));
    this.props = t;
    const { apiUrl: n } = t, r = {
      ...t.headers
    }, i = t.timeout ?? v6, o = _k.create({
      baseURL: n,
      headers: r,
      withCredentials: !0,
      timeout: i,
      maxBodyLength: y6,
      maxContentLength: g6
    });
    this._auto = new a4(o);
  }
}
const Ru = {
  disconnected: 0,
  user_creating: 1,
  user_created: 2,
  conversation_creating: 3,
  conversation_created: 4
}, Jn = (e, t) => e.status === t, Mr = (e, t) => Ru[e.status] < Ru[t], Mv = (e, t) => Ru[e.status] >= Ru[t];
class qr extends Error {
  constructor(t) {
    super(`Unexpected state: ${t.status}`), this.state = t;
  }
}
const w6 = ["audio", "file", "image", "video"], x6 = (e) => w6.includes(e);
class _6 extends hm {
  constructor(n) {
    super();
    k(this, "_client");
    k(this, "_webhookId");
    k(this, "_apiUrl");
    k(this, "_state", { status: "disconnected" });
    k(this, "mode", "pushpin");
    k(this, "_initialConnect", async ({ data: n, name: r, pictureUrl: i }) => {
      if (Mv(this._state, "user_created"))
        throw new Error("Client is already connected. Please disconnect first.");
      if (Jn(this._state, "user_creating"))
        return;
      this._state = {
        status: "user_creating"
      };
      const {
        user: { id: o },
        key: a
      } = await this._client.createUser({
        name: r,
        pictureUrl: i,
        userData: n
      });
      return this._state = {
        status: "user_created",
        userId: o,
        userKey: a
      }, {
        userId: o,
        userToken: a
      };
    });
    k(this, "_reConnect", async (n, { data: r, name: i, pictureUrl: o }) => {
      if (Mv(this._state, "user_created")) {
        if (this._state.userId !== n.userId)
          throw new Error("Client is already connected. Please disconnect first.");
        return n;
      }
      return Jn(this._state, "user_creating") || (this._state = {
        status: "user_created",
        userId: n.userId,
        userKey: n.userToken
      }, await this._client.updateUser({
        "x-user-key": n.userToken,
        name: i,
        pictureUrl: o,
        userData: r
      })), n;
    });
    k(this, "_mapMessage", (n) => {
      const { payload: r, disableInput: i } = b1(n.payload);
      return {
        id: n.id,
        conversationId: n.conversationId,
        authorId: n.userId,
        sentOn: new Date(n.createdAt),
        payload: r,
        disableInput: i
      };
    });
    const r = `${n.apiUrl}/${n.clientId}`;
    this._webhookId = n.clientId, this._apiUrl = r, this._client = new b6({
      apiUrl: r
    });
  }
  get apiUrl() {
    return this._apiUrl;
  }
  get clientId() {
    return this._webhookId;
  }
  get userId() {
    if (!Mr(this._state, "user_created"))
      return this._state.userId;
  }
  async getUser() {
    if (Mr(this._state, "user_created"))
      throw new qr(this._state);
    const { user: n } = await this._client.getUser({ "x-user-key": this._state.userKey });
    return { data: n.data };
  }
  async updateUser(n) {
    if (Mr(this._state, "user_created"))
      throw new qr(this._state);
    const { user: r } = await this._client.updateUser({
      "x-user-key": this._state.userKey,
      name: n.name,
      pictureUrl: n.pictureUrl,
      userData: n.data
    });
    return r;
  }
  get conversationId() {
    if (!Mr(this._state, "conversation_created"))
      return this._state.conversationId;
  }
  async connect(n, r, i = {}) {
    const o = { data: r, ...i };
    return n ? await this.userExists(n) ? this._reConnect(n, o) : this._initialConnect(o) : this._initialConnect(o);
  }
  async disconnect() {
    Jn(this._state, "conversation_created") ? this._state.signalEmitter.cleanup() : Jn(this._state, "conversation_creating") && console.warn("zombie conversation..."), this._state = { status: "disconnected" };
  }
  async sendFile(n) {
    if (Mr(this._state, "user_created"))
      throw new qr(this._state);
    if (Jn(this._state, "conversation_creating"))
      throw new qr(this._state);
    let r;
    Jn(this._state, "conversation_created") ? r = this._state : (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, r = await this._createNewConversation(this._state));
    const { size: i, name: o } = n, s = await ((h) => new Promise((m, y) => {
      const g = new FileReader();
      g.onload = (v) => {
        var b;
        return m((b = v.target) == null ? void 0 : b.result);
      }, g.onerror = (v) => {
        var b;
        return y((b = v.target) == null ? void 0 : b.error);
      }, g.readAsArrayBuffer(h);
    }))(n), {
      file: { uploadUrl: c, contentType: l, url: u }
    } = await this._client.createFile({
      "x-user-key": r.userKey,
      size: i,
      key: o,
      accessPolicies: ["public_content"],
      index: !1
    });
    await fetch(c, {
      method: "PUT",
      body: s
    });
    const d = l.split("/").shift() ?? "", p = x6(d) ? d : "file", f = p === "image" ? { type: p, imageUrl: u } : p === "audio" ? { type: p, audioUrl: u } : p === "video" ? { type: p, videoUrl: u } : { type: p, fileUrl: u };
    return await this._client.createMessage({
      "x-user-key": r.userKey,
      conversationId: r.conversationId,
      payload: f
    }), this.emit("messageSent", u), { fileUrl: u, name: o, type: p };
  }
  async sendMessage(n) {
    if (Mr(this._state, "user_created"))
      throw new qr(this._state);
    if (Jn(this._state, "conversation_creating"))
      throw new qr(this._state);
    let r;
    Jn(this._state, "conversation_created") ? r = this._state : (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, r = await this._createNewConversation(this._state)), await this._client.createMessage({
      "x-user-key": r.userKey,
      conversationId: r.conversationId,
      payload: {
        type: "text",
        text: n
      }
    }), this.emit("messageSent", n);
  }
  async sendEvent(n) {
    if (Mr(this._state, "user_created"))
      throw new qr(this._state);
    if (Jn(this._state, "conversation_creating"))
      throw new qr(this._state);
    let r;
    Jn(this._state, "conversation_created") ? r = this._state : (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, r = await this._createNewConversation(this._state)), await this._client.createEvent({
      "x-user-key": r.userKey,
      conversationId: r.conversationId,
      payload: {
        type: "custom",
        data: n
      }
    });
  }
  async switchConversation(n) {
    if (Mr(this._state, "user_created"))
      throw new qr(this._state);
    Jn(this._state, "conversation_created") && this._state.conversationId === n || Jn(this._state, "conversation_creating") || (this._state = {
      status: "conversation_creating",
      userId: this._state.userId,
      userKey: this._state.userKey
    }, await this._connectConversation(this._state, n));
  }
  async conversationExists(n) {
    if (Mr(this._state, "user_created"))
      return !1;
    try {
      return await this._client.getConversation({
        "x-user-key": this._state.userKey,
        id: n
      }), !0;
    } catch (r) {
      if (Hp(r) && r.code === 404)
        return !1;
      throw r;
    }
  }
  async userExists({ userToken: n }) {
    try {
      return await this._client.getUser({
        "x-user-key": n
      }), !0;
    } catch (r) {
      const i = (o) => o.code === 404 || o.code === 401;
      if (Hp(r) && i(r))
        return !1;
      throw r;
    }
  }
  async newConversation() {
    if (Mr(this._state, "user_created"))
      throw new qr(this._state);
    Jn(this._state, "conversation_creating") || (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, await this._createNewConversation(this._state));
  }
  async _createNewConversation(n) {
    const {
      conversation: { id: r }
    } = await this._client.createConversation({ "x-user-key": n.userKey }), i = await this._connectConversation(n, r);
    return await this._client.createEvent({
      "x-user-key": n.userKey,
      conversationId: r,
      payload: { type: "conversation_started", data: {} }
    }), i;
  }
  async listMessages() {
    if (!Jn(this._state, "conversation_created"))
      return [];
    const { conversationId: n, userKey: r } = this._state, i = [];
    let o;
    do {
      const a = await this._client.listConversationMessages({ id: n, "x-user-key": r, nextToken: o });
      i.push(...a.messages), o = a.meta.nextToken;
    } while (o);
    return i.map(this._mapMessage);
  }
  async _connectConversation(n, r) {
    const i = await this._client.listenConversation({ id: r, "x-user-key": n.userKey });
    return i.on("unknown", (o) => {
      typeof o == "string" && o === "ping" || console.debug("unknown event", o);
    }), i.on("message_created", (o) => {
      o.userId !== n.userId && this.emit("message", this._mapMessage(o));
    }), i.on("error", () => {
      this._state = { status: "user_created", userId: n.userId, userKey: n.userKey }, this.emit("error", new Error("Connection to conversation lost"));
    }), i.on("webchat_visibility", (o) => {
      this.emit("webchatVisibility", o.visibility);
    }), i.on("webchat_config", (o) => {
      this.emit("webchatConfig", o.config);
    }), i.on("typing_started", (o) => {
      this.emit("isTyping", { isTyping: !0, timeout: o.timeout ?? 5e3 });
    }), i.on("typing_stopped", () => {
      this.emit("isTyping", { isTyping: !1, timeout: 0 });
    }), i.on("custom", (o) => {
      this.emit("customEvent", o.event);
    }), this.emit("conversation", r), this._state = {
      status: "conversation_created",
      userId: n.userId,
      userKey: n.userKey,
      conversationId: r,
      signalEmitter: i
    }, this._state;
  }
}
const S6 = ({
  clientId: e,
  apiUrl: t = "https://webchat.botpress.cloud",
  mode: n = "pushpin"
}) => n === "messaging" ? new n5({
  url: t,
  clientId: e
}) : new _6({
  apiUrl: t,
  clientId: e
}), cJ = ({
  clientId: e,
  apiUrl: t = "https://webchat.botpress.cloud",
  mode: n = "pushpin"
}) => {
  const [r] = Ve(S6({ clientId: e, apiUrl: t, mode: n }));
  return r;
};
function k6(e, t) {
  const n = t ? `The ${t} has been copied to your clipboard.` : "Copied to clipboard.";
  return navigator.clipboard.writeText(e).then(() => FZ({ title: n, type: "success" }));
}
const E6 = (e, t = {}) => new Promise((n, r) => {
  if (typeof window > "u")
    return r("Window is not defined");
  if (!e)
    return r("Url is not defined");
  let i = null;
  const o = new Image();
  o.addEventListener("load", () => {
    i && clearTimeout(i), n({ width: o.naturalWidth, height: o.naturalHeight });
  }), o.addEventListener("error", (a) => {
    i && clearTimeout(i), r(`${a.type}: ${a.message}`);
  }), o.src = e, t.timeout && (i = setTimeout(() => r("Timeout"), t.timeout));
});
let C6 = { data: "" }, T6 = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || C6, R6 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, A6 = /\/\*[^]*?\*\/|  +/g, qv = /\n+/g, Ai = (e, t) => {
  let n = "", r = "", i = "";
  for (let o in e) {
    let a = e[o];
    o[0] == "@" ? o[1] == "i" ? n = o + " " + a + ";" : r += o[1] == "f" ? Ai(a, o) : o + "{" + Ai(a, o[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Ai(a, t ? t.replace(/([^,])+/g, (s) => o.replace(/(^:.*)|([^,])+/g, (c) => /&/.test(c) ? c.replace(/&/g, s) : s ? s + " " + c : c)) : o) : a != null && (o = /^--/.test(o) ? o : o.replace(/[A-Z]/g, "-$&").toLowerCase(), i += Ai.p ? Ai.p(o, a) : o + ":" + a + ";");
  }
  return n + (t && i ? t + "{" + i + "}" : i) + r;
}, ei = {}, Kk = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e)
      t += n + Kk(e[n]);
    return t;
  }
  return e;
}, O6 = (e, t, n, r, i) => {
  let o = Kk(e), a = ei[o] || (ei[o] = ((c) => {
    let l = 0, u = 11;
    for (; l < c.length; )
      u = 101 * u + c.charCodeAt(l++) >>> 0;
    return "go" + u;
  })(o));
  if (!ei[a]) {
    let c = o !== e ? e : ((l) => {
      let u, d, p = [{}];
      for (; u = R6.exec(l.replace(A6, "")); )
        u[4] ? p.shift() : u[3] ? (d = u[3].replace(qv, " ").trim(), p.unshift(p[0][d] = p[0][d] || {})) : p[0][u[1]] = u[2].replace(qv, " ").trim();
      return p[0];
    })(e);
    ei[a] = Ai(i ? { ["@keyframes " + a]: c } : c, n ? "" : "." + a);
  }
  let s = n && ei.g ? ei.g : null;
  return n && (ei.g = ei[a]), ((c, l, u, d) => {
    d ? l.data = l.data.replace(d, c) : l.data.indexOf(c) === -1 && (l.data = u ? c + l.data : l.data + c);
  })(ei[a], t, r, s), a;
}, I6 = (e, t, n) => e.reduce((r, i, o) => {
  let a = t[o];
  if (a && a.call) {
    let s = a(n), c = s && s.props && s.props.className || /^go/.test(s) && s;
    a = c ? "." + c : s && typeof s == "object" ? s.props ? "" : Ai(s, "") : s === !1 ? "" : s;
  }
  return r + i + (a ?? "");
}, "");
function Ld(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return O6(n.unshift ? n.raw ? I6(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, i) => Object.assign(r, i && i.call ? i(t.p) : i), {}) : n, T6(t.target), t.g, t.o, t.k);
}
let Jk, oh, ah;
Ld.bind({ g: 1 });
let mi = Ld.bind({ k: 1 });
function P6(e, t, n, r) {
  Ai.p = t, Jk = e, oh = n, ah = r;
}
function Ji(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function i(o, a) {
      let s = Object.assign({}, o), c = s.className || i.className;
      n.p = Object.assign({ theme: oh && oh() }, s), n.o = / *go\d+/.test(c), s.className = Ld.apply(n, r) + (c ? " " + c : ""), t && (s.ref = a);
      let l = e;
      return e[0] && (l = s.as || e, delete s.as), ah && l[0] && ah(s), Jk(l, s);
    }
    return t ? t(i) : i;
  };
}
var $6 = (e) => typeof e == "function", Au = (e, t) => $6(e) ? e(t) : e, D6 = (() => {
  let e = 0;
  return () => (++e).toString();
})(), Yk = (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), N6 = 20, ol = /* @__PURE__ */ new Map(), j6 = 1e3, Lv = (e) => {
  if (ol.has(e))
    return;
  let t = setTimeout(() => {
    ol.delete(e), $o({ type: 4, toastId: e });
  }, j6);
  ol.set(e, t);
}, M6 = (e) => {
  let t = ol.get(e);
  t && clearTimeout(t);
}, sh = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, N6) };
    case 1:
      return t.toast.id && M6(t.toast.id), { ...e, toasts: e.toasts.map((o) => o.id === t.toast.id ? { ...o, ...t.toast } : o) };
    case 2:
      let { toast: n } = t;
      return e.toasts.find((o) => o.id === n.id) ? sh(e, { type: 1, toast: n }) : sh(e, { type: 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return r ? Lv(r) : e.toasts.forEach((o) => {
        Lv(o.id);
      }), { ...e, toasts: e.toasts.map((o) => o.id === r || r === void 0 ? { ...o, visible: !1 } : o) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((o) => o.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let i = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((o) => ({ ...o, pauseDuration: o.pauseDuration + i })) };
  }
}, al = [], sl = { toasts: [], pausedAt: void 0 }, $o = (e) => {
  sl = sh(sl, e), al.forEach((t) => {
    t(sl);
  });
}, q6 = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, L6 = (e = {}) => {
  let [t, n] = Ve(sl);
  Ne(() => (al.push(n), () => {
    let i = al.indexOf(n);
    i > -1 && al.splice(i, 1);
  }), [t]);
  let r = t.toasts.map((i) => {
    var o, a;
    return { ...e, ...e[i.type], ...i, duration: i.duration || ((o = e[i.type]) == null ? void 0 : o.duration) || (e == null ? void 0 : e.duration) || q6[i.type], style: { ...e.style, ...(a = e[i.type]) == null ? void 0 : a.style, ...i.style } };
  });
  return { ...t, toasts: r };
}, F6 = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || D6() }), uc = (e) => (t, n) => {
  let r = F6(t, e, n);
  return $o({ type: 2, toast: r }), r.id;
}, Qn = (e, t) => uc("blank")(e, t);
Qn.error = uc("error");
Qn.success = uc("success");
Qn.loading = uc("loading");
Qn.custom = uc("custom");
Qn.dismiss = (e) => {
  $o({ type: 3, toastId: e });
};
Qn.remove = (e) => $o({ type: 4, toastId: e });
Qn.promise = (e, t, n) => {
  let r = Qn.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return e.then((i) => (Qn.success(Au(t.success, i), { id: r, ...n, ...n == null ? void 0 : n.success }), i)).catch((i) => {
    Qn.error(Au(t.error, i), { id: r, ...n, ...n == null ? void 0 : n.error });
  }), e;
};
var U6 = (e, t) => {
  $o({ type: 1, toast: { id: e, height: t } });
}, B6 = () => {
  $o({ type: 5, time: Date.now() });
}, z6 = (e) => {
  let { toasts: t, pausedAt: n } = L6(e);
  Ne(() => {
    if (n)
      return;
    let o = Date.now(), a = t.map((s) => {
      if (s.duration === 1 / 0)
        return;
      let c = (s.duration || 0) + s.pauseDuration - (o - s.createdAt);
      if (c < 0) {
        s.visible && Qn.dismiss(s.id);
        return;
      }
      return setTimeout(() => Qn.dismiss(s.id), c);
    });
    return () => {
      a.forEach((s) => s && clearTimeout(s));
    };
  }, [t, n]);
  let r = an(() => {
    n && $o({ type: 6, time: Date.now() });
  }, [n]), i = an((o, a) => {
    let { reverseOrder: s = !1, gutter: c = 8, defaultPosition: l } = a || {}, u = t.filter((f) => (f.position || l) === (o.position || l) && f.height), d = u.findIndex((f) => f.id === o.id), p = u.filter((f, h) => h < d && f.visible).length;
    return u.filter((f) => f.visible).slice(...s ? [p + 1] : [0, p]).reduce((f, h) => f + (h.height || 0) + c, 0);
  }, [t]);
  return { toasts: t, handlers: { updateHeight: U6, startPause: B6, endPause: r, calculateOffset: i } };
}, Z6 = mi`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, V6 = mi`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, H6 = mi`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, W6 = Ji("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Z6} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${V6} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${H6} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, K6 = mi`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, J6 = Ji("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${K6} 1s linear infinite;
`, Y6 = mi`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, G6 = mi`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, X6 = Ji("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Y6} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${G6} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Q6 = Ji("div")`
  position: absolute;
`, eZ = Ji("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, tZ = mi`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, nZ = Ji("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${tZ} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, rZ = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? D.createElement(nZ, null, t) : t : n === "blank" ? null : D.createElement(eZ, null, D.createElement(J6, { ...r }), n !== "loading" && D.createElement(Q6, null, n === "error" ? D.createElement(W6, { ...r }) : D.createElement(X6, { ...r })));
}, iZ = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, oZ = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, aZ = "0%{opacity:0;} 100%{opacity:1;}", sZ = "0%{opacity:1;} 100%{opacity:0;}", cZ = Ji("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, lZ = Ji("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, uZ = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, i] = Yk() ? [aZ, sZ] : [iZ(n), oZ(n)];
  return { animation: t ? `${mi(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${mi(i)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, dZ = D.memo(({ toast: e, position: t, style: n, children: r }) => {
  let i = e.height ? uZ(e.position || t || "top-center", e.visible) : { opacity: 0 }, o = D.createElement(rZ, { toast: e }), a = D.createElement(lZ, { ...e.ariaProps }, Au(e.message, e));
  return D.createElement(cZ, { className: e.className, style: { ...i, ...n, ...e.style } }, typeof r == "function" ? r({ icon: o, message: a }) : D.createElement(D.Fragment, null, o, a));
});
P6(D.createElement);
var fZ = ({ id: e, className: t, style: n, onHeightUpdate: r, children: i }) => {
  let o = D.useCallback((a) => {
    if (a) {
      let s = () => {
        let c = a.getBoundingClientRect().height;
        r(e, c);
      };
      s(), new MutationObserver(s).observe(a, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return D.createElement("div", { ref: o, className: t, style: n }, i);
}, pZ = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, i = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: Yk() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...i };
}, hZ = Ld`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, Ic = 16, mZ = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: i, containerStyle: o, containerClassName: a }) => {
  let { toasts: s, handlers: c } = z6(n);
  return D.createElement("div", { style: { position: "fixed", zIndex: 9999, top: Ic, left: Ic, right: Ic, bottom: Ic, pointerEvents: "none", ...o }, className: a, onMouseEnter: c.startPause, onMouseLeave: c.endPause }, s.map((l) => {
    let u = l.position || t, d = c.calculateOffset(l, { reverseOrder: e, gutter: r, defaultPosition: t }), p = pZ(u, d);
    return D.createElement(fZ, { id: l.id, key: l.id, onHeightUpdate: c.updateHeight, className: l.visible ? hZ : "", style: p }, l.type === "custom" ? Au(l.message, l) : i ? i(l) : D.createElement(dZ, { toast: l, position: u }));
  }));
}, yZ = Object.defineProperty, gZ = (e, t, n) => t in e ? yZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Mf = (e, t, n) => (gZ(e, typeof t != "symbol" ? t + "" : t, n), n);
let vZ = class {
  constructor() {
    Mf(this, "current", this.detect()), Mf(this, "handoffState", "pending"), Mf(this, "currentId", 0);
  }
  set(t) {
    this.current !== t && (this.handoffState = "pending", this.currentId = 0, this.current = t);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, cs = new vZ(), Fd = (e, t) => {
  cs.isServer ? Ne(e, t) : Ls(e, t);
};
function ia(e) {
  let t = Ke(e);
  return Fd(() => {
    t.current = e;
  }, [e]), t;
}
function bZ(e) {
  typeof queueMicrotask == "function" ? queueMicrotask(e) : Promise.resolve().then(e).catch((t) => setTimeout(() => {
    throw t;
  }));
}
function Ud() {
  let e = [], t = [], n = { enqueue(r) {
    t.push(r);
  }, addEventListener(r, i, o, a) {
    return r.addEventListener(i, o, a), n.add(() => r.removeEventListener(i, o, a));
  }, requestAnimationFrame(...r) {
    let i = requestAnimationFrame(...r);
    return n.add(() => cancelAnimationFrame(i));
  }, nextFrame(...r) {
    return n.requestAnimationFrame(() => n.requestAnimationFrame(...r));
  }, setTimeout(...r) {
    let i = setTimeout(...r);
    return n.add(() => clearTimeout(i));
  }, microTask(...r) {
    let i = { current: !0 };
    return bZ(() => {
      i.current && r[0]();
    }), n.add(() => {
      i.current = !1;
    });
  }, add(r) {
    return e.push(r), () => {
      let i = e.indexOf(r);
      if (i >= 0) {
        let [o] = e.splice(i, 1);
        o();
      }
    };
  }, dispose() {
    for (let r of e.splice(0))
      r();
  }, async workQueue() {
    for (let r of t.splice(0))
      await r();
  }, style(r, i, o) {
    let a = r.style.getPropertyValue(i);
    return Object.assign(r.style, { [i]: o }), this.add(() => {
      Object.assign(r.style, { [i]: a });
    });
  } };
  return n;
}
function Gk() {
  let [e] = Ve(Ud);
  return Ne(() => () => e.dispose(), [e]), e;
}
let co = function(e) {
  let t = ia(e);
  return Xt.useCallback((...n) => t.current(...n), [t]);
};
function Xk() {
  let [e, t] = Ve(cs.isHandoffComplete);
  return e && cs.isHandoffComplete === !1 && t(!1), Ne(() => {
    e !== !0 && t(!0);
  }, [e]), Ne(() => cs.handoff(), []), e;
}
function zr(e, t, ...n) {
  if (e in t) {
    let i = t[e];
    return typeof i == "function" ? i(...n) : i;
  }
  let r = new Error(`Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t).map((i) => `"${i}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(r, zr), r;
}
let wZ = Symbol();
function Qk(...e) {
  let t = Ke(e);
  Ne(() => {
    t.current = e;
  }, [e]);
  let n = co((r) => {
    for (let i of t.current)
      i != null && (typeof i == "function" ? i(r) : i.current = r);
  });
  return e.every((r) => r == null || (r == null ? void 0 : r[wZ])) ? void 0 : n;
}
function eE(...e) {
  return e.filter(Boolean).join(" ");
}
var tE = ((e) => (e[e.None = 0] = "None", e[e.RenderStrategy = 1] = "RenderStrategy", e[e.Static = 2] = "Static", e))(tE || {}), ai = ((e) => (e[e.Unmount = 0] = "Unmount", e[e.Hidden = 1] = "Hidden", e))(ai || {});
function nE({ ourProps: e, theirProps: t, slot: n, defaultTag: r, features: i, visible: o = !0, name: a }) {
  let s = rE(t, e);
  if (o)
    return Pc(s, n, r, a);
  let c = i ?? 0;
  if (c & 2) {
    let { static: l = !1, ...u } = s;
    if (l)
      return Pc(u, n, r, a);
  }
  if (c & 1) {
    let { unmount: l = !0, ...u } = s;
    return zr(l ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return Pc({ ...u, hidden: !0, style: { display: "none" } }, n, r, a);
    } });
  }
  return Pc(s, n, r, a);
}
function Pc(e, t = {}, n, r) {
  var i;
  let { as: o = n, children: a, refName: s = "ref", ...c } = qf(e, ["unmount", "static"]), l = e.ref !== void 0 ? { [s]: e.ref } : {}, u = typeof a == "function" ? a(t) : a;
  c.className && typeof c.className == "function" && (c.className = c.className(t));
  let d = {};
  if (t) {
    let p = !1, f = [];
    for (let [h, m] of Object.entries(t))
      typeof m == "boolean" && (p = !0), m === !0 && f.push(h);
    p && (d["data-headlessui-state"] = f.join(" "));
  }
  if (o === $i && Object.keys(Fv(c)).length > 0) {
    if (!ds(u) || Array.isArray(u) && u.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${r} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(c).map((h) => `  - ${h}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((h) => `  - ${h}`).join(`
`)].join(`
`));
    let p = eE((i = u.props) == null ? void 0 : i.className, c.className), f = p ? { className: p } : {};
    return Uu(u, Object.assign({}, rE(u.props, Fv(qf(c, ["ref"]))), d, l, xZ(u.ref, l.ref), f));
  }
  return Me(o, Object.assign({}, qf(c, ["ref"]), o !== $i && l, o !== $i && d), u);
}
function xZ(...e) {
  return { ref: e.every((t) => t == null) ? void 0 : (t) => {
    for (let n of e)
      n != null && (typeof n == "function" ? n(t) : n.current = t);
  } };
}
function rE(...e) {
  if (e.length === 0)
    return {};
  if (e.length === 1)
    return e[0];
  let t = {}, n = {};
  for (let r of e)
    for (let i in r)
      i.startsWith("on") && typeof r[i] == "function" ? (n[i] != null || (n[i] = []), n[i].push(r[i])) : t[i] = r[i];
  if (t.disabled || t["aria-disabled"])
    return Object.assign(t, Object.fromEntries(Object.keys(n).map((r) => [r, void 0])));
  for (let r in n)
    Object.assign(t, { [r](i, ...o) {
      let a = n[r];
      for (let s of a) {
        if ((i instanceof Event || (i == null ? void 0 : i.nativeEvent) instanceof Event) && i.defaultPrevented)
          return;
        s(i, ...o);
      }
    } });
  return t;
}
function Gm(e) {
  var t;
  return Object.assign(Ue(e), { displayName: (t = e.displayName) != null ? t : e.name });
}
function Fv(e) {
  let t = Object.assign({}, e);
  for (let n in t)
    t[n] === void 0 && delete t[n];
  return t;
}
function qf(e, t = []) {
  let n = Object.assign({}, e);
  for (let r of t)
    r in n && delete n[r];
  return n;
}
let Xm = gr(null);
Xm.displayName = "OpenClosedContext";
var ii = ((e) => (e[e.Open = 1] = "Open", e[e.Closed = 2] = "Closed", e[e.Closing = 4] = "Closing", e[e.Opening = 8] = "Opening", e))(ii || {});
function iE() {
  return Ir(Xm);
}
function _Z({ value: e, children: t }) {
  return Xt.createElement(Xm.Provider, { value: e }, t);
}
function oE() {
  let e = Ke(!1);
  return Fd(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e;
}
function SZ(e = 0) {
  let [t, n] = Ve(e), r = an((s) => n((c) => c | s), [t]), i = an((s) => !!(t & s), [t]), o = an((s) => n((c) => c & ~s), [n]), a = an((s) => n((c) => c ^ s), [n]);
  return { flags: t, addFlag: r, hasFlag: i, removeFlag: o, toggleFlag: a };
}
function kZ(e) {
  let t = { called: !1 };
  return (...n) => {
    if (!t.called)
      return t.called = !0, e(...n);
  };
}
function Lf(e, ...t) {
  e && t.length > 0 && e.classList.add(...t);
}
function Ff(e, ...t) {
  e && t.length > 0 && e.classList.remove(...t);
}
function EZ(e, t) {
  let n = Ud();
  if (!e)
    return n.dispose;
  let { transitionDuration: r, transitionDelay: i } = getComputedStyle(e), [o, a] = [r, i].map((s) => {
    let [c = 0] = s.split(",").filter(Boolean).map((l) => l.includes("ms") ? parseFloat(l) : parseFloat(l) * 1e3).sort((l, u) => u - l);
    return c;
  });
  if (o + a !== 0) {
    let s = n.addEventListener(e, "transitionend", (c) => {
      c.target === c.currentTarget && (t(), s());
    });
  } else
    t();
  return n.add(() => t()), n.dispose;
}
function CZ(e, t, n, r) {
  let i = n ? "enter" : "leave", o = Ud(), a = r !== void 0 ? kZ(r) : () => {
  };
  i === "enter" && (e.removeAttribute("hidden"), e.style.display = "");
  let s = zr(i, { enter: () => t.enter, leave: () => t.leave }), c = zr(i, { enter: () => t.enterTo, leave: () => t.leaveTo }), l = zr(i, { enter: () => t.enterFrom, leave: () => t.leaveFrom });
  return Ff(e, ...t.enter, ...t.enterTo, ...t.enterFrom, ...t.leave, ...t.leaveFrom, ...t.leaveTo, ...t.entered), Lf(e, ...s, ...l), o.nextFrame(() => {
    Ff(e, ...l), Lf(e, ...c), EZ(e, () => (Ff(e, ...s), Lf(e, ...t.entered), a()));
  }), o.dispose;
}
function TZ({ container: e, direction: t, classes: n, onStart: r, onStop: i }) {
  let o = oE(), a = Gk(), s = ia(t);
  Fd(() => {
    let c = Ud();
    a.add(c.dispose);
    let l = e.current;
    if (l && s.current !== "idle" && o.current)
      return c.dispose(), r.current(s.current), c.add(CZ(l, n.current, s.current === "enter", () => {
        c.dispose(), i.current(s.current);
      })), c.dispose;
  }, [t]);
}
function no(e = "") {
  return e.split(" ").filter((t) => t.trim().length > 1);
}
let Bd = gr(null);
Bd.displayName = "TransitionContext";
var RZ = ((e) => (e.Visible = "visible", e.Hidden = "hidden", e))(RZ || {});
function AZ() {
  let e = Ir(Bd);
  if (e === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e;
}
function OZ() {
  let e = Ir(zd);
  if (e === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e;
}
let zd = gr(null);
zd.displayName = "NestingContext";
function Zd(e) {
  return "children" in e ? Zd(e.children) : e.current.filter(({ el: t }) => t.current !== null).filter(({ state: t }) => t === "visible").length > 0;
}
function aE(e, t) {
  let n = ia(e), r = Ke([]), i = oE(), o = Gk(), a = co((f, h = ai.Hidden) => {
    let m = r.current.findIndex(({ el: y }) => y === f);
    m !== -1 && (zr(h, { [ai.Unmount]() {
      r.current.splice(m, 1);
    }, [ai.Hidden]() {
      r.current[m].state = "hidden";
    } }), o.microTask(() => {
      var y;
      !Zd(r) && i.current && ((y = n.current) == null || y.call(n));
    }));
  }), s = co((f) => {
    let h = r.current.find(({ el: m }) => m === f);
    return h ? h.state !== "visible" && (h.state = "visible") : r.current.push({ el: f, state: "visible" }), () => a(f, ai.Unmount);
  }), c = Ke([]), l = Ke(Promise.resolve()), u = Ke({ enter: [], leave: [], idle: [] }), d = co((f, h, m) => {
    c.current.splice(0), t && (t.chains.current[h] = t.chains.current[h].filter(([y]) => y !== f)), t == null || t.chains.current[h].push([f, new Promise((y) => {
      c.current.push(y);
    })]), t == null || t.chains.current[h].push([f, new Promise((y) => {
      Promise.all(u.current[h].map(([g, v]) => v)).then(() => y());
    })]), h === "enter" ? l.current = l.current.then(() => t == null ? void 0 : t.wait.current).then(() => m(h)) : m(h);
  }), p = co((f, h, m) => {
    Promise.all(u.current[h].splice(0).map(([y, g]) => g)).then(() => {
      var y;
      (y = c.current.shift()) == null || y();
    }).then(() => m(h));
  });
  return ho(() => ({ children: r, register: s, unregister: a, onStart: d, onStop: p, wait: l, chains: u }), [s, a, r, d, p, u, l]);
}
function IZ() {
}
let PZ = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function Uv(e) {
  var t;
  let n = {};
  for (let r of PZ)
    n[r] = (t = e[r]) != null ? t : IZ;
  return n;
}
function $Z(e) {
  let t = Ke(Uv(e));
  return Ne(() => {
    t.current = Uv(e);
  }, [e]), t;
}
let DZ = "div", sE = tE.RenderStrategy, cE = Gm(function(e, t) {
  let { beforeEnter: n, afterEnter: r, beforeLeave: i, afterLeave: o, enter: a, enterFrom: s, enterTo: c, entered: l, leave: u, leaveFrom: d, leaveTo: p, ...f } = e, h = Ke(null), m = Qk(h, t), y = f.unmount ? ai.Unmount : ai.Hidden, { show: g, appear: v, initial: b } = AZ(), [_, S] = Ve(g ? "visible" : "hidden"), x = OZ(), { register: A, unregister: I } = x, P = Ke(null);
  Ne(() => A(h), [A, h]), Ne(() => {
    if (y === ai.Hidden && h.current) {
      if (g && _ !== "visible") {
        S("visible");
        return;
      }
      return zr(_, { hidden: () => I(h), visible: () => A(h) });
    }
  }, [_, h, A, I, g, y]);
  let R = ia({ enter: no(a), enterFrom: no(s), enterTo: no(c), entered: no(l), leave: no(u), leaveFrom: no(d), leaveTo: no(p) }), M = $Z({ beforeEnter: n, afterEnter: r, beforeLeave: i, afterLeave: o }), V = Xk();
  Ne(() => {
    if (V && _ === "visible" && h.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [h, _, V]);
  let U = b && !v, L = (() => !V || U || P.current === g ? "idle" : g ? "enter" : "leave")(), $ = SZ(0), j = co((ee) => zr(ee, { enter: () => {
    $.addFlag(ii.Opening), M.current.beforeEnter();
  }, leave: () => {
    $.addFlag(ii.Closing), M.current.beforeLeave();
  }, idle: () => {
  } })), z = co((ee) => zr(ee, { enter: () => {
    $.removeFlag(ii.Opening), M.current.afterEnter();
  }, leave: () => {
    $.removeFlag(ii.Closing), M.current.afterLeave();
  }, idle: () => {
  } })), H = aE(() => {
    S("hidden"), I(h);
  }, x);
  TZ({ container: h, classes: R, direction: L, onStart: ia((ee) => {
    H.onStart(h, ee, j);
  }), onStop: ia((ee) => {
    H.onStop(h, ee, z), ee === "leave" && !Zd(H) && (S("hidden"), I(h));
  }) }), Ne(() => {
    !U || (y === ai.Hidden ? P.current = null : P.current = g);
  }, [g, U, _]);
  let X = f, E = { ref: m };
  return v && g && cs.isServer && (X = { ...X, className: eE(f.className, ...R.current.enter, ...R.current.enterFrom) }), Xt.createElement(zd.Provider, { value: H }, Xt.createElement(_Z, { value: zr(_, { visible: ii.Open, hidden: ii.Closed }) | $.flags }, nE({ ourProps: E, theirProps: X, defaultTag: DZ, features: sE, visible: _ === "visible", name: "Transition.Child" })));
}), ch = Gm(function(e, t) {
  let { show: n, appear: r = !1, unmount: i, ...o } = e, a = Ke(null), s = Qk(a, t);
  Xk();
  let c = iE();
  if (n === void 0 && c !== null && (n = (c & ii.Open) === ii.Open), ![!0, !1].includes(n))
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [l, u] = Ve(n ? "visible" : "hidden"), d = aE(() => {
    u("hidden");
  }), [p, f] = Ve(!0), h = Ke([n]);
  Fd(() => {
    p !== !1 && h.current[h.current.length - 1] !== n && (h.current.push(n), f(!1));
  }, [h, n]);
  let m = ho(() => ({ show: n, appear: r, initial: p }), [n, r, p]);
  Ne(() => {
    if (n)
      u("visible");
    else if (!Zd(d))
      u("hidden");
    else {
      let g = a.current;
      if (!g)
        return;
      let v = g.getBoundingClientRect();
      v.x === 0 && v.y === 0 && v.width === 0 && v.height === 0 && u("hidden");
    }
  }, [n, d]);
  let y = { unmount: i };
  return Xt.createElement(zd.Provider, { value: d }, Xt.createElement(Bd.Provider, { value: m }, nE({ ourProps: { ...y, as: $i, children: Xt.createElement(cE, { ref: s, ...y, ...o }) }, theirProps: {}, defaultTag: $i, features: sE, visible: l === "visible", name: "Transition" })));
}), NZ = Gm(function(e, t) {
  let n = Ir(Bd) !== null, r = iE() !== null;
  return Xt.createElement(Xt.Fragment, null, !n && r ? Xt.createElement(ch, { ref: t, ...e }) : Xt.createElement(cE, { ref: t, ...e }));
}), jZ = Object.assign(ch, { Child: NZ, Root: ch });
const MZ = (e) => /* @__PURE__ */ D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, ...e }, /* @__PURE__ */ D.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "m7.5 12 3 3 6-6m5.5 3c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10Z" })), qZ = (e) => /* @__PURE__ */ D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, fill: "none", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ D.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "M18 6 6 18M6 6l12 12" })), LZ = (e) => /* @__PURE__ */ D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, ...e }, /* @__PURE__ */ D.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "m15 9-6 6m0-6 6 6m7-3c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10Z" }));
function FZ(e) {
  return Qn.custom((t) => /* @__PURE__ */ F.jsx(BZ, { type: e.type, show: t.visible, children: e.type === "custom" ? e.content : /* @__PURE__ */ F.jsx(UZ, { ...e, toastId: t.id }) }));
}
const UZ = ({ icon: e, type: t, title: n, description: r, toastId: i }) => {
  const { notification: o } = Ie((a) => a.theme);
  return /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
    e ? /* @__PURE__ */ F.jsx(e, { ...o == null ? void 0 : o.icon }) : /* @__PURE__ */ F.jsx(zZ, { ...o == null ? void 0 : o.icon, type: t }),
    /* @__PURE__ */ F.jsx("p", { ...o == null ? void 0 : o.title, children: n }),
    r ? /* @__PURE__ */ F.jsx("p", { ...o == null ? void 0 : o.description, children: r }) : null,
    /* @__PURE__ */ F.jsx(qZ, { ...o == null ? void 0 : o.closeIcon, onClick: () => Qn.dismiss(i) })
  ] });
}, BZ = ({ type: e, ...t }) => {
  const { notification: n } = Ie((r) => r.theme);
  return /* @__PURE__ */ F.jsx(jZ, { ...t, ...n == null ? void 0 : n.container, appear: !0, "data-type": e ?? "neutral" });
}, zZ = ({ type: e, className: t }) => {
  switch (e) {
    case "success":
      return /* @__PURE__ */ F.jsx(MZ, { className: t });
    case "error":
      return /* @__PURE__ */ F.jsx(LZ, { className: t });
    default:
      return null;
  }
};
var Ou = function() {
  return Ou = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, Ou.apply(this, arguments);
};
function ZZ() {
  var e = Ke(!1), t = an(function() {
    return e.current;
  }, []);
  return Ne(function() {
    return e.current = !0, function() {
      e.current = !1;
    };
  }, []), t;
}
function VZ(e, t, n) {
  t === void 0 && (t = []), n === void 0 && (n = { loading: !1 });
  var r = Ke(0), i = ZZ(), o = Ve(n), a = o[0], s = o[1], c = an(function() {
    for (var l = [], u = 0; u < arguments.length; u++)
      l[u] = arguments[u];
    var d = ++r.current;
    return a.loading || s(function(p) {
      return Ou(Ou({}, p), { loading: !0 });
    }), e.apply(void 0, l).then(function(p) {
      return i() && d === r.current && s({ value: p, loading: !1 }), p;
    }, function(p) {
      return i() && d === r.current && s({ error: p, loading: !1 }), p;
    });
  }, t);
  return [a, c];
}
function Bv(e, t) {
  t === void 0 && (t = []);
  var n = VZ(e, t, {
    loading: !0
  }), r = n[0], i = n[1];
  return Ne(function() {
    i();
  }, [i]), r;
}
function HZ(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  e && e.addEventListener && e.addEventListener.apply(e, t);
}
function WZ(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  e && e.removeEventListener && e.removeEventListener.apply(e, t);
}
var KZ = function(e) {
  Ne(e, []);
};
const lE = KZ;
var JZ = function(e) {
  lE(function() {
    e();
  });
};
const YZ = JZ;
var GZ = function(e) {
  var t = Ke(e);
  t.current = e, lE(function() {
    return function() {
      return t.current();
    };
  });
};
const XZ = GZ;
var QZ = function(e) {
  var t = Ke(0), n = Ve(e), r = n[0], i = n[1], o = an(function(a) {
    cancelAnimationFrame(t.current), t.current = requestAnimationFrame(function() {
      i(a);
    });
  }, []);
  return XZ(function() {
    cancelAnimationFrame(t.current);
  }), [r, o];
};
const e7 = QZ;
var t7 = function(e) {
  process.env.NODE_ENV === "development" && (typeof e != "object" || typeof e.current > "u") && console.error("`useScroll` expects a single ref argument.");
  var t = e7({
    x: 0,
    y: 0
  }), n = t[0], r = t[1];
  return Ne(function() {
    var i = function() {
      e.current && r({
        x: e.current.scrollLeft,
        y: e.current.scrollTop
      });
    };
    return e.current && HZ(e.current, "scroll", i, {
      capture: !1,
      passive: !0
    }), function() {
      e.current && WZ(e.current, "scroll", i);
    };
  }, [e]), n;
};
const n7 = t7, zv = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (c, l) => {
    const u = typeof c == "function" ? c(t) : c;
    if (!Object.is(u, t)) {
      const d = t;
      t = l ?? typeof u != "object" ? u : Object.assign({}, t, u), n.forEach((p) => p(t, d));
    }
  }, i = () => t, s = { setState: r, getState: i, subscribe: (c) => (n.add(c), () => n.delete(c)), destroy: () => {
    n.clear();
  } };
  return t = e(r, i, s), s;
}, uE = (e) => e ? zv(e) : zv;
var lh = { exports: {} }, Uf = {}, $c = { exports: {} }, Bf = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Zv;
function r7() {
  if (Zv)
    return Bf;
  Zv = 1;
  var e = Xt;
  function t(d, p) {
    return d === p && (d !== 0 || 1 / d === 1 / p) || d !== d && p !== p;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, o = e.useLayoutEffect, a = e.useDebugValue;
  function s(d, p) {
    var f = p(), h = r({ inst: { value: f, getSnapshot: p } }), m = h[0].inst, y = h[1];
    return o(function() {
      m.value = f, m.getSnapshot = p, c(m) && y({ inst: m });
    }, [d, f, p]), i(function() {
      return c(m) && y({ inst: m }), d(function() {
        c(m) && y({ inst: m });
      });
    }, [d]), a(f), f;
  }
  function c(d) {
    var p = d.getSnapshot;
    d = d.value;
    try {
      var f = p();
      return !n(d, f);
    } catch {
      return !0;
    }
  }
  function l(d, p) {
    return p();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? l : s;
  return Bf.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u, Bf;
}
var zf = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Vv;
function i7() {
  return Vv || (Vv = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = Xt, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(b) {
      {
        for (var _ = arguments.length, S = new Array(_ > 1 ? _ - 1 : 0), x = 1; x < _; x++)
          S[x - 1] = arguments[x];
        r("error", b, S);
      }
    }
    function r(b, _, S) {
      {
        var x = t.ReactDebugCurrentFrame, A = x.getStackAddendum();
        A !== "" && (_ += "%s", S = S.concat([A]));
        var I = S.map(function(P) {
          return String(P);
        });
        I.unshift("Warning: " + _), Function.prototype.apply.call(console[b], console, I);
      }
    }
    function i(b, _) {
      return b === _ && (b !== 0 || 1 / b === 1 / _) || b !== b && _ !== _;
    }
    var o = typeof Object.is == "function" ? Object.is : i, a = e.useState, s = e.useEffect, c = e.useLayoutEffect, l = e.useDebugValue, u = !1, d = !1;
    function p(b, _, S) {
      u || e.startTransition !== void 0 && (u = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var x = _();
      if (!d) {
        var A = _();
        o(x, A) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), d = !0);
      }
      var I = a({
        inst: {
          value: x,
          getSnapshot: _
        }
      }), P = I[0].inst, R = I[1];
      return c(function() {
        P.value = x, P.getSnapshot = _, f(P) && R({
          inst: P
        });
      }, [b, x, _]), s(function() {
        f(P) && R({
          inst: P
        });
        var M = function() {
          f(P) && R({
            inst: P
          });
        };
        return b(M);
      }, [b]), l(x), x;
    }
    function f(b) {
      var _ = b.getSnapshot, S = b.value;
      try {
        var x = _();
        return !o(S, x);
      } catch {
        return !0;
      }
    }
    function h(b, _, S) {
      return _();
    }
    var m = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", y = !m, g = y ? h : p, v = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : g;
    zf.useSyncExternalStore = v, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), zf;
}
var Hv;
function dE() {
  return Hv || (Hv = 1, process.env.NODE_ENV === "production" ? $c.exports = r7() : $c.exports = i7()), $c.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Wv;
function o7() {
  if (Wv)
    return Uf;
  Wv = 1;
  var e = Xt, t = dE();
  function n(l, u) {
    return l === u && (l !== 0 || 1 / l === 1 / u) || l !== l && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, a = e.useEffect, s = e.useMemo, c = e.useDebugValue;
  return Uf.useSyncExternalStoreWithSelector = function(l, u, d, p, f) {
    var h = o(null);
    if (h.current === null) {
      var m = { hasValue: !1, value: null };
      h.current = m;
    } else
      m = h.current;
    h = s(function() {
      function g(x) {
        if (!v) {
          if (v = !0, b = x, x = p(x), f !== void 0 && m.hasValue) {
            var A = m.value;
            if (f(A, x))
              return _ = A;
          }
          return _ = x;
        }
        if (A = _, r(b, x))
          return A;
        var I = p(x);
        return f !== void 0 && f(A, I) ? A : (b = x, _ = I);
      }
      var v = !1, b, _, S = d === void 0 ? null : d;
      return [function() {
        return g(u());
      }, S === null ? void 0 : function() {
        return g(S());
      }];
    }, [u, d, p, f]);
    var y = i(l, h[0], h[1]);
    return a(function() {
      m.hasValue = !0, m.value = y;
    }, [y]), c(y), y;
  }, Uf;
}
var Zf = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Kv;
function a7() {
  return Kv || (Kv = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = Xt, t = dE();
    function n(u, d) {
      return u === d && (u !== 0 || 1 / u === 1 / d) || u !== u && d !== d;
    }
    var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, a = e.useEffect, s = e.useMemo, c = e.useDebugValue;
    function l(u, d, p, f, h) {
      var m = o(null), y;
      m.current === null ? (y = {
        hasValue: !1,
        value: null
      }, m.current = y) : y = m.current;
      var g = s(function() {
        var S = !1, x, A, I = function(V) {
          if (!S) {
            S = !0, x = V;
            var U = f(V);
            if (h !== void 0 && y.hasValue) {
              var L = y.value;
              if (h(L, U))
                return A = L, L;
            }
            return A = U, U;
          }
          var $ = x, j = A;
          if (r($, V))
            return j;
          var z = f(V);
          return h !== void 0 && h(j, z) ? j : (x = V, A = z, z);
        }, P = p === void 0 ? null : p, R = function() {
          return I(d());
        }, M = P === null ? void 0 : function() {
          return I(P());
        };
        return [R, M];
      }, [d, p, f, h]), v = g[0], b = g[1], _ = i(u, v, b);
      return a(function() {
        y.hasValue = !0, y.value = _;
      }, [_]), c(_), _;
    }
    Zf.useSyncExternalStoreWithSelector = l, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Zf;
}
process.env.NODE_ENV === "production" ? lh.exports = o7() : lh.exports = a7();
var s7 = lh.exports;
const c7 = /* @__PURE__ */ Vi(s7), { useSyncExternalStoreWithSelector: l7 } = c7;
function fE(e, t = e.getState, n) {
  const r = l7(
    e.subscribe,
    e.getState,
    e.getServerState || e.getState,
    t,
    n
  );
  return VC(r), r;
}
const Jv = (e) => {
  const t = typeof e == "function" ? uE(e) : e, n = (r, i) => fE(t, r, i);
  return Object.assign(n, t), n;
}, u7 = (e) => e ? Jv(e) : Jv, uh = /* @__PURE__ */ new Map(), Dc = (e) => {
  const t = uh.get(e);
  return t ? Object.fromEntries(
    Object.entries(t.stores).map(([n, r]) => [n, r.getState()])
  ) : {};
}, d7 = (e, t, n) => {
  if (e === void 0)
    return {
      type: "untracked",
      connection: t.connect(n)
    };
  const r = uh.get(n.name);
  if (r)
    return { type: "tracked", store: e, ...r };
  const i = {
    connection: t.connect(n),
    stores: {}
  };
  return uh.set(n.name, i), { type: "tracked", store: e, ...i };
}, f7 = (e, t = {}) => (n, r, i) => {
  const { enabled: o, anonymousActionType: a, store: s, ...c } = t;
  let l;
  try {
    l = (o ?? !1) && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!l)
    return e(n, r, i);
  const { connection: u, ...d } = d7(s, l, c);
  let p = !0;
  i.setState = (m, y, g) => {
    const v = n(m, y);
    if (!p)
      return v;
    const b = g === void 0 ? { type: a || "anonymous" } : typeof g == "string" ? { type: g } : g;
    return s === void 0 ? (u == null || u.send(b, r()), v) : (u == null || u.send(
      {
        ...b,
        type: `${s}/${b.type}`
      },
      {
        ...Dc(c.name),
        [s]: i.getState()
      }
    ), v);
  };
  const f = (...m) => {
    const y = p;
    p = !1, n(...m), p = y;
  }, h = e(i.setState, r, i);
  if (d.type === "untracked" ? u == null || u.init(h) : (d.stores[d.store] = i, u == null || u.init(
    Object.fromEntries(
      Object.entries(d.stores).map(([m, y]) => [
        m,
        m === d.store ? h : y.getState()
      ])
    )
  )), i.dispatchFromDevtools && typeof i.dispatch == "function") {
    let m = !1;
    const y = i.dispatch;
    i.dispatch = (...g) => {
      y(...g);
    };
  }
  return u.subscribe((m) => {
    var y;
    switch (m.type) {
      case "ACTION":
        if (typeof m.payload != "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return Vf(
          m.payload,
          (g) => {
            if (g.type === "__setState") {
              if (s === void 0) {
                f(g.state);
                return;
              }
              Object.keys(g.state).length !== 1 && console.error(
                `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
              );
              const v = g.state[s];
              if (v == null)
                return;
              JSON.stringify(i.getState()) !== JSON.stringify(v) && f(v);
              return;
            }
            i.dispatchFromDevtools && typeof i.dispatch == "function" && i.dispatch(g);
          }
        );
      case "DISPATCH":
        switch (m.payload.type) {
          case "RESET":
            return f(h), s === void 0 ? u == null ? void 0 : u.init(i.getState()) : u == null ? void 0 : u.init(Dc(c.name));
          case "COMMIT":
            if (s === void 0) {
              u == null || u.init(i.getState());
              return;
            }
            return u == null ? void 0 : u.init(Dc(c.name));
          case "ROLLBACK":
            return Vf(m.state, (g) => {
              if (s === void 0) {
                f(g), u == null || u.init(i.getState());
                return;
              }
              f(g[s]), u == null || u.init(Dc(c.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return Vf(m.state, (g) => {
              if (s === void 0) {
                f(g);
                return;
              }
              JSON.stringify(i.getState()) !== JSON.stringify(g[s]) && f(g[s]);
            });
          case "IMPORT_STATE": {
            const { nextLiftedState: g } = m.payload, v = (y = g.computedStates.slice(-1)[0]) == null ? void 0 : y.state;
            if (!v)
              return;
            f(s === void 0 ? v : v[s]), u == null || u.send(
              null,
              // FIXME no-any
              g
            );
            return;
          }
          case "PAUSE_RECORDING":
            return p = !p;
        }
        return;
    }
  }), h;
}, pE = f7, Vf = (e, t) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      r
    );
  }
  n !== void 0 && t(n);
};
function p7(e, t) {
  let n;
  try {
    n = e();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var o;
      const a = (c) => c === null ? null : JSON.parse(c, t == null ? void 0 : t.reviver), s = (o = n.getItem(i)) != null ? o : null;
      return s instanceof Promise ? s.then(a) : a(s);
    },
    setItem: (i, o) => n.setItem(
      i,
      JSON.stringify(o, t == null ? void 0 : t.replacer)
    ),
    removeItem: (i) => n.removeItem(i)
  };
}
const $s = (e) => (t) => {
  try {
    const n = e(t);
    return n instanceof Promise ? n : {
      then(r) {
        return $s(r)(n);
      },
      catch(r) {
        return this;
      }
    };
  } catch (n) {
    return {
      then(r) {
        return this;
      },
      catch(r) {
        return $s(r)(n);
      }
    };
  }
}, h7 = (e, t) => (n, r, i) => {
  let o = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (y) => y,
    version: 0,
    merge: (y, g) => ({
      ...g,
      ...y
    }),
    ...t
  }, a = !1;
  const s = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  let l;
  try {
    l = o.getStorage();
  } catch {
  }
  if (!l)
    return e(
      (...y) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`
        ), n(...y);
      },
      r,
      i
    );
  const u = $s(o.serialize), d = () => {
    const y = o.partialize({ ...r() });
    let g;
    const v = u({ state: y, version: o.version }).then(
      (b) => l.setItem(o.name, b)
    ).catch((b) => {
      g = b;
    });
    if (g)
      throw g;
    return v;
  }, p = i.setState;
  i.setState = (y, g) => {
    p(y, g), d();
  };
  const f = e(
    (...y) => {
      n(...y), d();
    },
    r,
    i
  );
  let h;
  const m = () => {
    var y;
    if (!l)
      return;
    a = !1, s.forEach((v) => v(r()));
    const g = ((y = o.onRehydrateStorage) == null ? void 0 : y.call(o, r())) || void 0;
    return $s(l.getItem.bind(l))(o.name).then((v) => {
      if (v)
        return o.deserialize(v);
    }).then((v) => {
      if (v)
        if (typeof v.version == "number" && v.version !== o.version) {
          if (o.migrate)
            return o.migrate(
              v.state,
              v.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return v.state;
    }).then((v) => {
      var b;
      return h = o.merge(
        v,
        (b = r()) != null ? b : f
      ), n(h, !0), d();
    }).then(() => {
      g == null || g(h, void 0), a = !0, c.forEach((v) => v(h));
    }).catch((v) => {
      g == null || g(void 0, v);
    });
  };
  return i.persist = {
    setOptions: (y) => {
      o = {
        ...o,
        ...y
      }, y.getStorage && (l = y.getStorage());
    },
    clearStorage: () => {
      l == null || l.removeItem(o.name);
    },
    getOptions: () => o,
    rehydrate: () => m(),
    hasHydrated: () => a,
    onHydrate: (y) => (s.add(y), () => {
      s.delete(y);
    }),
    onFinishHydration: (y) => (c.add(y), () => {
      c.delete(y);
    })
  }, m(), h || f;
}, m7 = (e, t) => (n, r, i) => {
  let o = {
    storage: p7(() => localStorage),
    partialize: (m) => m,
    version: 0,
    merge: (m, y) => ({
      ...y,
      ...m
    }),
    ...t
  }, a = !1;
  const s = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  let l = o.storage;
  if (!l)
    return e(
      (...m) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`
        ), n(...m);
      },
      r,
      i
    );
  const u = () => {
    const m = o.partialize({ ...r() });
    return l.setItem(o.name, {
      state: m,
      version: o.version
    });
  }, d = i.setState;
  i.setState = (m, y) => {
    d(m, y), u();
  };
  const p = e(
    (...m) => {
      n(...m), u();
    },
    r,
    i
  );
  let f;
  const h = () => {
    var m, y;
    if (!l)
      return;
    a = !1, s.forEach((v) => {
      var b;
      return v((b = r()) != null ? b : p);
    });
    const g = ((y = o.onRehydrateStorage) == null ? void 0 : y.call(o, (m = r()) != null ? m : p)) || void 0;
    return $s(l.getItem.bind(l))(o.name).then((v) => {
      if (v)
        if (typeof v.version == "number" && v.version !== o.version) {
          if (o.migrate)
            return o.migrate(
              v.state,
              v.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return v.state;
    }).then((v) => {
      var b;
      return f = o.merge(
        v,
        (b = r()) != null ? b : p
      ), n(f, !0), u();
    }).then(() => {
      g == null || g(f, void 0), f = r(), a = !0, c.forEach((v) => v(f));
    }).catch((v) => {
      g == null || g(void 0, v);
    });
  };
  return i.persist = {
    setOptions: (m) => {
      o = {
        ...o,
        ...m
      }, m.storage && (l = m.storage);
    },
    clearStorage: () => {
      l == null || l.removeItem(o.name);
    },
    getOptions: () => o,
    rehydrate: () => h(),
    hasHydrated: () => a,
    onHydrate: (m) => (s.add(m), () => {
      s.delete(m);
    }),
    onFinishHydration: (m) => (c.add(m), () => {
      c.delete(m);
    })
  }, o.skipHydration || h(), f || p;
}, y7 = (e, t) => "getStorage" in t || "serialize" in t || "deserialize" in t ? h7(e, t) : m7(e, t), g7 = y7, ir = u7()(
  pE(
    g7(
      (e, t) => ({
        messageHistory: {},
        addMessageToHistory: ({ userId: n, message: r }) => e((i) => ({
          ...i,
          messageHistory: {
            ...i.messageHistory,
            [n]: [r, ...(i.messageHistory[n] ?? []).slice(0, 100)]
          }
        })),
        clientMode: "",
        setClientMode: (n) => {
          const { clearAll: r, clientMode: i } = t();
          i !== n && r(), e((o) => ({
            ...o,
            clientMode: n
          }));
        },
        setUser: (n) => e((r) => ({
          ...r,
          user: n
        })),
        setConversationId: (n) => e((r) => ({
          ...r,
          conversationId: n
        })),
        clearAll: () => {
          e((n) => ({
            ...n,
            messageHistory: {},
            user: void 0,
            conversationId: void 0
          }));
        }
      }),
      {
        name: "botpress-webchat"
      }
    )
  )
), hE = gr(null), v7 = (e) => {
  const t = {
    theme: {},
    configuration: {},
    messages: {},
    connected: !0,
    disableComposer: !1,
    renderers: {},
    isReadOnly: !1,
    userData: {},
    userName: void 0,
    userPictureUrl: void 0,
    closeWindow: () => {
    },
    messageContainerRef: { current: null },
    isTyping: !1,
    lastTypingHeartbeat: null,
    allowFileUpload: !1,
    conversationId: void 0,
    disableRestartConversation: !1
  }, n = e == null ? void 0 : e.client, r = e == null ? void 0 : e.conversationId, i = ir.getState().setClientMode, o = ir.getState().setConversationId;
  return n && i(n.mode), Ne(() => {
    r && o(r);
  }, [r]), uE()(
    pE(
      (a, s) => {
        const c = (d) => {
          const p = ir.getState().conversationId;
          if (p)
            return a((f) => {
              const h = f.messages[p] ?? [];
              return {
                ...f,
                messages: {
                  ...f.messages,
                  [p]: [...h.filter((m) => m.id !== d.id), { id: su(), ...d }]
                }
              };
            });
        }, l = (d) => {
          const p = ir.getState().conversationId;
          if (p)
            return a((f) => ({ ...f, messages: { ...f.messages, [p]: d } }));
        }, u = ir.getState().addMessageToHistory;
        return {
          ...t,
          ...e,
          eventEmitter: bD,
          client: n,
          sendFile: (d) => s().client.sendFile(d),
          sendTextMessage: async (d) => {
            const p = s().client;
            c({
              id: su(),
              direction: "outgoing",
              sender: { name: "You" },
              timestamp: /* @__PURE__ */ new Date(),
              disableInput: !1,
              block: { type: "bubble", block: { type: "text", text: d } }
            }), p && await p.sendMessage(d), p != null && p.userId && u({ message: d, userId: p.userId });
          },
          on: (d, p) => {
            const f = s().client;
            return f ? f.on(d, p) : () => {
            };
          },
          getClientId: () => {
            var d;
            return (d = s().client) == null ? void 0 : d.clientId;
          },
          setState: (d) => a((p) => ({ ...p, ...d })),
          setTheme: (d) => a((p) => ({ ...p, theme: d })),
          setMessages: l,
          getMessages: () => s().messages[ir.getState().conversationId ?? ""] ?? [],
          setConfiguration: (d) => a((p) => ({ ...p, configuration: d })),
          setIsTyping: (d, p) => {
            a((f) => ({ ...f, isTyping: d })), d && (a((f) => ({ ...f, lastTypingHeartbeat: /* @__PURE__ */ new Date() })), p && setTimeout(() => {
              const f = s().lastTypingHeartbeat;
              f && (/* @__PURE__ */ new Date()).getTime() - f.getTime() > p && a((h) => ({ ...h, isTyping: !1 }));
            }, p + 100));
          },
          setLastTypingHeartbeat: (d) => a((p) => ({ ...p, lastTypingHeartbeat: d })),
          addMessage: c,
          setConnected: (d) => a((p) => ({ ...p, connected: d })),
          restartConversation: async () => {
            const d = s().client, p = s().setMessages;
            d && (await d.newConversation(), p([]));
          }
        };
      },
      { name: "webchatStore" }
    )
  );
};
function Ie(e) {
  const t = Ir(hE);
  if (!t)
    throw new Error("Missing WebchatContext.Provider in the tree");
  return fE(t, e);
}
const b7 = ({ text: e, buttonValue: t, type: n, styles: r, variant: i, groupId: o, reusable: a, ...s }) => {
  const c = Ie((v) => v.eventEmitter), l = Ie((v) => v.sendTextMessage), u = Ie((v) => v.isReadOnly), [d, p] = Ve(!1), [f, h] = Ve(!1), [m, y] = Ve(!1);
  Ne(() => {
    if (o)
      return c.on(`button-group-${o}-click`, () => {
        h(!0), a || y(!0);
      });
  }, [c, o, a]);
  function g() {
    o && c.emit(`button-group-${o}-click`), p(!0), a || y(!0), i !== "link" && l(t);
  }
  return /* @__PURE__ */ F.jsx(
    w7,
    {
      ...s,
      variant: i,
      onClick: g,
      disabled: m || u,
      "data-activated": d ? "" : void 0,
      "data-group-activated": f ? "" : void 0,
      "data-type": i,
      value: t,
      ...r == null ? void 0 : r[n],
      children: e
    }
  );
}, w7 = (e) => {
  if (e.variant === "link") {
    const { value: r, variant: i, ...o } = e;
    return /* @__PURE__ */ F.jsx("a", { ...o, href: r, target: "_blank", rel: "noopener noreferrer" });
  }
  const { variant: t, ...n } = e;
  return /* @__PURE__ */ F.jsx("button", { type: "button", ...n });
}, x7 = Ue(({ block: e, styles: t, type: n, ...r }, i) => /* @__PURE__ */ F.jsx("div", { ...r, ...t == null ? void 0 : t[n], ref: i, children: /* @__PURE__ */ F.jsx(yc, { styles: t, block: e }) })), mE = gr(null);
function yE() {
  const e = Ir(mE);
  if (!e)
    throw new Error("useComposerContext must be used within a Message");
  return e;
}
const gE = gr(null);
function _7() {
  const e = Ir(gE);
  if (!e)
    throw new Error("useMessageContext must be used within a Message");
  return e;
}
const vE = gr(null);
function bE() {
  const e = Ir(vE);
  if (!e)
    throw new Error("useModalContext must be used within a ModalProvider");
  return e;
}
gr(null);
const S7 = Ue(
  ({ url: e, type: t, styles: n, orientation: r = "auto", ...i }, o) => {
    var p, f;
    const a = HC(), { setIsLoading: s } = _7(), [c, l] = Ve(r), [u, d] = Ve(!1);
    return Ls(() => {
      s((h) => [...h, a]);
    }, []), Ne(() => {
      e && c === "auto" && E6(e).then(({ width: h, height: m }) => {
        l(k7(h, m)), s((y) => y.filter((g) => g !== a));
      });
    }, [e]), /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
      u ? null : /* @__PURE__ */ F.jsx("div", { "data-orientation": c, ...(p = n == null ? void 0 : n[t]) == null ? void 0 : p.placeholder }),
      /* @__PURE__ */ F.jsx(
        "img",
        {
          "data-orientation": c,
          "data-loaded": u,
          ...i,
          ...(f = n == null ? void 0 : n[t]) == null ? void 0 : f.image,
          src: e,
          alt: "",
          ref: o,
          loading: "lazy",
          onLoad: () => {
            d(!0);
          }
        }
      )
    ] });
  }
);
function k7(e, t) {
  const n = {
    square: 1,
    portrait: 0.75,
    landscape: 1.3333333333333333
  }, r = e / t;
  return Object.keys(n).reduce((o, a) => Math.abs(n[a] - r) < Math.abs(n[o] - r) ? a : o);
}
const E7 = Ue(({ url: e, type: t, styles: n, ...r }, i) => /* @__PURE__ */ F.jsx("div", { children: /* @__PURE__ */ F.jsx("video", { ...r, controls: !0, src: e, ...n == null ? void 0 : n[t], ref: i }) })), C7 = Ue(({ url: e, type: t, styles: n, ...r }, i) => /* @__PURE__ */ F.jsx("div", { children: /* @__PURE__ */ F.jsx("audio", { ...r, controls: !0, src: e, ...n == null ? void 0 : n[t], ref: i }) }));
function T7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    fillRule: "evenodd",
    d: "M10 3a.75.75 0 01.75.75v10.638l3.96-4.158a.75.75 0 111.08 1.04l-5.25 5.5a.75.75 0 01-1.08 0l-5.25-5.5a.75.75 0 111.08-1.04l3.96 4.158V3.75A.75.75 0 0110 3z",
    clipRule: "evenodd"
  }));
}
const R7 = D.forwardRef(T7), A7 = R7;
function O7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    fillRule: "evenodd",
    d: "M15.312 11.424a5.5 5.5 0 01-9.201 2.466l-.312-.311h2.433a.75.75 0 000-1.5H3.989a.75.75 0 00-.75.75v4.242a.75.75 0 001.5 0v-2.43l.31.31a7 7 0 0011.712-3.138.75.75 0 00-1.449-.39zm1.23-3.723a.75.75 0 00.219-.53V2.929a.75.75 0 00-1.5 0V5.36l-.31-.31A7 7 0 003.239 8.188a.75.75 0 101.448.389A5.5 5.5 0 0113.89 6.11l.311.31h-2.432a.75.75 0 000 1.5h4.243a.75.75 0 00.53-.219z",
    clipRule: "evenodd"
  }));
}
const I7 = D.forwardRef(O7), P7 = I7;
function $7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm-.75-4.75a.75.75 0 001.5 0V8.66l1.95 2.1a.75.75 0 101.1-1.02l-3.25-3.5a.75.75 0 00-1.1 0L6.2 9.74a.75.75 0 101.1 1.02l1.95-2.1v4.59z",
    clipRule: "evenodd"
  }));
}
const D7 = D.forwardRef($7), N7 = D7;
function j7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    fillRule: "evenodd",
    d: "M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z",
    clipRule: "evenodd"
  }));
}
const M7 = D.forwardRef(j7), q7 = M7;
function L7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    fillRule: "evenodd",
    d: "M4.5 2A1.5 1.5 0 003 3.5v13A1.5 1.5 0 004.5 18h11a1.5 1.5 0 001.5-1.5V7.621a1.5 1.5 0 00-.44-1.06l-4.12-4.122A1.5 1.5 0 0011.378 2H4.5zm4.75 6.75a.75.75 0 011.5 0v2.546l.943-1.048a.75.75 0 011.114 1.004l-2.25 2.5a.75.75 0 01-1.114 0l-2.25-2.5a.75.75 0 111.114-1.004l.943 1.048V8.75z",
    clipRule: "evenodd"
  }));
}
const F7 = D.forwardRef(L7), U7 = F7;
function B7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    fillRule: "evenodd",
    d: "M9.69 18.933l.003.001C9.89 19.02 10 19 10 19s.11.02.308-.066l.002-.001.006-.003.018-.008a5.741 5.741 0 00.281-.14c.186-.096.446-.24.757-.433.62-.384 1.445-.966 2.274-1.765C15.302 14.988 17 12.493 17 9A7 7 0 103 9c0 3.492 1.698 5.988 3.355 7.584a13.731 13.731 0 002.273 1.765 11.842 11.842 0 00.976.544l.062.029.018.008.006.003zM10 11.25a2.25 2.25 0 100-4.5 2.25 2.25 0 000 4.5z",
    clipRule: "evenodd"
  }));
}
const z7 = D.forwardRef(B7), Z7 = z7;
function V7({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    d: "M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z"
  }));
}
const H7 = D.forwardRef(V7), W7 = H7, K7 = Ue(
  ({ type: e, latitude: t, longitude: n, title: r, styles: i, ...o }, a) => {
    var c, l, u;
    const s = `https://www.google.com/maps/search/?api=1&query=${t},${n}`;
    return /* @__PURE__ */ F.jsxs("a", { ...o, ...(c = i == null ? void 0 : i[e]) == null ? void 0 : c.container, href: s, type: "_blank", rel: "noopener", ref: a, children: [
      /* @__PURE__ */ F.jsx("p", { ...(l = i == null ? void 0 : i[e]) == null ? void 0 : l.title, children: r }),
      /* @__PURE__ */ F.jsx(Z7, { ...(u = i == null ? void 0 : i[e]) == null ? void 0 : u.icon })
    ] });
  }
), J7 = Ue(
  ({ blocks: e, styles: t, type: n, horizontalAlignment: r, verticalAlignment: i, ...o }, a) => /* @__PURE__ */ F.jsx(
    "div",
    {
      "data-horizontal": r,
      "data-vertical": i,
      ...o,
      ...t == null ? void 0 : t[n],
      ref: a,
      children: e.map((s, c) => /* @__PURE__ */ F.jsx(yc, { styles: t, block: s }, c))
    }
  )
), Y7 = Ue(
  ({ blocks: e, styles: t, type: n, horizontalAlignment: r, verticalAlignment: i, ...o }, a) => /* @__PURE__ */ F.jsx(
    "div",
    {
      "data-horizontal": r,
      "data-vertical": i,
      ...o,
      ...t == null ? void 0 : t[n],
      ref: a,
      children: e.map((s, c) => /* @__PURE__ */ F.jsx(yc, { styles: t, block: s }, c))
    }
  )
);
function G7(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Yv(e) {
  return G7(e) || Array.isArray(e);
}
function X7() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function Qm(e, t) {
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return !1;
  const i = JSON.stringify(Object.keys(e.breakpoints || {})), o = JSON.stringify(Object.keys(t.breakpoints || {}));
  return i !== o ? !1 : n.every((a) => {
    const s = e[a], c = t[a];
    return typeof s == "function" ? `${s}` == `${c}` : !Yv(s) || !Yv(c) ? s === c : Qm(s, c);
  });
}
function Gv(e) {
  return e.concat().sort((t, n) => t.name > n.name ? 1 : -1).map((t) => t.options);
}
function Q7(e, t) {
  if (e.length !== t.length)
    return !1;
  const n = Gv(e), r = Gv(t);
  return n.every((i, o) => {
    const a = r[o];
    return Qm(i, a);
  });
}
function ey(e) {
  return typeof e == "number";
}
function Xv(e) {
  return typeof e == "string";
}
function ty(e) {
  return typeof e == "boolean";
}
function Qv(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Gt(e) {
  return Math.abs(e);
}
function ny(e) {
  return Math.sign(e);
}
function cl(e, t) {
  return Gt(e - t);
}
function e9(e, t) {
  if (e === 0 || t === 0 || Gt(e) <= Gt(t))
    return 0;
  const n = cl(Gt(e), Gt(t));
  return Gt(n / e);
}
function Ds(e) {
  return Iu(e).map(Number);
}
function ui(e) {
  return e[Vd(e)];
}
function Vd(e) {
  return Math.max(0, e.length - 1);
}
function Iu(e) {
  return Object.keys(e);
}
function wE(e, t) {
  return [e, t].reduce((n, r) => (Iu(r).forEach((i) => {
    const o = n[i], a = r[i], s = Qv(o) && Qv(a);
    n[i] = s ? wE(o, a) : a;
  }), n), {});
}
function xE(e, t) {
  return typeof t.MouseEvent < "u" && e instanceof t.MouseEvent;
}
function t9(e, t) {
  const n = {
    start: r,
    center: i,
    end: o
  };
  function r() {
    return 0;
  }
  function i(l) {
    return o(l) / 2;
  }
  function o(l) {
    return t - l;
  }
  function a() {
    return t * Number(e);
  }
  function s(l) {
    return ey(e) ? a() : n[e](l);
  }
  return {
    measure: s
  };
}
function n9(e, t) {
  const n = e === "y" ? "y" : "x", r = e === "y" ? "x" : "y", i = s(), o = c();
  function a(u) {
    const {
      width: d,
      height: p
    } = u;
    return n === "x" ? d : p;
  }
  function s() {
    return n === "y" ? "top" : t === "rtl" ? "right" : "left";
  }
  function c() {
    return n === "y" ? "bottom" : t === "rtl" ? "left" : "right";
  }
  return {
    scroll: n,
    cross: r,
    startEdge: i,
    endEdge: o,
    measureSize: a
  };
}
function Bi(e, t) {
  const n = Gt(e - t);
  function r(l) {
    return l < e;
  }
  function i(l) {
    return l > t;
  }
  function o(l) {
    return r(l) || i(l);
  }
  function a(l) {
    return o(l) ? r(l) ? e : t : l;
  }
  function s(l) {
    return n ? l - n * Math.ceil((l - t) / n) : l;
  }
  return {
    length: n,
    max: t,
    min: e,
    constrain: a,
    reachedAny: o,
    reachedMax: i,
    reachedMin: r,
    removeOffset: s
  };
}
function _E(e, t, n) {
  const {
    constrain: r
  } = Bi(0, e), i = e + 1;
  let o = a(t);
  function a(p) {
    return n ? Gt((i + p) % i) : r(p);
  }
  function s() {
    return o;
  }
  function c(p) {
    return o = a(p), d;
  }
  function l(p) {
    return u().set(s() + p);
  }
  function u() {
    return _E(e, s(), n);
  }
  const d = {
    get: s,
    set: c,
    add: l,
    clone: u
  };
  return d;
}
function r9(e) {
  const t = e === "rtl" ? -1 : 1;
  function n(i) {
    return i * t;
  }
  return {
    apply: n
  };
}
function Ns() {
  let e = [];
  function t(i, o, a, s = {
    passive: !0
  }) {
    return i.addEventListener(o, a, s), e.push(() => i.removeEventListener(o, a, s)), r;
  }
  function n() {
    e = e.filter((i) => i());
  }
  const r = {
    add: t,
    clear: n
  };
  return r;
}
function i9(e, t, n, r, i, o, a, s, c, l, u, d, p, f, h, m, y, g, v) {
  const {
    cross: b
  } = e, _ = ["INPUT", "SELECT", "TEXTAREA"], S = {
    passive: !1
  }, x = Ns(), A = Ns(), I = Bi(50, 225).constrain(h.measure(20)), P = {
    mouse: 300,
    touch: 400
  }, R = {
    mouse: 500,
    touch: 600
  }, M = m ? 43 : 25;
  let V = !1, U = 0, L = 0, $ = !1, j = !1, z = !1, H = !1;
  function X(ue, xe) {
    if (!xe)
      return;
    function fe(nt) {
      (ty(xe) || xe(ue, nt)) && ke(nt);
    }
    const $e = n;
    x.add($e, "dragstart", (nt) => nt.preventDefault(), S).add($e, "touchmove", () => {
    }, S).add($e, "touchend", () => {
    }).add($e, "touchstart", fe).add($e, "mousedown", fe).add($e, "touchcancel", Pe).add($e, "contextmenu", Pe).add($e, "click", Be, !0);
  }
  function E() {
    x.clear(), A.clear();
  }
  function ee() {
    const ue = H ? r : n;
    A.add(ue, "touchmove", Se, S).add(ue, "touchend", Pe).add(ue, "mousemove", Se, S).add(ue, "mouseup", Pe);
  }
  function de(ue) {
    const xe = ue.nodeName || "";
    return _.includes(xe);
  }
  function T() {
    return (m ? R : P)[H ? "mouse" : "touch"];
  }
  function be(ue, xe) {
    const fe = p.add(ny(ue) * -1), $e = d.byDistance(ue, !m).distance;
    return m || Gt(ue) < I ? $e : g && xe ? $e * 0.5 : d.byIndex(fe.get(), 0).distance;
  }
  function ke(ue) {
    const xe = xE(ue, i);
    H = xe, !(xe && ue.button !== 0) && (de(ue.target) || (z = m && xe && !ue.buttons && V, V = cl(o.get(), s.get()) >= 2, $ = !0, a.pointerDown(ue), u.useFriction(0).useDuration(0), o.set(s), ee(), U = a.readPoint(ue), L = a.readPoint(ue, b), f.emit("pointerDown")));
  }
  function Se(ue) {
    const xe = a.readPoint(ue), fe = a.readPoint(ue, b), $e = cl(xe, U), nt = cl(fe, L);
    if (!j && !H && (!ue.cancelable || (j = $e > nt, !j)))
      return Pe(ue);
    const q = a.pointerMove(ue);
    $e > y && (z = !0), u.useFriction(0.3).useDuration(1), c.start(), o.add(t.apply(q)), ue.preventDefault();
  }
  function Pe(ue) {
    const fe = d.byDistance(0, !1).index !== p.get(), $e = a.pointerUp(ue) * T(), nt = be(t.apply($e), fe), q = e9($e, nt), ie = M - 10 * q, se = v + q / 50;
    j = !1, $ = !1, A.clear(), u.useDuration(ie).useFriction(se), l.distance(nt, !m), H = !1, f.emit("pointerUp");
  }
  function Be(ue) {
    z && (ue.stopPropagation(), ue.preventDefault());
  }
  function Ae() {
    return $;
  }
  return {
    init: X,
    pointerDown: Ae,
    destroy: E
  };
}
function o9(e, t) {
  let r, i;
  function o(d) {
    return d.timeStamp;
  }
  function a(d, p) {
    const h = `client${(p || e.scroll) === "x" ? "X" : "Y"}`;
    return (xE(d, t) ? d : d.touches[0])[h];
  }
  function s(d) {
    return r = d, i = d, a(d);
  }
  function c(d) {
    const p = a(d) - a(i), f = o(d) - o(r) > 170;
    return i = d, f && (r = d), p;
  }
  function l(d) {
    if (!r || !i)
      return 0;
    const p = a(i) - a(r), f = o(d) - o(r), h = o(d) - o(i) > 170, m = p / f;
    return f && !h && Gt(m) > 0.1 ? m : 0;
  }
  return {
    pointerDown: s,
    pointerMove: c,
    pointerUp: l,
    readPoint: a
  };
}
function a9(e) {
  function t(r) {
    return e * (r / 100);
  }
  return {
    measure: t
  };
}
function s9(e, t, n, r, i) {
  let o, a, s = [], c = !1;
  function l(f) {
    return i.measureSize(f.getBoundingClientRect());
  }
  function u(f, h) {
    if (!h)
      return;
    a = l(e), s = r.map(l);
    function m(g) {
      for (const v of g) {
        const b = v.target === e, _ = r.indexOf(v.target), S = b ? a : s[_], x = l(b ? e : r[_]);
        if (S !== x) {
          n.requestAnimationFrame(() => {
            f.reInit(), t.emit("resize");
          });
          break;
        }
      }
    }
    o = new ResizeObserver((g) => {
      c || (ty(h) || h(f, g)) && m(g);
    }), [e].concat(r).forEach((g) => o.observe(g));
  }
  function d() {
    o && o.disconnect(), c = !0;
  }
  return {
    init: u,
    destroy: d
  };
}
function c9(e, t, n, r) {
  let i = !0, o = 0, a = 0, s = n, c = r, l = e.get(), u = 0;
  function d() {
    const S = t.get() - e.get(), x = !s;
    let A = 0;
    return x ? (o = 0, e.set(t), A = S) : (o += S / s, o *= c, l += o, e.add(o), A = l - u), a = ny(A), u = l, i = Gt(S) < 1e-3, _;
  }
  function p() {
    return i;
  }
  function f() {
    return s;
  }
  function h() {
    return a;
  }
  function m() {
    return o;
  }
  function y() {
    return v(n);
  }
  function g() {
    return b(r);
  }
  function v(S) {
    return s = S, _;
  }
  function b(S) {
    return c = S, _;
  }
  const _ = {
    direction: h,
    duration: f,
    velocity: m,
    seek: d,
    settled: p,
    useBaseFriction: g,
    useBaseDuration: y,
    useFriction: b,
    useDuration: v
  };
  return _;
}
function l9(e, t, n, r, i) {
  const o = i.measure(10), a = i.measure(50), s = Bi(0.1, 0.99);
  let c = !1;
  function l() {
    return !(c || !e.reachedAny(n.get()) || !e.reachedAny(t.get()));
  }
  function u(f) {
    if (!l())
      return;
    const h = e.reachedMin(t.get()) ? "min" : "max", m = Gt(e[h] - t.get()), y = n.get() - t.get(), g = s.constrain(m / a);
    n.subtract(y * g), !f && Gt(y) < o && (n.set(e.constrain(n.get())), r.useDuration(25).useBaseFriction());
  }
  function d(f) {
    c = !f;
  }
  return {
    constrain: u,
    toggleActive: d
  };
}
function u9(e, t, n, r) {
  const i = Bi(-t + e, n[0]), o = c(), a = l();
  function s() {
    const d = o[0], p = ui(o), f = o.lastIndexOf(d), h = o.indexOf(p) + 1;
    return Bi(f, h);
  }
  function c() {
    return n.map(i.constrain).map((d) => parseFloat(d.toFixed(3)));
  }
  function l() {
    if (t <= e)
      return [i.max];
    if (r === "keepSnaps")
      return o;
    const {
      min: d,
      max: p
    } = s();
    return o.slice(d, p);
  }
  return {
    snapsContained: a
  };
}
function d9(e, t, n) {
  const r = t[0], i = n ? r - e : ui(t);
  return {
    limit: Bi(i, r)
  };
}
function f9(e, t, n, r) {
  const o = t.min + 0.1, a = t.max + 0.1, {
    reachedMin: s,
    reachedMax: c
  } = Bi(o, a);
  function l(p) {
    return p === 1 ? c(n.get()) : p === -1 ? s(n.get()) : !1;
  }
  function u(p) {
    if (!l(p))
      return;
    const f = e * (p * -1);
    r.forEach((h) => h.add(f));
  }
  return {
    loop: u
  };
}
function p9(e) {
  const {
    max: t,
    length: n
  } = e;
  function r(o) {
    return (o - t) / -n;
  }
  return {
    get: r
  };
}
function h9(e, t, n, r, i, o, a) {
  const {
    startEdge: s,
    endEdge: c
  } = e, {
    groupSlides: l
  } = o, u = f().map(t.measure), d = h(), p = m();
  function f() {
    return l(r).map((g) => ui(g)[c] - g[0][s]).map(Gt);
  }
  function h() {
    return r.map((g) => n[s] - g[s]).map((g) => -Gt(g));
  }
  function m() {
    const v = ui(d) - ui(i);
    return l(d).map((b) => b[0]).map((b, _, S) => {
      const x = !_, A = _ === Vd(S);
      return a && x ? 0 : a && A ? v : b + u[_];
    });
  }
  return {
    snaps: d,
    snapsAligned: p
  };
}
function m9(e, t, n, r, i) {
  const {
    reachedAny: o,
    removeOffset: a,
    constrain: s
  } = r;
  function c(h) {
    return h.concat().sort((m, y) => Gt(m) - Gt(y))[0];
  }
  function l(h) {
    const m = e ? a(h) : s(h), y = t.map((v) => v - m).map((v) => u(v, 0)).map((v, b) => ({
      diff: v,
      index: b
    })).sort((v, b) => Gt(v.diff) - Gt(b.diff)), {
      index: g
    } = y[0];
    return {
      index: g,
      distance: m
    };
  }
  function u(h, m) {
    const y = [h, h + n, h - n];
    if (!e)
      return y[0];
    if (!m)
      return c(y);
    const g = y.filter((v) => ny(v) === m);
    return c(g);
  }
  function d(h, m) {
    const y = t[h] - i.get(), g = u(y, m);
    return {
      index: h,
      distance: g
    };
  }
  function p(h, m) {
    const y = i.get() + h, {
      index: g,
      distance: v
    } = l(y), b = !e && o(y);
    if (!m || b)
      return {
        index: g,
        distance: h
      };
    const _ = t[g] - v, S = h + u(_, 0);
    return {
      index: g,
      distance: S
    };
  }
  return {
    byDistance: p,
    byIndex: d,
    shortcut: u
  };
}
function y9(e, t, n, r, i, o, a) {
  function s(d) {
    const p = d.distance, f = d.index !== t.get();
    o.add(p), p && (i.duration() ? e.start() : (e.update(), e.render(1), e.update())), f && (n.set(t.get()), t.set(d.index), a.emit("select"));
  }
  function c(d, p) {
    const f = r.byDistance(d, p);
    s(f);
  }
  function l(d, p) {
    const f = t.clone().set(d), h = r.byIndex(f.get(), p);
    s(h);
  }
  return {
    distance: c,
    index: l
  };
}
function ll(e) {
  let t = e;
  function n() {
    return t;
  }
  function r(c) {
    t = a(c);
  }
  function i(c) {
    t += a(c);
  }
  function o(c) {
    t -= a(c);
  }
  function a(c) {
    return ey(c) ? c : c.get();
  }
  return {
    get: n,
    set: r,
    add: i,
    subtract: o
  };
}
function SE(e, t, n) {
  const r = e.scroll === "x" ? a : s, i = n.style;
  let o = !1;
  function a(p) {
    return `translate3d(${p}px,0px,0px)`;
  }
  function s(p) {
    return `translate3d(0px,${p}px,0px)`;
  }
  function c(p) {
    o || (i.transform = r(t.apply(p)));
  }
  function l(p) {
    o = !p;
  }
  function u() {
    o || (i.transform = "", n.getAttribute("style") || n.removeAttribute("style"));
  }
  return {
    clear: u,
    to: c,
    toggleActive: l
  };
}
function g9(e, t, n, r, i, o, a, s, c) {
  const l = Ds(i), u = Ds(i).reverse(), d = m().concat(y());
  function p(S, x) {
    return S.reduce((A, I) => A - i[I], x);
  }
  function f(S, x) {
    return S.reduce((A, I) => p(A, x) > 0 ? A.concat([I]) : A, []);
  }
  function h(S, x) {
    const A = x === "start", I = A ? -r : r, P = a.findSlideBounds([I]);
    return S.map((R) => {
      const M = A ? 0 : -r, V = A ? r : 0, L = P.filter(($) => $.index === R)[0][A ? "end" : "start"];
      return {
        index: R,
        slideLocation: ll(-1),
        translate: SE(e, t, c[R]),
        target: () => s.get() > L ? M : V
      };
    });
  }
  function m() {
    const S = o[0] - 1, x = f(u, S);
    return h(x, "end");
  }
  function y() {
    const S = n - o[0] - 1, x = f(l, S);
    return h(x, "start");
  }
  function g() {
    return d.every(({
      index: S
    }) => {
      const x = l.filter((A) => A !== S);
      return p(x, n) <= 0.1;
    });
  }
  function v() {
    d.forEach((S) => {
      const {
        target: x,
        translate: A,
        slideLocation: I
      } = S, P = x();
      P !== I.get() && (A.to(P), I.set(P));
    });
  }
  function b() {
    d.forEach((S) => S.translate.clear());
  }
  return {
    canLoop: g,
    clear: b,
    loop: v,
    loopPoints: d
  };
}
function v9(e, t) {
  let n, r = !1;
  function i(s, c) {
    if (!c)
      return;
    function l(u) {
      for (const d of u)
        if (d.type === "childList") {
          s.reInit(), t.emit("slidesChanged");
          break;
        }
    }
    n = new MutationObserver((u) => {
      r || (ty(c) || c(s, u)) && l(u);
    }), n.observe(e, {
      childList: !0
    });
  }
  function o() {
    n && n.disconnect(), r = !0;
  }
  return {
    init: i,
    destroy: o
  };
}
function b9(e, t, n, r, i, o, a) {
  const {
    removeOffset: s,
    constrain: c
  } = i, l = 0.5, u = o ? [0, t, -t] : [0], d = f(u, a);
  function p(y) {
    const g = y || 0;
    return n.map((v) => Bi(l, v - l).constrain(v * g));
  }
  function f(y, g) {
    const v = y || u, b = p(g);
    return v.reduce((_, S) => {
      const x = r.map((A, I) => ({
        start: A - n[I] + b[I] + S,
        end: A + e - b[I] + S,
        index: I
      }));
      return _.concat(x);
    }, []);
  }
  function h(y, g) {
    const v = o ? s(y) : c(y);
    return (g || d).reduce((_, S) => {
      const {
        index: x,
        start: A,
        end: I
      } = S, P = _.includes(x), R = A < v && I > v;
      return !P && R ? _.concat([x]) : _;
    }, []);
  }
  return {
    check: h,
    findSlideBounds: f
  };
}
function w9(e, t, n, r, i, o) {
  const {
    measureSize: a,
    startEdge: s,
    endEdge: c
  } = e, l = n[0] && i, u = h(), d = m(), p = n.map(a), f = y();
  function h() {
    if (!l)
      return 0;
    const v = n[0];
    return Gt(t[s] - v[s]);
  }
  function m() {
    if (!l)
      return 0;
    const v = o.getComputedStyle(ui(r));
    return parseFloat(v.getPropertyValue(`margin-${c}`));
  }
  function y() {
    return n.map((v, b, _) => {
      const S = !b, x = b === Vd(_);
      return S ? p[b] + u : x ? p[b] + d : _[b + 1][s] - v[s];
    }).map(Gt);
  }
  return {
    slideSizes: p,
    slideSizesWithGaps: f
  };
}
function x9(e, t, n) {
  const r = ey(n);
  function i(c, l) {
    return Ds(c).filter((u) => u % l === 0).map((u) => c.slice(u, u + l));
  }
  function o(c) {
    return Ds(c).reduce((l, u) => {
      const p = t.slice(ui(l), u + 1).reduce((f, h) => f + h, 0);
      return !u || p > e ? l.concat(u) : l;
    }, []).map((l, u, d) => c.slice(l, d[u + 1]));
  }
  function a(c) {
    return r ? i(c, n) : o(c);
  }
  return {
    groupSlides: a
  };
}
function _9(e, t, n, r, i, o, a, s) {
  const {
    align: c,
    axis: l,
    direction: u,
    startIndex: d,
    inViewThreshold: p,
    loop: f,
    duration: h,
    dragFree: m,
    dragThreshold: y,
    slidesToScroll: g,
    skipSnaps: v,
    containScroll: b
  } = o, _ = t.getBoundingClientRect(), S = n.map((se) => se.getBoundingClientRect()), x = r9(u), A = n9(l, u), I = A.measureSize(_), P = a9(I), R = t9(c, I), M = !f && !!b, V = f || !!b, {
    slideSizes: U,
    slideSizesWithGaps: L
  } = w9(A, _, S, n, V, i), $ = x9(I, L, g), {
    snaps: j,
    snapsAligned: z
  } = h9(A, R, _, S, L, $, M), H = -ui(j) + ui(L), {
    snapsContained: X
  } = u9(I, H, z, b), E = M ? X : z, {
    limit: ee
  } = d9(H, E, f), de = _E(Vd(E), d, f), T = de.clone(), be = Ds(n), ke = ({
    dragHandler: se,
    scrollBody: le,
    scrollBounds: De,
    eventHandler: _e,
    animation: Ze,
    options: {
      loop: yt
    }
  }) => {
    const et = se.pointerDown();
    yt || De.constrain(et);
    const W = le.seek().settled();
    W && !et && (Ze.stop(), _e.emit("settle")), W || _e.emit("scroll");
  }, Se = ({
    scrollBody: se,
    translate: le,
    location: De,
    offsetLocation: _e,
    scrollLooper: Ze,
    slideLooper: yt,
    options: {
      loop: et
    }
  }, W) => {
    const re = se.velocity();
    _e.set(De.get() - re + re * W), et && (Ze.loop(se.direction()), yt.loop()), le.to(_e.get());
  }, Pe = {
    start: () => s.start(ie),
    stop: () => s.stop(ie),
    update: () => ke(ie),
    render: (se) => Se(ie, se)
  }, Be = 0.68, Ae = E[de.get()], pe = ll(Ae), ue = ll(Ae), xe = ll(Ae), fe = c9(pe, xe, h, Be), $e = m9(f, E, H, ee, xe), nt = y9(Pe, de, T, $e, fe, xe, a), q = b9(I, H, U, j, ee, f, p), ie = {
    ownerDocument: r,
    ownerWindow: i,
    eventHandler: a,
    containerRect: _,
    slideRects: S,
    animation: Pe,
    axis: A,
    direction: x,
    dragHandler: i9(A, x, e, r, i, xe, o9(A, i), pe, Pe, nt, fe, $e, de, a, P, m, y, v, Be),
    eventStore: Ns(),
    percentOfView: P,
    index: de,
    indexPrevious: T,
    limit: ee,
    location: pe,
    offsetLocation: ue,
    options: o,
    resizeHandler: s9(t, a, i, n, A),
    scrollBody: fe,
    scrollBounds: l9(ee, pe, xe, fe, P),
    scrollLooper: f9(H, ee, ue, [pe, ue, xe]),
    scrollProgress: p9(ee),
    scrollSnaps: E,
    scrollTarget: $e,
    scrollTo: nt,
    slideLooper: g9(A, x, I, H, L, E, q, ue, n),
    slidesHandler: v9(t, a),
    slidesInView: q,
    slideIndexes: be,
    slidesToScroll: $,
    target: xe,
    translate: SE(A, x, t)
  };
  return ie;
}
function S9(e) {
  const t = 16.666666666666668;
  let n = [], r = null, i = 0, o = 0;
  function a(d) {
    r || (r = d);
    const p = d - r;
    for (r = d, i += p; i >= t; )
      n.forEach(({
        animation: h
      }) => h.update()), i -= t;
    const f = Gt(i / t);
    n.forEach(({
      animation: h
    }) => h.render(f)), o && e.requestAnimationFrame(a);
  }
  function s(d) {
    n.includes(d) || n.push(d), !o && (o = e.requestAnimationFrame(a));
  }
  function c(d) {
    n = n.filter((p) => p !== d), !n.length && (e.cancelAnimationFrame(o), r = null, i = 0, o = 0);
  }
  function l() {
    r = null, i = 0;
  }
  return {
    start: s,
    stop: c,
    reset: l,
    window: e
  };
}
function k9() {
  const e = {};
  let t;
  function n(c) {
    t = c;
  }
  function r(c) {
    return e[c] || [];
  }
  function i(c) {
    return r(c).forEach((l) => l(t, c)), s;
  }
  function o(c, l) {
    return e[c] = r(c).concat([l]), s;
  }
  function a(c, l) {
    return e[c] = r(c).filter((u) => u !== l), s;
  }
  const s = {
    init: n,
    emit: i,
    off: a,
    on: o
  };
  return s;
}
const E9 = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  inViewThreshold: 0,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0
};
function C9(e) {
  function t(o, a) {
    return wE(o, a || {});
  }
  function n(o) {
    const a = o.breakpoints || {}, s = Iu(a).filter((c) => e.matchMedia(c).matches).map((c) => a[c]).reduce((c, l) => t(c, l), {});
    return t(o, s);
  }
  function r(o) {
    return o.map((a) => Iu(a.breakpoints || {})).reduce((a, s) => a.concat(s), []).map(e.matchMedia);
  }
  return {
    mergeOptions: t,
    optionsAtMedia: n,
    optionsMediaQueries: r
  };
}
function T9(e) {
  let t = [];
  function n(o, a) {
    return t = o.filter(({
      options: s
    }) => e.optionsAtMedia(s).active !== !1), t.forEach((s) => s.init(a, e)), o.reduce((s, c) => Object.assign(s, {
      [c.name]: c
    }), {});
  }
  function r() {
    t = t.filter((o) => o.destroy());
  }
  return {
    init: n,
    destroy: r
  };
}
function Ca(e, t, n) {
  const r = e.ownerDocument, i = r.defaultView, o = C9(i), a = T9(o), s = Ns(), c = Ns(), l = k9(), {
    animationRealms: u
  } = Ca, {
    mergeOptions: d,
    optionsAtMedia: p,
    optionsMediaQueries: f
  } = o, {
    on: h,
    off: m,
    emit: y
  } = l, g = U;
  let v = !1, b, _ = d(E9, Ca.globalOptions), S = d(_), x = [], A, I, P;
  function R() {
    const {
      container: fe,
      slides: $e
    } = S;
    I = (Xv(fe) ? e.querySelector(fe) : fe) || e.children[0];
    const q = Xv($e) ? I.querySelectorAll($e) : $e;
    P = [].slice.call(q || I.children);
  }
  function M(fe, $e) {
    const nt = _9(e, I, P, r, i, fe, l, $e);
    if (fe.loop && !nt.slideLooper.canLoop()) {
      const q = Object.assign({}, fe, {
        loop: !1
      });
      return M(q, $e);
    }
    return nt;
  }
  function V(fe, $e) {
    if (v)
      return;
    const nt = u.find((ie) => ie.window === i), q = nt || S9(i);
    nt || u.push(q), _ = d(_, fe), S = p(_), x = $e || x, R(), b = M(S, q), f([_, ...x.map(({
      options: ie
    }) => ie)]).forEach((ie) => s.add(ie, "change", U)), S.active && (b.translate.to(b.location.get()), b.eventHandler.init(xe), b.resizeHandler.init(xe, S.watchResize), b.slidesHandler.init(xe, S.watchSlides), c.add(r, "visibilitychange", () => {
      r.hidden && q.reset();
    }), b.options.loop && b.slideLooper.loop(), I.offsetParent && P.length && b.dragHandler.init(xe, S.watchDrag), A = a.init(x, xe));
  }
  function U(fe, $e) {
    const nt = ke();
    L(), V(d({
      startIndex: nt
    }, fe), $e), l.emit("reInit");
  }
  function L() {
    b.dragHandler.destroy(), b.animation.stop(), b.eventStore.clear(), b.translate.clear(), b.slideLooper.clear(), b.resizeHandler.destroy(), b.slidesHandler.destroy(), a.destroy(), s.clear(), c.clear();
  }
  function $() {
    v || (v = !0, s.clear(), L(), l.emit("destroy"));
  }
  function j(fe) {
    const $e = b[fe ? "target" : "location"].get(), nt = S.loop ? "removeOffset" : "constrain";
    return b.slidesInView.check(b.limit[nt]($e));
  }
  function z(fe) {
    const $e = j(fe);
    return b.slideIndexes.filter((nt) => !$e.includes(nt));
  }
  function H(fe, $e, nt) {
    !S.active || v || (b.scrollBody.useBaseFriction().useDuration($e ? 0 : S.duration), b.scrollTo.index(fe, nt || 0));
  }
  function X(fe) {
    const $e = b.index.add(1).get();
    H($e, fe === !0, -1);
  }
  function E(fe) {
    const $e = b.index.add(-1).get();
    H($e, fe === !0, 1);
  }
  function ee() {
    return b.index.add(1).get() !== ke();
  }
  function de() {
    return b.index.add(-1).get() !== ke();
  }
  function T() {
    return b.scrollSnaps.map(b.scrollProgress.get);
  }
  function be() {
    return b.scrollProgress.get(b.location.get());
  }
  function ke() {
    return b.index.get();
  }
  function Se() {
    return b.indexPrevious.get();
  }
  function Pe() {
    return A;
  }
  function Be() {
    return b;
  }
  function Ae() {
    return e;
  }
  function pe() {
    return I;
  }
  function ue() {
    return P;
  }
  const xe = {
    canScrollNext: ee,
    canScrollPrev: de,
    containerNode: pe,
    internalEngine: Be,
    destroy: $,
    off: m,
    on: h,
    emit: y,
    plugins: Pe,
    previousScrollSnap: Se,
    reInit: g,
    rootNode: Ae,
    scrollNext: X,
    scrollPrev: E,
    scrollProgress: be,
    scrollSnapList: T,
    scrollTo: H,
    selectedScrollSnap: ke,
    slideNodes: ue,
    slidesInView: j,
    slidesNotInView: z
  };
  return V(t, n), setTimeout(() => l.emit("init"), 0), xe;
}
Ca.animationRealms = [];
Ca.globalOptions = void 0;
function ry(e = {}, t = []) {
  const n = Ke(e), r = Ke(t), [i, o] = Ve(), [a, s] = Ve(), c = an(() => {
    i && i.reInit(n.current, r.current);
  }, [i]);
  return Ne(() => {
    if (X7() && a) {
      Ca.globalOptions = ry.globalOptions;
      const l = Ca(a, n.current, r.current);
      return o(l), () => l.destroy();
    } else
      o(void 0);
  }, [a, o]), Ne(() => {
    Qm(n.current, e) || (n.current = e, c());
  }, [e, c]), Ne(() => {
    Q7(r.current, t) || (r.current = t, c());
  }, [t, c]), [s, i];
}
ry.globalOptions = void 0;
function R9({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    fillRule: "evenodd",
    d: "M7.72 12.53a.75.75 0 010-1.06l7.5-7.5a.75.75 0 111.06 1.06L9.31 12l6.97 6.97a.75.75 0 11-1.06 1.06l-7.5-7.5z",
    clipRule: "evenodd"
  }));
}
const A9 = D.forwardRef(R9), O9 = A9;
function I9({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    fillRule: "evenodd",
    d: "M16.28 11.47a.75.75 0 010 1.06l-7.5 7.5a.75.75 0 01-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 011.06-1.06l7.5 7.5z",
    clipRule: "evenodd"
  }));
}
const P9 = D.forwardRef(I9), $9 = P9;
function D9({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    fillRule: "evenodd",
    d: "M5.625 1.5c-1.036 0-1.875.84-1.875 1.875v17.25c0 1.035.84 1.875 1.875 1.875h12.75c1.035 0 1.875-.84 1.875-1.875V12.75A3.75 3.75 0 0016.5 9h-1.875a1.875 1.875 0 01-1.875-1.875V5.25A3.75 3.75 0 009 1.5H5.625zM7.5 15a.75.75 0 01.75-.75h7.5a.75.75 0 010 1.5h-7.5A.75.75 0 017.5 15zm.75 2.25a.75.75 0 000 1.5H12a.75.75 0 000-1.5H8.25z",
    clipRule: "evenodd"
  }), /* @__PURE__ */ D.createElement("path", {
    d: "M12.971 1.816A5.23 5.23 0 0114.25 5.25v1.875c0 .207.168.375.375.375H16.5a5.23 5.23 0 013.434 1.279 9.768 9.768 0 00-6.963-6.963z"
  }));
}
const N9 = D.forwardRef(D9), j9 = N9;
function M9({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    d: "M1.5 8.67v8.58a3 3 0 003 3h15a3 3 0 003-3V8.67l-8.928 5.493a3 3 0 01-3.144 0L1.5 8.67z"
  }), /* @__PURE__ */ D.createElement("path", {
    d: "M22.5 6.908V6.75a3 3 0 00-3-3h-15a3 3 0 00-3 3v.158l9.714 5.978a1.5 1.5 0 001.572 0L22.5 6.908z"
  }));
}
const q9 = D.forwardRef(M9), L9 = q9;
function F9({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    d: "M21.721 12.752a9.711 9.711 0 00-.945-5.003 12.754 12.754 0 01-4.339 2.708 18.991 18.991 0 01-.214 4.772 17.165 17.165 0 005.498-2.477zM14.634 15.55a17.324 17.324 0 00.332-4.647c-.952.227-1.945.347-2.966.347-1.021 0-2.014-.12-2.966-.347a17.515 17.515 0 00.332 4.647 17.385 17.385 0 005.268 0zM9.772 17.119a18.963 18.963 0 004.456 0A17.182 17.182 0 0112 21.724a17.18 17.18 0 01-2.228-4.605zM7.777 15.23a18.87 18.87 0 01-.214-4.774 12.753 12.753 0 01-4.34-2.708 9.711 9.711 0 00-.944 5.004 17.165 17.165 0 005.498 2.477zM21.356 14.752a9.765 9.765 0 01-7.478 6.817 18.64 18.64 0 001.988-4.718 18.627 18.627 0 005.49-2.098zM2.644 14.752c1.682.971 3.53 1.688 5.49 2.099a18.64 18.64 0 001.988 4.718 9.765 9.765 0 01-7.478-6.816zM13.878 2.43a9.755 9.755 0 016.116 3.986 11.267 11.267 0 01-3.746 2.504 18.63 18.63 0 00-2.37-6.49zM12 2.276a17.152 17.152 0 012.805 7.121c-.897.23-1.837.353-2.805.353-.968 0-1.908-.122-2.805-.353A17.151 17.151 0 0112 2.276zM10.122 2.43a18.629 18.629 0 00-2.37 6.49 11.266 11.266 0 01-3.746-2.504 9.754 9.754 0 016.116-3.985z"
  }));
}
const U9 = D.forwardRef(F9), B9 = U9;
function z9({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    fillRule: "evenodd",
    d: "M12 1.5a5.25 5.25 0 00-5.25 5.25v3a3 3 0 00-3 3v6.75a3 3 0 003 3h10.5a3 3 0 003-3v-6.75a3 3 0 00-3-3v-3c0-2.9-2.35-5.25-5.25-5.25zm3.75 8.25v-3a3.75 3.75 0 10-7.5 0v3h7.5z",
    clipRule: "evenodd"
  }));
}
const Z9 = D.forwardRef(z9), V9 = Z9;
function H9({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    fillRule: "evenodd",
    d: "M1.5 4.5a3 3 0 013-3h1.372c.86 0 1.61.586 1.819 1.42l1.105 4.423a1.875 1.875 0 01-.694 1.955l-1.293.97c-.135.101-.164.249-.126.352a11.285 11.285 0 006.697 6.697c.103.038.25.009.352-.126l.97-1.293a1.875 1.875 0 011.955-.694l4.423 1.105c.834.209 1.42.959 1.42 1.82V19.5a3 3 0 01-3 3h-2.25C8.552 22.5 1.5 15.448 1.5 6.75V4.5z",
    clipRule: "evenodd"
  }));
}
const W9 = D.forwardRef(H9), K9 = W9, J9 = Ue(({ type: e, styles: t, blocks: n }, r) => {
  const [i, o] = ry({ skipSnaps: !0 }), [a, s] = Ve(!0), [c, l] = Ve(!0), u = an(() => o && o.scrollPrev(), [o]), d = an(() => o && o.scrollNext(), [o]), p = t == null ? void 0 : t[e], f = an((h) => {
    s(!h.canScrollPrev()), l(!h.canScrollNext());
  }, []);
  return Ne(() => {
    o && (f(o), o.on("reInit", f), o.on("select", f));
  }, [o, f]), /* @__PURE__ */ F.jsxs("div", { ...p == null ? void 0 : p.container, "data-container": "carousel", ref: i, children: [
    /* @__PURE__ */ F.jsx("div", { ref: r, ...p == null ? void 0 : p.slidesContainer, children: n.map((h, m) => /* @__PURE__ */ F.jsx(yc, { styles: t, block: h }, m)) }),
    /* @__PURE__ */ F.jsx(
      O9,
      {
        ...p == null ? void 0 : p.backButton,
        "data-disabled": a ? "" : void 0,
        onClick: u
      }
    ),
    /* @__PURE__ */ F.jsx(
      $9,
      {
        ...p == null ? void 0 : p.nextButton,
        "data-disabled": c ? "" : void 0,
        onClick: d
      }
    )
  ] });
}), Ta = Math.min, or = Math.max, Pu = Math.round, Yo = Math.floor, zi = (e) => ({
  x: e,
  y: e
});
function eb(e, t, n) {
  return or(e, Ta(t, n));
}
function Hd(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function dc(e) {
  return e.split("-")[0];
}
function iy(e) {
  return e.split("-")[1];
}
function kE(e) {
  return e === "x" ? "y" : "x";
}
function Y9(e) {
  return e === "y" ? "height" : "width";
}
function fc(e) {
  return ["top", "bottom"].includes(dc(e)) ? "y" : "x";
}
function G9(e) {
  return kE(fc(e));
}
function X9(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Q9(e) {
  return typeof e != "number" ? X9(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function $u(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
function Zi(e) {
  return EE(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function cr(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function vi(e) {
  var t;
  return (t = (EE(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function EE(e) {
  return e instanceof Node || e instanceof cr(e).Node;
}
function en(e) {
  return e instanceof Element || e instanceof cr(e).Element;
}
function Ln(e) {
  return e instanceof HTMLElement || e instanceof cr(e).HTMLElement;
}
function dh(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof cr(e).ShadowRoot;
}
function pc(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = lr(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function e8(e) {
  return ["table", "td", "th"].includes(Zi(e));
}
function oy(e) {
  const t = ay(), n = lr(e);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function t8(e) {
  let t = Co(e);
  for (; Ln(t) && !hc(t); ) {
    if (oy(t))
      return t;
    t = Co(t);
  }
  return null;
}
function ay() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function hc(e) {
  return ["html", "body", "#document"].includes(Zi(e));
}
function lr(e) {
  return cr(e).getComputedStyle(e);
}
function Wd(e) {
  return en(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function Co(e) {
  if (Zi(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    dh(e) && e.host || // Fallback.
    vi(e)
  );
  return dh(t) ? t.host : t;
}
function CE(e) {
  const t = Co(e);
  return hc(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Ln(t) && pc(t) ? t : CE(t);
}
function Di(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = CE(e), o = i === ((r = e.ownerDocument) == null ? void 0 : r.body), a = cr(i);
  return o ? t.concat(a, a.visualViewport || [], pc(i) ? i : [], a.frameElement && n ? Di(a.frameElement) : []) : t.concat(i, Di(i, [], n));
}
function Oi(e) {
  let t = e.activeElement;
  for (; ((n = t) == null || (r = n.shadowRoot) == null ? void 0 : r.activeElement) != null; ) {
    var n, r;
    t = t.shadowRoot.activeElement;
  }
  return t;
}
function Xn(e, t) {
  if (!e || !t)
    return !1;
  const n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && dh(n)) {
    let r = t;
    for (; r; ) {
      if (e === r)
        return !0;
      r = r.parentNode || r.host;
    }
  }
  return !1;
}
function TE() {
  const e = navigator.userAgentData;
  return e != null && e.platform ? e.platform : navigator.platform;
}
function n8() {
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? e.brands.map((t) => {
    let {
      brand: n,
      version: r
    } = t;
    return n + "/" + r;
  }).join(" ") : navigator.userAgent;
}
function RE(e) {
  if (e.mozInputSource === 0 && e.isTrusted)
    return !0;
  const t = /Android/i;
  return (t.test(TE()) || t.test(n8())) && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType;
}
function AE(e) {
  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType !== "mouse" || // iOS VoiceOver returns 0.333 for width/height.
  e.width < 1 && e.height < 1 && e.pressure === 0 && e.detail === 0;
}
function OE() {
  return /apple/i.test(navigator.vendor);
}
function r8() {
  return TE().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function tb(e, t) {
  const n = ["mouse", "pen"];
  return t || n.push("", void 0), n.includes(e);
}
function i8(e) {
  return "nativeEvent" in e;
}
function o8(e) {
  return e.matches("html,body");
}
function _r(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function Hf(e, t) {
  if (t == null)
    return !1;
  if ("composedPath" in e)
    return e.composedPath().includes(t);
  const n = e;
  return n.target != null && t.contains(n.target);
}
function IE(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
const a8 = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function PE(e) {
  return Ln(e) && e.matches(a8);
}
function Cn(e) {
  e.preventDefault(), e.stopPropagation();
}
function nb(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const o = fc(t), a = G9(t), s = Y9(a), c = dc(t), l = o === "y", u = r.x + r.width / 2 - i.width / 2, d = r.y + r.height / 2 - i.height / 2, p = r[s] / 2 - i[s] / 2;
  let f;
  switch (c) {
    case "top":
      f = {
        x: u,
        y: r.y - i.height
      };
      break;
    case "bottom":
      f = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      f = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      f = {
        x: r.x - i.width,
        y: d
      };
      break;
    default:
      f = {
        x: r.x,
        y: r.y
      };
  }
  switch (iy(t)) {
    case "start":
      f[a] -= p * (n && l ? -1 : 1);
      break;
    case "end":
      f[a] += p * (n && l ? -1 : 1);
      break;
  }
  return f;
}
const s8 = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: a
  } = n, s = o.filter(Boolean), c = await (a.isRTL == null ? void 0 : a.isRTL(t));
  let l = await a.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: u,
    y: d
  } = nb(l, r, c), p = r, f = {}, h = 0;
  for (let m = 0; m < s.length; m++) {
    const {
      name: y,
      fn: g
    } = s[m], {
      x: v,
      y: b,
      data: _,
      reset: S
    } = await g({
      x: u,
      y: d,
      initialPlacement: r,
      placement: p,
      strategy: i,
      middlewareData: f,
      rects: l,
      platform: a,
      elements: {
        reference: e,
        floating: t
      }
    });
    if (u = v ?? u, d = b ?? d, f = {
      ...f,
      [y]: {
        ...f[y],
        ..._
      }
    }, S && h <= 50) {
      h++, typeof S == "object" && (S.placement && (p = S.placement), S.rects && (l = S.rects === !0 ? await a.getElementRects({
        reference: e,
        floating: t,
        strategy: i
      }) : S.rects), {
        x: u,
        y: d
      } = nb(l, p, c)), m = -1;
      continue;
    }
  }
  return {
    x: u,
    y: d,
    placement: p,
    strategy: i,
    middlewareData: f
  };
};
async function $E(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: o,
    rects: a,
    elements: s,
    strategy: c
  } = e, {
    boundary: l = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: p = !1,
    padding: f = 0
  } = Hd(t, e), h = Q9(f), y = s[p ? d === "floating" ? "reference" : "floating" : d], g = $u(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(y))) == null || n ? y : y.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(s.floating)),
    boundary: l,
    rootBoundary: u,
    strategy: c
  })), v = d === "floating" ? {
    ...a.floating,
    x: r,
    y: i
  } : a.reference, b = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(s.floating)), _ = await (o.isElement == null ? void 0 : o.isElement(b)) ? await (o.getScale == null ? void 0 : o.getScale(b)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = $u(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: v,
    offsetParent: b,
    strategy: c
  }) : v);
  return {
    top: (g.top - S.top + h.top) / _.y,
    bottom: (S.bottom - g.bottom + h.bottom) / _.y,
    left: (g.left - S.left + h.left) / _.x,
    right: (S.right - g.right + h.right) / _.x
  };
}
async function c8(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), a = dc(n), s = iy(n), c = fc(n) === "y", l = ["left", "top"].includes(a) ? -1 : 1, u = o && c ? -1 : 1, d = Hd(t, e);
  let {
    mainAxis: p,
    crossAxis: f,
    alignmentAxis: h
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return s && typeof h == "number" && (f = s === "end" ? h * -1 : h), c ? {
    x: f * u,
    y: p * l
  } : {
    x: p * l,
    y: f * u
  };
}
const l8 = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r
      } = t, i = await c8(t, e);
      return {
        x: n + i.x,
        y: r + i.y,
        data: i
      };
    }
  };
}, u8 = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i
      } = t, {
        mainAxis: o = !0,
        crossAxis: a = !1,
        limiter: s = {
          fn: (y) => {
            let {
              x: g,
              y: v
            } = y;
            return {
              x: g,
              y: v
            };
          }
        },
        ...c
      } = Hd(e, t), l = {
        x: n,
        y: r
      }, u = await $E(t, c), d = fc(dc(i)), p = kE(d);
      let f = l[p], h = l[d];
      if (o) {
        const y = p === "y" ? "top" : "left", g = p === "y" ? "bottom" : "right", v = f + u[y], b = f - u[g];
        f = eb(v, f, b);
      }
      if (a) {
        const y = d === "y" ? "top" : "left", g = d === "y" ? "bottom" : "right", v = h + u[y], b = h - u[g];
        h = eb(v, h, b);
      }
      const m = s.fn({
        ...t,
        [p]: f,
        [d]: h
      });
      return {
        ...m,
        data: {
          x: m.x - n,
          y: m.y - r
        }
      };
    }
  };
}, d8 = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      const {
        placement: n,
        rects: r,
        platform: i,
        elements: o
      } = t, {
        apply: a = () => {
        },
        ...s
      } = Hd(e, t), c = await $E(t, s), l = dc(n), u = iy(n), d = fc(n) === "y", {
        width: p,
        height: f
      } = r.floating;
      let h, m;
      l === "top" || l === "bottom" ? (h = l, m = u === (await (i.isRTL == null ? void 0 : i.isRTL(o.floating)) ? "start" : "end") ? "left" : "right") : (m = l, h = u === "end" ? "top" : "bottom");
      const y = f - c[h], g = p - c[m], v = !t.middlewareData.shift;
      let b = y, _ = g;
      if (d) {
        const x = p - c.left - c.right;
        _ = u || v ? Ta(g, x) : x;
      } else {
        const x = f - c.top - c.bottom;
        b = u || v ? Ta(y, x) : x;
      }
      if (v && !u) {
        const x = or(c.left, 0), A = or(c.right, 0), I = or(c.top, 0), P = or(c.bottom, 0);
        d ? _ = p - 2 * (x !== 0 || A !== 0 ? x + A : or(c.left, c.right)) : b = f - 2 * (I !== 0 || P !== 0 ? I + P : or(c.top, c.bottom));
      }
      await a({
        ...t,
        availableWidth: _,
        availableHeight: b
      });
      const S = await i.getDimensions(o.floating);
      return p !== S.width || f !== S.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function DE(e) {
  const t = lr(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = Ln(e), o = i ? e.offsetWidth : n, a = i ? e.offsetHeight : r, s = Pu(n) !== o || Pu(r) !== a;
  return s && (n = o, r = a), {
    width: n,
    height: r,
    $: s
  };
}
function sy(e) {
  return en(e) ? e : e.contextElement;
}
function oa(e) {
  const t = sy(e);
  if (!Ln(t))
    return zi(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: o
  } = DE(t);
  let a = (o ? Pu(n.width) : n.width) / r, s = (o ? Pu(n.height) : n.height) / i;
  return (!a || !Number.isFinite(a)) && (a = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: a,
    y: s
  };
}
const f8 = /* @__PURE__ */ zi(0);
function NE(e) {
  const t = cr(e);
  return !ay() || !t.visualViewport ? f8 : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function p8(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== cr(e) ? !1 : t;
}
function To(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), o = sy(e);
  let a = zi(1);
  t && (r ? en(r) && (a = oa(r)) : a = oa(e));
  const s = p8(o, n, r) ? NE(o) : zi(0);
  let c = (i.left + s.x) / a.x, l = (i.top + s.y) / a.y, u = i.width / a.x, d = i.height / a.y;
  if (o) {
    const p = cr(o), f = r && en(r) ? cr(r) : r;
    let h = p.frameElement;
    for (; h && r && f !== p; ) {
      const m = oa(h), y = h.getBoundingClientRect(), g = lr(h), v = y.left + (h.clientLeft + parseFloat(g.paddingLeft)) * m.x, b = y.top + (h.clientTop + parseFloat(g.paddingTop)) * m.y;
      c *= m.x, l *= m.y, u *= m.x, d *= m.y, c += v, l += b, h = cr(h).frameElement;
    }
  }
  return $u({
    width: u,
    height: d,
    x: c,
    y: l
  });
}
function h8(e) {
  let {
    rect: t,
    offsetParent: n,
    strategy: r
  } = e;
  const i = Ln(n), o = vi(n);
  if (n === o)
    return t;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, s = zi(1);
  const c = zi(0);
  if ((i || !i && r !== "fixed") && ((Zi(n) !== "body" || pc(o)) && (a = Wd(n)), Ln(n))) {
    const l = To(n);
    s = oa(n), c.x = l.x + n.clientLeft, c.y = l.y + n.clientTop;
  }
  return {
    width: t.width * s.x,
    height: t.height * s.y,
    x: t.x * s.x - a.scrollLeft * s.x + c.x,
    y: t.y * s.y - a.scrollTop * s.y + c.y
  };
}
function m8(e) {
  return Array.from(e.getClientRects());
}
function jE(e) {
  return To(vi(e)).left + Wd(e).scrollLeft;
}
function y8(e) {
  const t = vi(e), n = Wd(e), r = e.ownerDocument.body, i = or(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = or(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let a = -n.scrollLeft + jE(e);
  const s = -n.scrollTop;
  return lr(r).direction === "rtl" && (a += or(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: o,
    x: a,
    y: s
  };
}
function g8(e, t) {
  const n = cr(e), r = vi(e), i = n.visualViewport;
  let o = r.clientWidth, a = r.clientHeight, s = 0, c = 0;
  if (i) {
    o = i.width, a = i.height;
    const l = ay();
    (!l || l && t === "fixed") && (s = i.offsetLeft, c = i.offsetTop);
  }
  return {
    width: o,
    height: a,
    x: s,
    y: c
  };
}
function v8(e, t) {
  const n = To(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = Ln(e) ? oa(e) : zi(1), a = e.clientWidth * o.x, s = e.clientHeight * o.y, c = i * o.x, l = r * o.y;
  return {
    width: a,
    height: s,
    x: c,
    y: l
  };
}
function rb(e, t, n) {
  let r;
  if (t === "viewport")
    r = g8(e, n);
  else if (t === "document")
    r = y8(vi(e));
  else if (en(t))
    r = v8(t, n);
  else {
    const i = NE(e);
    r = {
      ...t,
      x: t.x - i.x,
      y: t.y - i.y
    };
  }
  return $u(r);
}
function ME(e, t) {
  const n = Co(e);
  return n === t || !en(n) || hc(n) ? !1 : lr(n).position === "fixed" || ME(n, t);
}
function b8(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Di(e, [], !1).filter((s) => en(s) && Zi(s) !== "body"), i = null;
  const o = lr(e).position === "fixed";
  let a = o ? Co(e) : e;
  for (; en(a) && !hc(a); ) {
    const s = lr(a), c = oy(a);
    !c && s.position === "fixed" && (i = null), (o ? !c && !i : !c && s.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || pc(a) && !c && ME(e, a)) ? r = r.filter((u) => u !== a) : i = s, a = Co(a);
  }
  return t.set(e, r), r;
}
function w8(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const a = [...n === "clippingAncestors" ? b8(t, this._c) : [].concat(n), r], s = a[0], c = a.reduce((l, u) => {
    const d = rb(t, u, i);
    return l.top = or(d.top, l.top), l.right = Ta(d.right, l.right), l.bottom = Ta(d.bottom, l.bottom), l.left = or(d.left, l.left), l;
  }, rb(t, s, i));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function x8(e) {
  return DE(e);
}
function _8(e, t, n) {
  const r = Ln(t), i = vi(t), o = n === "fixed", a = To(e, !0, o, t);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = zi(0);
  if (r || !r && !o)
    if ((Zi(t) !== "body" || pc(i)) && (s = Wd(t)), r) {
      const l = To(t, !0, o, t);
      c.x = l.x + t.clientLeft, c.y = l.y + t.clientTop;
    } else
      i && (c.x = jE(i));
  return {
    x: a.left + s.scrollLeft - c.x,
    y: a.top + s.scrollTop - c.y,
    width: a.width,
    height: a.height
  };
}
function ib(e, t) {
  return !Ln(e) || lr(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function qE(e, t) {
  const n = cr(e);
  if (!Ln(e))
    return n;
  let r = ib(e, t);
  for (; r && e8(r) && lr(r).position === "static"; )
    r = ib(r, t);
  return r && (Zi(r) === "html" || Zi(r) === "body" && lr(r).position === "static" && !oy(r)) ? n : r || t8(e) || n;
}
const S8 = async function(e) {
  let {
    reference: t,
    floating: n,
    strategy: r
  } = e;
  const i = this.getOffsetParent || qE, o = this.getDimensions;
  return {
    reference: _8(t, await i(n), r),
    floating: {
      x: 0,
      y: 0,
      ...await o(n)
    }
  };
};
function k8(e) {
  return lr(e).direction === "rtl";
}
const E8 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: h8,
  getDocumentElement: vi,
  getClippingRect: w8,
  getOffsetParent: qE,
  getElementRects: S8,
  getClientRects: m8,
  getDimensions: x8,
  getScale: oa,
  isElement: en,
  isRTL: k8
};
function C8(e, t) {
  let n = null, r;
  const i = vi(e);
  function o() {
    clearTimeout(r), n && n.disconnect(), n = null;
  }
  function a(s, c) {
    s === void 0 && (s = !1), c === void 0 && (c = 1), o();
    const {
      left: l,
      top: u,
      width: d,
      height: p
    } = e.getBoundingClientRect();
    if (s || t(), !d || !p)
      return;
    const f = Yo(u), h = Yo(i.clientWidth - (l + d)), m = Yo(i.clientHeight - (u + p)), y = Yo(l), v = {
      rootMargin: -f + "px " + -h + "px " + -m + "px " + -y + "px",
      threshold: or(0, Ta(1, c)) || 1
    };
    let b = !0;
    function _(S) {
      const x = S[0].intersectionRatio;
      if (x !== c) {
        if (!b)
          return a();
        x ? a(!1, x) : r = setTimeout(() => {
          a(!1, 1e-7);
        }, 100);
      }
      b = !1;
    }
    try {
      n = new IntersectionObserver(_, {
        ...v,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(_, v);
    }
    n.observe(e);
  }
  return a(!0), o;
}
function T8(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: a = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, l = sy(e), u = i || o ? [...l ? Di(l) : [], ...Di(t)] : [];
  u.forEach((g) => {
    i && g.addEventListener("scroll", n, {
      passive: !0
    }), o && g.addEventListener("resize", n);
  });
  const d = l && s ? C8(l, n) : null;
  let p = -1, f = null;
  a && (f = new ResizeObserver((g) => {
    let [v] = g;
    v && v.target === l && f && (f.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      f && f.observe(t);
    })), n();
  }), l && !c && f.observe(l), f.observe(t));
  let h, m = c ? To(e) : null;
  c && y();
  function y() {
    const g = To(e);
    m && (g.x !== m.x || g.y !== m.y || g.width !== m.width || g.height !== m.height) && n(), m = g, h = requestAnimationFrame(y);
  }
  return n(), () => {
    u.forEach((g) => {
      i && g.removeEventListener("scroll", n), o && g.removeEventListener("resize", n);
    }), d && d(), f && f.disconnect(), f = null, c && cancelAnimationFrame(h);
  };
}
const R8 = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: E8,
    ...n
  }, o = {
    ...i.platform,
    _c: r
  };
  return s8(e, t, {
    ...i,
    platform: o
  });
};
var ul = typeof document < "u" ? Ls : Ne;
function Du(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (r = n; r-- !== 0; )
        if (!Du(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (!(o === "_owner" && e.$$typeof) && !Du(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function LE(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function ob(e, t) {
  const n = LE(e);
  return Math.round(t * n) / n;
}
function ab(e) {
  const t = D.useRef(e);
  return ul(() => {
    t.current = e;
  }), t;
}
function A8(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: o,
      floating: a
    } = {},
    transform: s = !0,
    whileElementsMounted: c,
    open: l
  } = e, [u, d] = D.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [p, f] = D.useState(r);
  Du(p, r) || f(r);
  const [h, m] = D.useState(null), [y, g] = D.useState(null), v = D.useCallback((j) => {
    j != x.current && (x.current = j, m(j));
  }, [m]), b = D.useCallback((j) => {
    j !== A.current && (A.current = j, g(j));
  }, [g]), _ = o || h, S = a || y, x = D.useRef(null), A = D.useRef(null), I = D.useRef(u), P = ab(c), R = ab(i), M = D.useCallback(() => {
    if (!x.current || !A.current)
      return;
    const j = {
      placement: t,
      strategy: n,
      middleware: p
    };
    R.current && (j.platform = R.current), R8(x.current, A.current, j).then((z) => {
      const H = {
        ...z,
        isPositioned: !0
      };
      V.current && !Du(I.current, H) && (I.current = H, WC.flushSync(() => {
        d(H);
      }));
    });
  }, [p, t, n, R]);
  ul(() => {
    l === !1 && I.current.isPositioned && (I.current.isPositioned = !1, d((j) => ({
      ...j,
      isPositioned: !1
    })));
  }, [l]);
  const V = D.useRef(!1);
  ul(() => (V.current = !0, () => {
    V.current = !1;
  }), []), ul(() => {
    if (_ && (x.current = _), S && (A.current = S), _ && S) {
      if (P.current)
        return P.current(_, S, M);
      M();
    }
  }, [_, S, M, P]);
  const U = D.useMemo(() => ({
    reference: x,
    floating: A,
    setReference: v,
    setFloating: b
  }), [v, b]), L = D.useMemo(() => ({
    reference: _,
    floating: S
  }), [_, S]), $ = D.useMemo(() => {
    const j = {
      position: n,
      left: 0,
      top: 0
    };
    if (!L.floating)
      return j;
    const z = ob(L.floating, u.x), H = ob(L.floating, u.y);
    return s ? {
      ...j,
      transform: "translate(" + z + "px, " + H + "px)",
      ...LE(L.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: z,
      top: H
    };
  }, [n, s, L.floating, u.x, u.y]);
  return D.useMemo(() => ({
    ...u,
    update: M,
    refs: U,
    elements: L,
    floatingStyles: $
  }), [u, M, U, L, $]);
}
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var O8 = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], fh = /* @__PURE__ */ O8.join(","), FE = typeof Element > "u", js = FE ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, Nu = !FE && Element.prototype.getRootNode ? function(e) {
  var t;
  return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
} : function(e) {
  return e == null ? void 0 : e.ownerDocument;
}, ju = function e(t, n) {
  var r;
  n === void 0 && (n = !0);
  var i = t == null || (r = t.getAttribute) === null || r === void 0 ? void 0 : r.call(t, "inert"), o = i === "" || i === "true", a = o || n && t && e(t.parentNode);
  return a;
}, I8 = function(t) {
  var n, r = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "contenteditable");
  return r === "" || r === "true";
}, P8 = function(t, n, r) {
  if (ju(t))
    return [];
  var i = Array.prototype.slice.apply(t.querySelectorAll(fh));
  return n && js.call(t, fh) && i.unshift(t), i = i.filter(r), i;
}, $8 = function e(t, n, r) {
  for (var i = [], o = Array.from(t); o.length; ) {
    var a = o.shift();
    if (!ju(a, !1))
      if (a.tagName === "SLOT") {
        var s = a.assignedElements(), c = s.length ? s : a.children, l = e(c, !0, r);
        r.flatten ? i.push.apply(i, l) : i.push({
          scopeParent: a,
          candidates: l
        });
      } else {
        var u = js.call(a, fh);
        u && r.filter(a) && (n || !t.includes(a)) && i.push(a);
        var d = a.shadowRoot || // check for an undisclosed shadow
        typeof r.getShadowRoot == "function" && r.getShadowRoot(a), p = !ju(d, !1) && (!r.shadowRootFilter || r.shadowRootFilter(a));
        if (d && p) {
          var f = e(d === !0 ? a.children : d.children, !0, r);
          r.flatten ? i.push.apply(i, f) : i.push({
            scopeParent: a,
            candidates: f
          });
        } else
          o.unshift.apply(o, a.children);
      }
  }
  return i;
}, UE = function(t) {
  return !isNaN(parseInt(t.getAttribute("tabindex"), 10));
}, BE = function(t) {
  if (!t)
    throw new Error("No node provided");
  return t.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || I8(t)) && !UE(t) ? 0 : t.tabIndex;
}, D8 = function(t, n) {
  var r = BE(t);
  return r < 0 && n && !UE(t) ? 0 : r;
}, N8 = function(t, n) {
  return t.tabIndex === n.tabIndex ? t.documentOrder - n.documentOrder : t.tabIndex - n.tabIndex;
}, zE = function(t) {
  return t.tagName === "INPUT";
}, j8 = function(t) {
  return zE(t) && t.type === "hidden";
}, M8 = function(t) {
  var n = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function(r) {
    return r.tagName === "SUMMARY";
  });
  return n;
}, q8 = function(t, n) {
  for (var r = 0; r < t.length; r++)
    if (t[r].checked && t[r].form === n)
      return t[r];
}, L8 = function(t) {
  if (!t.name)
    return !0;
  var n = t.form || Nu(t), r = function(s) {
    return n.querySelectorAll('input[type="radio"][name="' + s + '"]');
  }, i;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    i = r(window.CSS.escape(t.name));
  else
    try {
      i = r(t.name);
    } catch (a) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", a.message), !1;
    }
  var o = q8(i, t.form);
  return !o || o === t;
}, F8 = function(t) {
  return zE(t) && t.type === "radio";
}, U8 = function(t) {
  return F8(t) && !L8(t);
}, B8 = function(t) {
  var n, r = t && Nu(t), i = (n = r) === null || n === void 0 ? void 0 : n.host, o = !1;
  if (r && r !== t) {
    var a, s, c;
    for (o = !!((a = i) !== null && a !== void 0 && (s = a.ownerDocument) !== null && s !== void 0 && s.contains(i) || t != null && (c = t.ownerDocument) !== null && c !== void 0 && c.contains(t)); !o && i; ) {
      var l, u, d;
      r = Nu(i), i = (l = r) === null || l === void 0 ? void 0 : l.host, o = !!((u = i) !== null && u !== void 0 && (d = u.ownerDocument) !== null && d !== void 0 && d.contains(i));
    }
  }
  return o;
}, sb = function(t) {
  var n = t.getBoundingClientRect(), r = n.width, i = n.height;
  return r === 0 && i === 0;
}, z8 = function(t, n) {
  var r = n.displayCheck, i = n.getShadowRoot;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  var o = js.call(t, "details>summary:first-of-type"), a = o ? t.parentElement : t;
  if (js.call(a, "details:not([open]) *"))
    return !0;
  if (!r || r === "full" || r === "legacy-full") {
    if (typeof i == "function") {
      for (var s = t; t; ) {
        var c = t.parentElement, l = Nu(t);
        if (c && !c.shadowRoot && i(c) === !0)
          return sb(t);
        t.assignedSlot ? t = t.assignedSlot : !c && l !== t.ownerDocument ? t = l.host : t = c;
      }
      t = s;
    }
    if (B8(t))
      return !t.getClientRects().length;
    if (r !== "legacy-full")
      return !0;
  } else if (r === "non-zero-area")
    return sb(t);
  return !1;
}, Z8 = function(t) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
    for (var n = t.parentElement; n; ) {
      if (n.tagName === "FIELDSET" && n.disabled) {
        for (var r = 0; r < n.children.length; r++) {
          var i = n.children.item(r);
          if (i.tagName === "LEGEND")
            return js.call(n, "fieldset[disabled] *") ? !0 : !i.contains(t);
        }
        return !0;
      }
      n = n.parentElement;
    }
  return !1;
}, V8 = function(t, n) {
  return !(n.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  ju(n) || j8(n) || z8(n, t) || // For a details element with a summary, the summary element gets the focus
  M8(n) || Z8(n));
}, cb = function(t, n) {
  return !(U8(n) || BE(n) < 0 || !V8(t, n));
}, H8 = function(t) {
  var n = parseInt(t.getAttribute("tabindex"), 10);
  return !!(isNaN(n) || n >= 0);
}, W8 = function e(t) {
  var n = [], r = [];
  return t.forEach(function(i, o) {
    var a = !!i.scopeParent, s = a ? i.scopeParent : i, c = D8(s, a), l = a ? e(i.candidates) : s;
    c === 0 ? a ? n.push.apply(n, l) : n.push(s) : r.push({
      documentOrder: o,
      tabIndex: c,
      item: i,
      isScope: a,
      content: l
    });
  }), r.sort(N8).reduce(function(i, o) {
    return o.isScope ? i.push.apply(i, o.content) : i.push(o.content), i;
  }, []).concat(n);
}, cy = function(t, n) {
  n = n || {};
  var r;
  return n.getShadowRoot ? r = $8([t], n.includeContainer, {
    filter: cb.bind(null, n),
    flatten: !1,
    getShadowRoot: n.getShadowRoot,
    shadowRootFilter: H8
  }) : r = P8(t, n.includeContainer, cb.bind(null, n)), W8(r);
};
const ly = "ArrowUp", Kd = "ArrowDown", Ra = "ArrowLeft", mc = "ArrowRight";
function Nc(e, t, n) {
  return Math.floor(e / t) !== n;
}
function ls(e, t) {
  return t < 0 || t >= e.current.length;
}
function Wf(e, t) {
  return Pn(e, {
    disabledIndices: t
  });
}
function lb(e, t) {
  return Pn(e, {
    decrement: !0,
    startingIndex: e.current.length,
    disabledIndices: t
  });
}
function Pn(e, t) {
  let {
    startingIndex: n = -1,
    decrement: r = !1,
    disabledIndices: i,
    amount: o = 1
  } = t === void 0 ? {} : t;
  const a = e.current;
  let s = n;
  do {
    var c, l;
    s = s + (r ? -o : o);
  } while (s >= 0 && s <= a.length - 1 && (i ? i.includes(s) : a[s] == null || (c = a[s]) != null && c.hasAttribute("disabled") || ((l = a[s]) == null ? void 0 : l.getAttribute("aria-disabled")) === "true"));
  return s;
}
function K8(e, t) {
  let {
    event: n,
    orientation: r,
    loop: i,
    cols: o,
    disabledIndices: a,
    minIndex: s,
    maxIndex: c,
    prevIndex: l,
    stopEvent: u = !1
  } = t, d = l;
  if (n.key === ly) {
    if (u && Cn(n), l === -1)
      d = c;
    else if (d = Pn(e, {
      startingIndex: d,
      amount: o,
      decrement: !0,
      disabledIndices: a
    }), i && (l - o < s || d < 0)) {
      const p = l % o, f = c % o, h = c - (f - p);
      f === p ? d = c : d = f > p ? h : h - o;
    }
    ls(e, d) && (d = l);
  }
  if (n.key === Kd && (u && Cn(n), l === -1 ? d = s : (d = Pn(e, {
    startingIndex: l,
    amount: o,
    disabledIndices: a
  }), i && l + o > c && (d = Pn(e, {
    startingIndex: l % o - o,
    amount: o,
    disabledIndices: a
  }))), ls(e, d) && (d = l)), r === "both") {
    const p = Yo(l / o);
    n.key === mc && (u && Cn(n), l % o !== o - 1 ? (d = Pn(e, {
      startingIndex: l,
      disabledIndices: a
    }), i && Nc(d, o, p) && (d = Pn(e, {
      startingIndex: l - l % o - 1,
      disabledIndices: a
    }))) : i && (d = Pn(e, {
      startingIndex: l - l % o - 1,
      disabledIndices: a
    })), Nc(d, o, p) && (d = l)), n.key === Ra && (u && Cn(n), l % o !== 0 ? (d = Pn(e, {
      startingIndex: l,
      disabledIndices: a,
      decrement: !0
    }), i && Nc(d, o, p) && (d = Pn(e, {
      startingIndex: l + (o - l % o),
      decrement: !0,
      disabledIndices: a
    }))) : i && (d = Pn(e, {
      startingIndex: l + (o - l % o),
      decrement: !0,
      disabledIndices: a
    })), Nc(d, o, p) && (d = l));
    const f = Yo(c / o) === p;
    ls(e, d) && (i && f ? d = n.key === Ra ? c : Pn(e, {
      startingIndex: l - l % o - 1,
      disabledIndices: a
    }) : d = l);
  }
  return d;
}
let ub = 0;
function ni(e, t) {
  t === void 0 && (t = {});
  const {
    preventScroll: n = !1,
    cancelPrevious: r = !0,
    sync: i = !1
  } = t;
  r && cancelAnimationFrame(ub);
  const o = () => e == null ? void 0 : e.focus({
    preventScroll: n
  });
  i ? o() : ub = requestAnimationFrame(o);
}
var fn = typeof document < "u" ? Ls : Ne;
function Mu() {
  return Mu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Mu.apply(this, arguments);
}
let Kf = !1, J8 = 0;
const db = () => "floating-ui-" + J8++;
function Y8() {
  const [e, t] = D.useState(() => Kf ? db() : void 0);
  return fn(() => {
    e == null && t(db());
  }, []), D.useEffect(() => {
    Kf || (Kf = !0);
  }, []), e;
}
const G8 = D[/* @__PURE__ */ "useId".toString()], uy = G8 || Y8;
function X8() {
  const e = /* @__PURE__ */ new Map();
  return {
    emit(t, n) {
      var r;
      (r = e.get(t)) == null || r.forEach((i) => i(n));
    },
    on(t, n) {
      e.set(t, [...e.get(t) || [], n]);
    },
    off(t, n) {
      var r;
      e.set(t, ((r = e.get(t)) == null ? void 0 : r.filter((i) => i !== n)) || []);
    }
  };
}
const Q8 = /* @__PURE__ */ D.createContext(null), eV = /* @__PURE__ */ D.createContext(null), ZE = () => {
  var e;
  return ((e = D.useContext(Q8)) == null ? void 0 : e.id) || null;
}, Jd = () => D.useContext(eV);
function Ms(e) {
  return "data-floating-ui-" + e;
}
function Ni(e) {
  const t = Ke(e);
  return fn(() => {
    t.current = e;
  }), t;
}
function tV(e, t) {
  var n;
  let r = [], i = (n = e.find((o) => o.id === t)) == null ? void 0 : n.parentId;
  for (; i; ) {
    const o = e.find((a) => a.id === i);
    i = o == null ? void 0 : o.parentId, o && (r = r.concat(o));
  }
  return r;
}
function aa(e, t) {
  let n = e.filter((i) => {
    var o;
    return i.parentId === t && ((o = i.context) == null ? void 0 : o.open);
  }), r = n;
  for (; r.length; )
    r = e.filter((i) => {
      var o;
      return (o = r) == null ? void 0 : o.some((a) => {
        var s;
        return i.parentId === a.id && ((s = i.context) == null ? void 0 : s.open);
      });
    }), n = n.concat(r);
  return n;
}
function nV(e, t) {
  let n, r = -1;
  function i(o, a) {
    a > r && (n = o, r = a), aa(e, o).forEach((c) => {
      i(c.id, a + 1);
    });
  }
  return i(t, 0), e.find((o) => o.id === n);
}
let qo = /* @__PURE__ */ new WeakMap(), jc = /* @__PURE__ */ new WeakSet(), Mc = {}, Jf = 0;
const rV = () => typeof HTMLElement < "u" && "inert" in HTMLElement.prototype, VE = (e) => e && (e.host || VE(e.parentNode)), iV = (e, t) => t.map((n) => {
  if (e.contains(n))
    return n;
  const r = VE(n);
  return e.contains(r) ? r : null;
}).filter((n) => n != null);
function oV(e, t, n, r) {
  const i = "data-floating-ui-inert", o = r ? "inert" : n ? "aria-hidden" : null, a = iV(t, e), s = /* @__PURE__ */ new Set(), c = new Set(a), l = [];
  Mc[i] || (Mc[i] = /* @__PURE__ */ new WeakMap());
  const u = Mc[i];
  a.forEach(d), p(t), s.clear();
  function d(f) {
    !f || s.has(f) || (s.add(f), f.parentNode && d(f.parentNode));
  }
  function p(f) {
    !f || c.has(f) || Array.prototype.forEach.call(f.children, (h) => {
      if (s.has(h))
        p(h);
      else {
        const m = o ? h.getAttribute(o) : null, y = m !== null && m !== "false", g = (qo.get(h) || 0) + 1, v = (u.get(h) || 0) + 1;
        qo.set(h, g), u.set(h, v), l.push(h), g === 1 && y && jc.add(h), v === 1 && h.setAttribute(i, ""), !y && o && h.setAttribute(o, "true");
      }
    });
  }
  return Jf++, () => {
    l.forEach((f) => {
      const h = (qo.get(f) || 0) - 1, m = (u.get(f) || 0) - 1;
      qo.set(f, h), u.set(f, m), h || (!jc.has(f) && o && f.removeAttribute(o), jc.delete(f)), m || f.removeAttribute(i);
    }), Jf--, Jf || (qo = /* @__PURE__ */ new WeakMap(), qo = /* @__PURE__ */ new WeakMap(), jc = /* @__PURE__ */ new WeakSet(), Mc = {});
  };
}
function fb(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = _r(e[0]).body;
  return oV(e.concat(Array.from(r.querySelectorAll("[aria-live]"))), r, t, n);
}
const dy = () => ({
  getShadowRoot: !0,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function HE(e, t) {
  const n = cy(e, dy());
  t === "prev" && n.reverse();
  const r = n.indexOf(Oi(_r(e)));
  return n.slice(r + 1)[0];
}
function WE() {
  return HE(document.body, "next");
}
function KE() {
  return HE(document.body, "prev");
}
function us(e, t) {
  const n = t || e.currentTarget, r = e.relatedTarget;
  return !r || !Xn(n, r);
}
function aV(e) {
  cy(e, dy()).forEach((n) => {
    n.dataset.tabindex = n.getAttribute("tabindex") || "", n.setAttribute("tabindex", "-1");
  });
}
function sV(e) {
  e.querySelectorAll("[data-tabindex]").forEach((n) => {
    const r = n.dataset.tabindex;
    delete n.dataset.tabindex, r ? n.setAttribute("tabindex", r) : n.removeAttribute("tabindex");
  });
}
const fy = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
let cV;
function pb(e) {
  e.key === "Tab" && (e.target, clearTimeout(cV));
}
const qu = /* @__PURE__ */ D.forwardRef(function(t, n) {
  const [r, i] = D.useState();
  fn(() => (OE() && i("button"), document.addEventListener("keydown", pb), () => {
    document.removeEventListener("keydown", pb);
  }), []);
  const o = {
    ref: n,
    tabIndex: 0,
    // Role is only for VoiceOver
    role: r,
    "aria-hidden": r ? void 0 : !0,
    [Ms("focus-guard")]: "",
    style: fy
  };
  return /* @__PURE__ */ D.createElement("span", Mu({}, t, o));
}), JE = /* @__PURE__ */ D.createContext(null);
function lV(e) {
  let {
    id: t,
    root: n
  } = e === void 0 ? {} : e;
  const [r, i] = D.useState(null), o = uy(), a = YE(), s = D.useMemo(() => ({
    id: t,
    root: n,
    portalContext: a,
    uniqueId: o
  }), [t, n, a, o]), c = D.useRef();
  return fn(() => () => {
    r == null || r.remove();
  }, [r, s]), fn(() => {
    if (c.current === s)
      return;
    c.current = s;
    const {
      id: l,
      root: u,
      portalContext: d,
      uniqueId: p
    } = s, f = l ? document.getElementById(l) : null, h = Ms("portal");
    if (f) {
      const m = document.createElement("div");
      m.id = p, m.setAttribute(h, ""), f.appendChild(m), i(m);
    } else {
      let m = u || (d == null ? void 0 : d.portalNode);
      m && !en(m) && (m = m.current), m = m || document.body;
      let y = null;
      l && (y = document.createElement("div"), y.id = l, m.appendChild(y));
      const g = document.createElement("div");
      g.id = p, g.setAttribute(h, ""), m = y || m, m.appendChild(g), i(g);
    }
  }, [s]), r;
}
function uV(e) {
  let {
    children: t,
    id: n,
    root: r = null,
    preserveTabOrder: i = !0
  } = e;
  const o = lV({
    id: n,
    root: r
  }), [a, s] = D.useState(null), c = D.useRef(null), l = D.useRef(null), u = D.useRef(null), d = D.useRef(null), p = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!a && // Guards are only for non-modal focus management.
    !a.modal && // Don't render if unmount is transitioning.
    a.open && i && !!(r || o)
  );
  return D.useEffect(() => {
    if (!o || !i || a != null && a.modal)
      return;
    function f(h) {
      o && us(h) && (h.type === "focusin" ? sV : aV)(o);
    }
    return o.addEventListener("focusin", f, !0), o.addEventListener("focusout", f, !0), () => {
      o.removeEventListener("focusin", f, !0), o.removeEventListener("focusout", f, !0);
    };
  }, [o, i, a == null ? void 0 : a.modal]), /* @__PURE__ */ D.createElement(JE.Provider, {
    value: D.useMemo(() => ({
      preserveTabOrder: i,
      beforeOutsideRef: c,
      afterOutsideRef: l,
      beforeInsideRef: u,
      afterInsideRef: d,
      portalNode: o,
      setFocusManagerState: s
    }), [i, o])
  }, p && o && /* @__PURE__ */ D.createElement(qu, {
    "data-type": "outside",
    ref: c,
    onFocus: (f) => {
      if (us(f, o)) {
        var h;
        (h = u.current) == null || h.focus();
      } else {
        const m = KE() || (a == null ? void 0 : a.refs.domReference.current);
        m == null || m.focus();
      }
    }
  }), p && o && /* @__PURE__ */ D.createElement("span", {
    "aria-owns": o.id,
    style: fy
  }), o && /* @__PURE__ */ KC(t, o), p && o && /* @__PURE__ */ D.createElement(qu, {
    "data-type": "outside",
    ref: l,
    onFocus: (f) => {
      if (us(f, o)) {
        var h;
        (h = d.current) == null || h.focus();
      } else {
        const m = WE() || (a == null ? void 0 : a.refs.domReference.current);
        m == null || m.focus(), a != null && a.closeOnFocusOut && (a == null || a.onOpenChange(!1, f.nativeEvent));
      }
    }
  }));
}
const YE = () => D.useContext(JE), dV = /* @__PURE__ */ D.forwardRef(function(t, n) {
  return /* @__PURE__ */ D.createElement("button", Mu({}, t, {
    type: "button",
    ref: n,
    tabIndex: -1,
    style: fy
  }));
});
function fV(e) {
  const {
    context: t,
    children: n,
    disabled: r = !1,
    order: i = ["content"],
    guards: o = !0,
    initialFocus: a = 0,
    returnFocus: s = !0,
    modal: c = !0,
    visuallyHiddenDismiss: l = !1,
    closeOnFocusOut: u = !0
  } = e, {
    open: d,
    refs: p,
    nodeId: f,
    onOpenChange: h,
    events: m,
    dataRef: y,
    elements: {
      domReference: g,
      floating: v
    }
  } = t, b = rV() ? o : !0, _ = Ni(i), S = Ni(a), x = Ni(s), A = Jd(), I = YE(), P = typeof a == "number" && a < 0, R = D.useRef(null), M = D.useRef(null), V = D.useRef(!1), U = D.useRef(null), L = D.useRef(!1), $ = I != null, j = g && g.getAttribute("role") === "combobox" && PE(g) && P, z = D.useCallback(function(ee) {
    return ee === void 0 && (ee = v), ee ? cy(ee, dy()) : [];
  }, [v]), H = D.useCallback((ee) => {
    const de = z(ee);
    return _.current.map((T) => g && T === "reference" ? g : v && T === "floating" ? v : de).filter(Boolean).flat();
  }, [g, v, _, z]);
  D.useEffect(() => {
    if (r || !c)
      return;
    function ee(T) {
      if (T.key === "Tab") {
        Xn(v, Oi(_r(v))) && z().length === 0 && !j && Cn(T);
        const be = H(), ke = IE(T);
        _.current[0] === "reference" && ke === g && (Cn(T), T.shiftKey ? ni(be[be.length - 1]) : ni(be[1])), _.current[1] === "floating" && ke === v && T.shiftKey && (Cn(T), ni(be[0]));
      }
    }
    const de = _r(v);
    return de.addEventListener("keydown", ee), () => {
      de.removeEventListener("keydown", ee);
    };
  }, [r, g, v, c, _, p, j, z, H]), D.useEffect(() => {
    if (r || !u)
      return;
    function ee() {
      L.current = !0, setTimeout(() => {
        L.current = !1;
      });
    }
    function de(T) {
      const be = T.relatedTarget;
      queueMicrotask(() => {
        const ke = !(Xn(g, be) || Xn(v, be) || Xn(be, v) || Xn(I == null ? void 0 : I.portalNode, be) || be != null && be.hasAttribute(Ms("focus-guard")) || A && (aa(A.nodesRef.current, f).find((Se) => {
          var Pe, Be;
          return Xn((Pe = Se.context) == null ? void 0 : Pe.elements.floating, be) || Xn((Be = Se.context) == null ? void 0 : Be.elements.domReference, be);
        }) || tV(A.nodesRef.current, f).find((Se) => {
          var Pe, Be;
          return ((Pe = Se.context) == null ? void 0 : Pe.elements.floating) === be || ((Be = Se.context) == null ? void 0 : Be.elements.domReference) === be;
        })));
        be && ke && !L.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        be !== U.current && (V.current = !0, h(!1, T));
      });
    }
    if (v && Ln(g))
      return g.addEventListener("focusout", de), g.addEventListener("pointerdown", ee), !c && v.addEventListener("focusout", de), () => {
        g.removeEventListener("focusout", de), g.removeEventListener("pointerdown", ee), !c && v.removeEventListener("focusout", de);
      };
  }, [r, g, v, c, f, A, I, h, u]), D.useEffect(() => {
    var ee;
    if (r)
      return;
    const de = Array.from((I == null || (ee = I.portalNode) == null ? void 0 : ee.querySelectorAll("[" + Ms("portal") + "]")) || []);
    if (v) {
      const T = [v, ...de, R.current, M.current, _.current.includes("reference") || j ? g : null].filter((ke) => ke != null), be = c ? fb(T, b, !b) : fb(T);
      return () => {
        be();
      };
    }
  }, [r, g, v, c, _, I, j, b]), fn(() => {
    if (r || !v)
      return;
    const ee = _r(v), de = Oi(ee);
    queueMicrotask(() => {
      const T = H(v), be = S.current, ke = (typeof be == "number" ? T[be] : be.current) || v, Se = Xn(v, de);
      !P && !Se && d && ni(ke, {
        preventScroll: ke === v
      });
    });
  }, [r, d, v, P, H, S]), fn(() => {
    if (r || !v)
      return;
    let ee = !1;
    const de = _r(v), T = Oi(de), be = y.current;
    U.current = T;
    function ke(Se) {
      if (Se.type === "escapeKey" && p.domReference.current && (U.current = p.domReference.current), ["referencePress", "escapeKey"].includes(Se.type))
        return;
      const Pe = Se.data.returnFocus;
      typeof Pe == "object" ? (V.current = !1, ee = Pe.preventScroll) : V.current = !Pe;
    }
    return m.on("dismiss", ke), () => {
      m.off("dismiss", ke);
      const Se = Oi(de);
      (Xn(v, Se) || A && aa(A.nodesRef.current, f).some((Be) => {
        var Ae;
        return Xn((Ae = Be.context) == null ? void 0 : Ae.elements.floating, Se);
      }) || be.openEvent && ["click", "mousedown"].includes(be.openEvent.type)) && p.domReference.current && (U.current = p.domReference.current), // eslint-disable-next-line react-hooks/exhaustive-deps
      x.current && Ln(U.current) && !V.current && ni(U.current, {
        // When dismissing nested floating elements, by the time the rAF has
        // executed, the menus will all have been unmounted. When they try
        // to get focused, the calls get ignored  leaving the root
        // reference focused as desired.
        cancelPrevious: !1,
        preventScroll: ee
      });
    };
  }, [r, v, x, y, p, m, A, f]), fn(() => {
    if (!(r || !I))
      return I.setFocusManagerState({
        modal: c,
        closeOnFocusOut: u,
        open: d,
        onOpenChange: h,
        refs: p
      }), () => {
        I.setFocusManagerState(null);
      };
  }, [r, I, c, d, h, p, u]), fn(() => {
    if (!r && v && typeof MutationObserver == "function" && !P) {
      const ee = () => {
        const T = v.getAttribute("tabindex");
        _.current.includes("floating") || Oi(_r(v)) !== p.domReference.current && z().length === 0 ? T !== "0" && v.setAttribute("tabindex", "0") : T !== "-1" && v.setAttribute("tabindex", "-1");
      };
      ee();
      const de = new MutationObserver(ee);
      return de.observe(v, {
        childList: !0,
        subtree: !0,
        attributes: !0
      }), () => {
        de.disconnect();
      };
    }
  }, [r, v, p, _, z, P]);
  function X(ee) {
    return r || !l || !c ? null : /* @__PURE__ */ D.createElement(dV, {
      ref: ee === "start" ? R : M,
      onClick: (de) => h(!1, de.nativeEvent)
    }, typeof l == "string" ? l : "Dismiss");
  }
  const E = !r && b && !j && ($ || c);
  return /* @__PURE__ */ D.createElement(D.Fragment, null, E && /* @__PURE__ */ D.createElement(qu, {
    "data-type": "inside",
    ref: I == null ? void 0 : I.beforeInsideRef,
    onFocus: (ee) => {
      if (c) {
        const T = H();
        ni(i[0] === "reference" ? T[0] : T[T.length - 1]);
      } else if (I != null && I.preserveTabOrder && I.portalNode)
        if (V.current = !1, us(ee, I.portalNode)) {
          const T = WE() || g;
          T == null || T.focus();
        } else {
          var de;
          (de = I.beforeOutsideRef.current) == null || de.focus();
        }
    }
  }), !j && X("start"), n, X("end"), E && /* @__PURE__ */ D.createElement(qu, {
    "data-type": "inside",
    ref: I == null ? void 0 : I.afterInsideRef,
    onFocus: (ee) => {
      if (c)
        ni(H()[0]);
      else if (I != null && I.preserveTabOrder && I.portalNode)
        if (u && (V.current = !0), us(ee, I.portalNode)) {
          const T = KE() || g;
          T == null || T.focus();
        } else {
          var de;
          (de = I.afterOutsideRef.current) == null || de.focus();
        }
    }
  }));
}
function hb(e) {
  return Ln(e.target) && e.target.tagName === "BUTTON";
}
function mb(e) {
  return PE(e);
}
function pV(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    dataRef: i,
    elements: {
      domReference: o
    }
  } = e, {
    enabled: a = !0,
    event: s = "click",
    toggle: c = !0,
    ignoreMouse: l = !1,
    keyboardHandlers: u = !0
  } = t, d = D.useRef(), p = D.useRef(!1);
  return D.useMemo(() => a ? {
    reference: {
      onPointerDown(f) {
        d.current = f.pointerType;
      },
      onMouseDown(f) {
        f.button === 0 && (tb(d.current, !0) && l || s !== "click" && (n && c && (!i.current.openEvent || i.current.openEvent.type === "mousedown") ? r(!1, f.nativeEvent) : (f.preventDefault(), r(!0, f.nativeEvent))));
      },
      onClick(f) {
        if (s === "mousedown" && d.current) {
          d.current = void 0;
          return;
        }
        tb(d.current, !0) && l || (n && c && (!i.current.openEvent || i.current.openEvent.type === "click") ? r(!1, f.nativeEvent) : r(!0, f.nativeEvent));
      },
      onKeyDown(f) {
        d.current = void 0, !(f.defaultPrevented || !u || hb(f)) && (f.key === " " && !mb(o) && (f.preventDefault(), p.current = !0), f.key === "Enter" && r(!(n && c), f.nativeEvent));
      },
      onKeyUp(f) {
        f.defaultPrevented || !u || hb(f) || mb(o) || f.key === " " && p.current && (p.current = !1, r(!(n && c), f.nativeEvent));
      }
    }
  } : {}, [a, i, s, l, u, o, c, n, r]);
}
const hV = D[/* @__PURE__ */ "useInsertionEffect".toString()], mV = hV || ((e) => e());
function ji(e) {
  const t = D.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return mV(() => {
    t.current = e;
  }), D.useCallback(function() {
    for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
      r[i] = arguments[i];
    return t.current == null ? void 0 : t.current(...r);
  }, []);
}
const yV = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, gV = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, vV = (e) => {
  var t, n;
  return {
    escapeKeyBubbles: typeof e == "boolean" ? e : (t = e == null ? void 0 : e.escapeKey) != null ? t : !1,
    outsidePressBubbles: typeof e == "boolean" ? e : (n = e == null ? void 0 : e.outsidePress) != null ? n : !0
  };
};
function bV(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    events: i,
    nodeId: o,
    elements: {
      reference: a,
      domReference: s,
      floating: c
    },
    dataRef: l
  } = e, {
    enabled: u = !0,
    escapeKey: d = !0,
    outsidePress: p = !0,
    outsidePressEvent: f = "pointerdown",
    referencePress: h = !1,
    referencePressEvent: m = "pointerdown",
    ancestorScroll: y = !1,
    bubbles: g
  } = t, v = Jd(), b = ZE() != null, _ = ji(typeof p == "function" ? p : () => !1), S = typeof p == "function" ? _ : p, x = D.useRef(!1), {
    escapeKeyBubbles: A,
    outsidePressBubbles: I
  } = vV(g), P = ji((M) => {
    if (!n || !u || !d || M.key !== "Escape")
      return;
    const V = v ? aa(v.nodesRef.current, o) : [];
    if (!A && (M.stopPropagation(), V.length > 0)) {
      let U = !0;
      if (V.forEach((L) => {
        var $;
        if (($ = L.context) != null && $.open && !L.context.dataRef.current.__escapeKeyBubbles) {
          U = !1;
          return;
        }
      }), !U)
        return;
    }
    i.emit("dismiss", {
      type: "escapeKey",
      data: {
        returnFocus: {
          preventScroll: !1
        }
      }
    }), r(!1, i8(M) ? M.nativeEvent : M);
  }), R = ji((M) => {
    const V = x.current;
    if (x.current = !1, V || typeof S == "function" && !S(M))
      return;
    const U = IE(M), L = "[" + Ms("inert") + "]", $ = _r(c).querySelectorAll(L);
    let j = en(U) ? U : null;
    for (; j && !hc(j); ) {
      const X = Co(j);
      if (X === _r(c).body || !en(X))
        break;
      j = X;
    }
    if ($.length && en(U) && !o8(U) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !Xn(U, c) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from($).every((X) => !Xn(j, X)))
      return;
    if (Ln(U) && c) {
      const X = U.clientWidth > 0 && U.scrollWidth > U.clientWidth, E = U.clientHeight > 0 && U.scrollHeight > U.clientHeight;
      let ee = E && M.offsetX > U.clientWidth;
      if (E && lr(U).direction === "rtl" && (ee = M.offsetX <= U.offsetWidth - U.clientWidth), ee || X && M.offsetY > U.clientHeight)
        return;
    }
    const z = v && aa(v.nodesRef.current, o).some((X) => {
      var E;
      return Hf(M, (E = X.context) == null ? void 0 : E.elements.floating);
    });
    if (Hf(M, c) || Hf(M, s) || z)
      return;
    const H = v ? aa(v.nodesRef.current, o) : [];
    if (H.length > 0) {
      let X = !0;
      if (H.forEach((E) => {
        var ee;
        if ((ee = E.context) != null && ee.open && !E.context.dataRef.current.__outsidePressBubbles) {
          X = !1;
          return;
        }
      }), !X)
        return;
    }
    i.emit("dismiss", {
      type: "outsidePress",
      data: {
        returnFocus: b ? {
          preventScroll: !0
        } : RE(M) || AE(M)
      }
    }), r(!1, M);
  });
  return D.useEffect(() => {
    if (!n || !u)
      return;
    l.current.__escapeKeyBubbles = A, l.current.__outsidePressBubbles = I;
    function M(L) {
      r(!1, L);
    }
    const V = _r(c);
    d && V.addEventListener("keydown", P), S && V.addEventListener(f, R);
    let U = [];
    return y && (en(s) && (U = Di(s)), en(c) && (U = U.concat(Di(c))), !en(a) && a && a.contextElement && (U = U.concat(Di(a.contextElement)))), U = U.filter((L) => {
      var $;
      return L !== (($ = V.defaultView) == null ? void 0 : $.visualViewport);
    }), U.forEach((L) => {
      L.addEventListener("scroll", M, {
        passive: !0
      });
    }), () => {
      d && V.removeEventListener("keydown", P), S && V.removeEventListener(f, R), U.forEach((L) => {
        L.removeEventListener("scroll", M);
      });
    };
  }, [l, c, s, a, d, S, f, n, r, y, u, A, I, P, R]), D.useEffect(() => {
    x.current = !1;
  }, [S, f]), D.useMemo(() => u ? {
    reference: {
      onKeyDown: P,
      [yV[m]]: (M) => {
        h && (i.emit("dismiss", {
          type: "referencePress",
          data: {
            returnFocus: !1
          }
        }), r(!1, M.nativeEvent));
      }
    },
    floating: {
      onKeyDown: P,
      [gV[f]]: () => {
        x.current = !0;
      }
    }
  } : {}, [u, i, h, f, m, r, P]);
}
let ph;
process.env.NODE_ENV !== "production" && (ph = /* @__PURE__ */ new Set());
function wV(e) {
  var t;
  e === void 0 && (e = {});
  const {
    open: n = !1,
    onOpenChange: r,
    nodeId: i
  } = e;
  if (process.env.NODE_ENV !== "production") {
    var o;
    const A = "Floating UI: Cannot pass a virtual element to the `elements.reference` option, as it must be a real DOM element. Use `refs.setPositionReference` instead.";
    if ((o = e.elements) != null && o.reference && !en(e.elements.reference)) {
      var a;
      if (!((a = ph) != null && a.has(A))) {
        var s;
        (s = ph) == null || s.add(A), console.error(A);
      }
    }
  }
  const [c, l] = D.useState(null), u = ((t = e.elements) == null ? void 0 : t.reference) || c, d = A8(e), p = Jd(), f = ji((A, I) => {
    A && (m.current.openEvent = I), r == null || r(A, I);
  }), h = D.useRef(null), m = D.useRef({}), y = D.useState(() => X8())[0], g = uy(), v = D.useCallback((A) => {
    const I = en(A) ? {
      getBoundingClientRect: () => A.getBoundingClientRect(),
      contextElement: A
    } : A;
    d.refs.setReference(I);
  }, [d.refs]), b = D.useCallback((A) => {
    (en(A) || A === null) && (h.current = A, l(A)), (en(d.refs.reference.current) || d.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    A !== null && !en(A)) && d.refs.setReference(A);
  }, [d.refs]), _ = D.useMemo(() => ({
    ...d.refs,
    setReference: b,
    setPositionReference: v,
    domReference: h
  }), [d.refs, b, v]), S = D.useMemo(() => ({
    ...d.elements,
    domReference: u
  }), [d.elements, u]), x = D.useMemo(() => ({
    ...d,
    refs: _,
    elements: S,
    dataRef: m,
    nodeId: i,
    floatingId: g,
    events: y,
    open: n,
    onOpenChange: f
  }), [d, i, g, y, n, f, _, S]);
  return fn(() => {
    const A = p == null ? void 0 : p.nodesRef.current.find((I) => I.id === i);
    A && (A.context = x);
  }), D.useMemo(() => ({
    ...d,
    context: x,
    refs: _,
    elements: S
  }), [d, _, S, x]);
}
function Yf(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  return {
    ...n === "floating" && {
      tabIndex: -1
    },
    ...e,
    ...t.map((i) => i ? i[n] : null).concat(e).reduce((i, o) => (o && Object.entries(o).forEach((a) => {
      let [s, c] = a;
      if (s.indexOf("on") === 0) {
        if (r.has(s) || r.set(s, []), typeof c == "function") {
          var l;
          (l = r.get(s)) == null || l.push(c), i[s] = function() {
            for (var u, d = arguments.length, p = new Array(d), f = 0; f < d; f++)
              p[f] = arguments[f];
            return (u = r.get(s)) == null ? void 0 : u.map((h) => h(...p)).find((h) => h !== void 0);
          };
        }
      } else
        i[s] = c;
    }), i), {})
  };
}
function xV(e) {
  e === void 0 && (e = []);
  const t = e, n = D.useCallback(
    (o) => Yf(o, e, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), r = D.useCallback(
    (o) => Yf(o, e, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), i = D.useCallback(
    (o) => Yf(o, e, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e.map((o) => o == null ? void 0 : o.item)
  );
  return D.useMemo(() => ({
    getReferenceProps: n,
    getFloatingProps: r,
    getItemProps: i
  }), [n, r, i]);
}
let yb = !1;
function Yd(e, t, n) {
  switch (e) {
    case "vertical":
      return t;
    case "horizontal":
      return n;
    default:
      return t || n;
  }
}
function gb(e, t) {
  return Yd(t, e === ly || e === Kd, e === Ra || e === mc);
}
function Gf(e, t, n) {
  return Yd(t, e === Kd, n ? e === Ra : e === mc) || e === "Enter" || e == " " || e === "";
}
function _V(e, t, n) {
  return Yd(t, n ? e === Ra : e === mc, e === Kd);
}
function vb(e, t, n) {
  return Yd(t, n ? e === mc : e === Ra, e === ly);
}
function SV(e, t) {
  const {
    open: n,
    onOpenChange: r,
    refs: i,
    elements: {
      domReference: o,
      floating: a
    }
  } = e, {
    listRef: s,
    activeIndex: c,
    onNavigate: l = () => {
    },
    enabled: u = !0,
    selectedIndex: d = null,
    allowEscape: p = !1,
    loop: f = !1,
    nested: h = !1,
    rtl: m = !1,
    virtual: y = !1,
    focusItemOnOpen: g = "auto",
    focusItemOnHover: v = !0,
    openOnArrowKeyDown: b = !0,
    disabledIndices: _ = void 0,
    orientation: S = "vertical",
    cols: x = 1,
    scrollItemIntoView: A = !0,
    virtualItemRef: I
  } = t;
  process.env.NODE_ENV !== "production" && (p && (f || console.warn(["Floating UI: `useListNavigation` looping must be enabled to allow", "escaping."].join(" ")), y || console.warn(["Floating UI: `useListNavigation` must be virtual to allow", "escaping."].join(" "))), S === "vertical" && x > 1 && console.warn(["Floating UI: In grid list navigation mode (`cols` > 1), the", '`orientation` should be either "horizontal" or "both".'].join(" ")));
  const P = ZE(), R = Jd(), M = ji(l), V = D.useRef(g), U = D.useRef(d ?? -1), L = D.useRef(null), $ = D.useRef(!0), j = D.useRef(M), z = D.useRef(!!a), H = D.useRef(!1), X = D.useRef(!1), E = Ni(_), ee = Ni(n), de = Ni(A), [T, be] = D.useState(), [ke, Se] = D.useState(), Pe = ji(function(pe, ue, xe) {
    xe === void 0 && (xe = !1);
    const fe = pe.current[ue.current];
    fe && (y ? (be(fe.id), R == null || R.events.emit("virtualfocus", fe), I && (I.current = fe)) : ni(fe, {
      preventScroll: !0,
      // Mac Safari does not move the virtual cursor unless the focus call
      // is sync. However, for the very first focus call, we need to wait
      // for the position to be ready in order to prevent unwanted
      // scrolling. This means the virtual cursor will not move to the first
      // item when first opening the floating element, but will on
      // subsequent calls. `preventScroll` is supported in modern Safari,
      // so we can use that instead.
      // iOS Safari must be async or the first item will not be focused.
      sync: r8() && OE() ? yb || H.current : !1
    }), requestAnimationFrame(() => {
      const $e = de.current;
      $e && fe && (xe || !$.current) && (fe.scrollIntoView == null || fe.scrollIntoView(typeof $e == "boolean" ? {
        block: "nearest",
        inline: "nearest"
      } : $e));
    }));
  });
  fn(() => {
    document.createElement("div").focus({
      get preventScroll() {
        return yb = !0, !1;
      }
    });
  }, []), fn(() => {
    u && (n && a ? V.current && d != null && (X.current = !0, M(d)) : z.current && (U.current = -1, j.current(null)));
  }, [u, n, a, d, M]), fn(() => {
    if (u && n && a)
      if (c == null) {
        if (H.current = !1, d != null)
          return;
        if (z.current && (U.current = -1, Pe(s, U)), !z.current && V.current && (L.current != null || V.current === !0 && L.current == null)) {
          let pe = 0;
          const ue = () => {
            s.current[0] == null ? (pe < 2 && (pe ? requestAnimationFrame : queueMicrotask)(ue), pe++) : (U.current = L.current == null || Gf(L.current, S, m) || h ? Wf(s, E.current) : lb(s, E.current), L.current = null, M(U.current));
          };
          ue();
        }
      } else
        ls(s, c) || (U.current = c, Pe(s, U, X.current), X.current = !1);
  }, [u, n, a, c, d, h, s, S, m, M, Pe, E]), fn(() => {
    var pe, ue;
    if (!u || a || !R || y || !z.current)
      return;
    const xe = R.nodesRef.current, fe = (pe = xe.find((q) => q.id === P)) == null || (ue = pe.context) == null ? void 0 : ue.elements.floating, $e = Oi(_r(a)), nt = xe.some((q) => q.context && Xn(q.context.elements.floating, $e));
    fe && !nt && $.current && fe.focus({
      preventScroll: !0
    });
  }, [u, a, R, P, y]), fn(() => {
    if (!u || !R || !y || P)
      return;
    function pe(ue) {
      Se(ue.id), I && (I.current = ue);
    }
    return R.events.on("virtualfocus", pe), () => {
      R.events.off("virtualfocus", pe);
    };
  }, [u, R, y, P, I]), fn(() => {
    j.current = M, z.current = !!a;
  }), fn(() => {
    n || (L.current = null);
  }, [n]);
  const Be = c != null, Ae = D.useMemo(() => {
    function pe(xe) {
      if (!n)
        return;
      const fe = s.current.indexOf(xe);
      fe !== -1 && M(fe);
    }
    return {
      onFocus(xe) {
        let {
          currentTarget: fe
        } = xe;
        pe(fe);
      },
      onClick: (xe) => {
        let {
          currentTarget: fe
        } = xe;
        return fe.focus({
          preventScroll: !0
        });
      },
      // Safari
      ...v && {
        onMouseMove(xe) {
          let {
            currentTarget: fe
          } = xe;
          pe(fe);
        },
        onPointerLeave(xe) {
          let {
            pointerType: fe
          } = xe;
          !$.current || fe === "touch" || (U.current = -1, Pe(s, U), M(null), y || ni(i.floating.current, {
            preventScroll: !0
          }));
        }
      }
    };
  }, [n, i, Pe, v, s, M, y]);
  return D.useMemo(() => {
    if (!u)
      return {};
    const pe = E.current;
    function ue(q) {
      if ($.current = !1, H.current = !0, !ee.current && q.currentTarget === i.floating.current)
        return;
      if (h && vb(q.key, S, m)) {
        Cn(q), r(!1, q.nativeEvent), Ln(o) && !y && o.focus();
        return;
      }
      const ie = U.current, se = Wf(s, pe), le = lb(s, pe);
      if (q.key === "Home" && (Cn(q), U.current = se, M(U.current)), q.key === "End" && (Cn(q), U.current = le, M(U.current)), !(x > 1 && (U.current = K8(s, {
        event: q,
        orientation: S,
        loop: f,
        cols: x,
        disabledIndices: pe,
        minIndex: se,
        maxIndex: le,
        prevIndex: U.current,
        stopEvent: !0
      }), M(U.current), S === "both")) && gb(q.key, S)) {
        if (Cn(q), n && !y && Oi(q.currentTarget.ownerDocument) === q.currentTarget) {
          U.current = Gf(q.key, S, m) ? se : le, M(U.current);
          return;
        }
        Gf(q.key, S, m) ? f ? U.current = ie >= le ? p && ie !== s.current.length ? -1 : se : Pn(s, {
          startingIndex: ie,
          disabledIndices: pe
        }) : U.current = Math.min(le, Pn(s, {
          startingIndex: ie,
          disabledIndices: pe
        })) : f ? U.current = ie <= se ? p && ie !== -1 ? s.current.length : le : Pn(s, {
          startingIndex: ie,
          decrement: !0,
          disabledIndices: pe
        }) : U.current = Math.max(se, Pn(s, {
          startingIndex: ie,
          decrement: !0,
          disabledIndices: pe
        })), ls(s, U.current) ? M(null) : M(U.current);
      }
    }
    function xe(q) {
      g === "auto" && RE(q.nativeEvent) && (V.current = !0);
    }
    function fe(q) {
      V.current = g, g === "auto" && AE(q.nativeEvent) && (V.current = !0);
    }
    const $e = y && n && Be && {
      "aria-activedescendant": ke || T
    }, nt = s.current.find((q) => (q == null ? void 0 : q.id) === T);
    return {
      reference: {
        ...$e,
        onKeyDown(q) {
          $.current = !1;
          const ie = q.key.indexOf("Arrow") === 0, se = _V(q.key, S, m), le = vb(q.key, S, m), De = gb(q.key, S), _e = (h ? se : De) || q.key === "Enter" || q.key.trim() === "";
          if (y && n) {
            const W = R == null ? void 0 : R.nodesRef.current.find((ae) => ae.parentId == null), re = R && W ? nV(R.nodesRef.current, W.id) : null;
            if (ie && re && I) {
              const ae = new KeyboardEvent("keydown", {
                key: q.key,
                bubbles: !0
              });
              if (se || le) {
                var Ze, yt;
                const Te = ((Ze = re.context) == null ? void 0 : Ze.elements.domReference) === q.currentTarget, Xe = le && !Te ? (yt = re.context) == null ? void 0 : yt.elements.domReference : se ? nt : null;
                Xe && (Cn(q), Xe.dispatchEvent(ae), Se(void 0));
              }
              if (De && re.context && re.context.open && re.parentId && q.currentTarget !== re.context.elements.domReference) {
                var et;
                Cn(q), (et = re.context.elements.domReference) == null || et.dispatchEvent(ae);
                return;
              }
            }
            return ue(q);
          }
          if (!(!n && !b && ie)) {
            if (_e && (L.current = h && De ? null : q.key), h) {
              se && (Cn(q), n ? (U.current = Wf(s, pe), M(U.current)) : r(!0, q.nativeEvent));
              return;
            }
            De && (d != null && (U.current = d), Cn(q), !n && b ? r(!0, q.nativeEvent) : ue(q), n && M(U.current));
          }
        },
        onFocus() {
          n && M(null);
        },
        onPointerDown: fe,
        onMouseDown: xe,
        onClick: xe
      },
      floating: {
        "aria-orientation": S === "both" ? void 0 : S,
        ...$e,
        onKeyDown: ue,
        onPointerMove() {
          $.current = !0;
        }
      },
      item: Ae
    };
  }, [o, i, T, ke, E, ee, s, u, S, m, y, n, Be, h, d, b, p, x, f, g, M, r, Ae, R, I]);
}
function kV(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    floatingId: r
  } = e, {
    enabled: i = !0,
    role: o = "dialog"
  } = t, a = uy();
  return D.useMemo(() => {
    const s = {
      id: r,
      role: o
    };
    return i ? o === "tooltip" ? {
      reference: {
        "aria-describedby": n ? r : void 0
      },
      floating: s
    } : {
      reference: {
        "aria-expanded": n ? "true" : "false",
        "aria-haspopup": o === "alertdialog" ? "dialog" : o,
        "aria-controls": n ? r : void 0,
        ...o === "listbox" && {
          role: "combobox"
        },
        ...o === "menu" && {
          id: a
        }
      },
      floating: {
        ...s,
        ...o === "menu" && {
          "aria-labelledby": a
        }
      }
    } : {};
  }, [i, o, n, r, a]);
}
function EV(e, t) {
  var n;
  const {
    open: r,
    dataRef: i
  } = e, {
    listRef: o,
    activeIndex: a,
    onMatch: s,
    onTypingChange: c,
    enabled: l = !0,
    findMatch: u = null,
    resetMs: d = 750,
    ignoreKeys: p = [],
    selectedIndex: f = null
  } = t, h = D.useRef(), m = D.useRef(""), y = D.useRef((n = f ?? a) != null ? n : -1), g = D.useRef(null), v = ji(s), b = ji(c), _ = Ni(u), S = Ni(p);
  return fn(() => {
    r && (clearTimeout(h.current), g.current = null, m.current = "");
  }, [r]), fn(() => {
    if (r && m.current === "") {
      var x;
      y.current = (x = f ?? a) != null ? x : -1;
    }
  }, [r, f, a]), D.useMemo(() => {
    if (!l)
      return {};
    function x(P) {
      P ? i.current.typing || (i.current.typing = P, b(P)) : i.current.typing && (i.current.typing = P, b(P));
    }
    function A(P, R, M) {
      const V = _.current ? _.current(R, M) : R.find((U) => (U == null ? void 0 : U.toLocaleLowerCase().indexOf(M.toLocaleLowerCase())) === 0);
      return V ? P.indexOf(V) : -1;
    }
    function I(P) {
      const R = o.current;
      if (m.current.length > 0 && m.current[0] !== " " && (A(R, R, m.current) === -1 ? x(!1) : P.key === " " && Cn(P)), R == null || S.current.includes(P.key) || // Character key.
      P.key.length !== 1 || // Modifier key.
      P.ctrlKey || P.metaKey || P.altKey)
        return;
      r && P.key !== " " && (Cn(P), x(!0)), R.every((L) => {
        var $, j;
        return L ? (($ = L[0]) == null ? void 0 : $.toLocaleLowerCase()) !== ((j = L[1]) == null ? void 0 : j.toLocaleLowerCase()) : !0;
      }) && m.current === P.key && (m.current = "", y.current = g.current), m.current += P.key, clearTimeout(h.current), h.current = setTimeout(() => {
        m.current = "", y.current = g.current, x(!1);
      }, d);
      const V = y.current, U = A(R, [...R.slice((V || 0) + 1), ...R.slice(0, (V || 0) + 1)], m.current);
      U !== -1 ? (v(U), g.current = U) : P.key !== " " && (m.current = "", x(!1));
    }
    return {
      reference: {
        onKeyDown: I
      },
      floating: {
        onKeyDown: I,
        onKeyUp(P) {
          P.key === " " && x(!1);
        }
      }
    };
  }, [l, r, i, o, d, S, _, v, b]);
}
const CV = ({ styles: e, type: t, options: n, label: r, reusable: i }) => {
  var z, H, X, E, ee, de, T, be, ke, Se, Pe, Be;
  const o = Ie((Ae) => Ae.sendTextMessage), a = Ie((Ae) => Ae.messageContainerRef), s = Ie((Ae) => Ae.isReadOnly), [c, l] = D.useState(!1), [u, d] = D.useState(null), [p, f] = D.useState(null), h = n.reduce(
    (Ae, pe) => (Ae[pe.label] = pe.value, Ae),
    {}
  ), m = h ? Object.keys(h) : [], y = (Ae) => {
    l(p !== null && !i ? !1 : Ae);
  }, { refs: g, floatingStyles: v, context: b } = wV({
    placement: "bottom-start",
    open: c,
    onOpenChange: y,
    whileElementsMounted: T8,
    middleware: [
      l8(5),
      u8({
        padding: 10,
        boundary: (a == null ? void 0 : a.current) ?? void 0,
        crossAxis: !0
      }),
      d8({
        apply({ rects: Ae, elements: pe, availableHeight: ue }) {
          Object.assign(pe.floating.style, {
            maxHeight: `${ue}px`,
            minWidth: `${Ae.reference.width}px`
          });
        },
        padding: 10
      })
    ]
  }), _ = D.useRef([]), S = D.useRef(m), x = D.useRef(!1), A = pV(b, { event: "mousedown" }), I = bV(b), P = kV(b, { role: "listbox" }), R = SV(b, {
    listRef: _,
    activeIndex: u,
    selectedIndex: p,
    onNavigate: d,
    // This is a large list, allow looping.
    loop: !0
  }), M = EV(b, {
    listRef: S,
    activeIndex: u,
    selectedIndex: p,
    onMatch: c ? d : f,
    onTypingChange(Ae) {
      x.current = Ae;
    }
  }), { getReferenceProps: V, getFloatingProps: U, getItemProps: L } = xV([
    I,
    P,
    R,
    M,
    A
  ]), $ = (Ae) => {
    f(Ae), o(h[m[Ae]]), l(!1);
  }, j = p !== null ? m[p] : void 0;
  return /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
    /* @__PURE__ */ F.jsxs(
      "div",
      {
        tabIndex: 0,
        ref: g.setReference,
        "aria-labelledby": "select-label",
        "aria-autocomplete": "none",
        "data-disabled": p !== null && !i ? "" : void 0,
        ...(H = (z = e == null ? void 0 : e[t]) == null ? void 0 : z.button) == null ? void 0 : H.container,
        ...V(),
        children: [
          /* @__PURE__ */ F.jsx("span", { ...(E = (X = e == null ? void 0 : e[t]) == null ? void 0 : X.button) == null ? void 0 : E.text, children: j || r || "Select..." }),
          /* @__PURE__ */ F.jsx(q7, { ...(de = (ee = e == null ? void 0 : e[t]) == null ? void 0 : ee.button) == null ? void 0 : de.icon })
        ]
      }
    ),
    c && /* @__PURE__ */ F.jsx(uV, { children: /* @__PURE__ */ F.jsx(fV, { context: b, modal: !1, children: /* @__PURE__ */ F.jsx(
      "div",
      {
        ref: g.setFloating,
        className: (ke = (be = (T = e == null ? void 0 : e[t]) == null ? void 0 : T.content) == null ? void 0 : be.container) == null ? void 0 : ke.className,
        style: { ...v, ...(Be = (Pe = (Se = e == null ? void 0 : e[t]) == null ? void 0 : Se.content) == null ? void 0 : Pe.container) == null ? void 0 : Be.style },
        ...U(),
        children: m.map((Ae, pe) => {
          var ue, xe;
          return /* @__PURE__ */ F.jsx(
            "div",
            {
              ref: (fe) => {
                _.current[pe] = fe;
              },
              role: "option",
              tabIndex: pe === u ? 0 : -1,
              "aria-selected": pe === p && pe === u,
              "data-active": pe === u ? "" : void 0,
              ...(xe = (ue = e == null ? void 0 : e[t]) == null ? void 0 : ue.content) == null ? void 0 : xe.item,
              ...L({
                onClick() {
                  s || $(pe);
                },
                onKeyDown(fe) {
                  s || (fe.key === "Enter" && (fe.preventDefault(), $(pe)), fe.key === " " && !x.current && (fe.preventDefault(), $(pe)));
                }
              }),
              children: Ae
            },
            Ae
          );
        })
      }
    ) }) })
  ] });
}, TV = Ue(({ type: e, title: t, styles: n, url: r, ...i }, o) => {
  var a, s, c;
  return /* @__PURE__ */ F.jsxs("a", { ...i, ...(a = n == null ? void 0 : n[e]) == null ? void 0 : a.container, href: r, download: !0, ref: o, target: "_blank", children: [
    /* @__PURE__ */ F.jsx("p", { ...(s = n == null ? void 0 : n[e]) == null ? void 0 : s.title, children: t || r }),
    /* @__PURE__ */ F.jsx(U7, { ...(c = n == null ? void 0 : n[e]) == null ? void 0 : c.icon })
  ] });
}), RV = {
  audio: C7,
  bubble: x7,
  button: b7,
  carousel: J9,
  column: J7,
  dropdown: CV,
  file: TV,
  image: S7,
  location: K7,
  row: Y7,
  text: eF,
  video: E7
}, yc = ({ block: e, styles: t, ...n }) => {
  const i = Ie((a) => a.renderers)[e.type] ?? RV[e.type], o = { ...n, styles: t, ...e };
  return /* @__PURE__ */ F.jsx(i, { ...o });
}, AV = Ao(
  Ue((e, t) => {
    const { composer: n } = Ie((d) => d.theme), r = Ie((d) => d.sendTextMessage), i = Ie((d) => d.disableComposer), o = Ie((d) => d.isReadOnly), [a, s] = Ve(""), [c, l] = Ve(-1);
    if (o)
      return null;
    const u = () => {
      a && (r(a), s(""), l(-1));
    };
    return /* @__PURE__ */ F.jsx(
      mE.Provider,
      {
        value: { value: a, setValue: s, historyIndex: c, setHistoryIndex: l, sendMessage: u },
        children: /* @__PURE__ */ F.jsx("div", { "data-disabled": i, ...e, ...n == null ? void 0 : n.container, ref: t })
      }
    );
  })
), OV = Ao((e) => {
  const { composer: t } = Ie((g) => g.theme), n = Ie((g) => g.configuration), r = Ie((g) => g.disableComposer), i = Ie((g) => g.setIsTyping), { value: o, setValue: a, historyIndex: s, setHistoryIndex: c, sendMessage: l } = yE(), u = Ke(null), d = ir((g) => g.user), p = ir((g) => g.messageHistory), [f, h] = Ve(!1);
  tF(u.current, o);
  function m({ key: g }) {
    g === "Shift" && h(!0);
  }
  function y({ key: g }) {
    g === "Shift" && h(!1);
  }
  return Ne(() => (window.addEventListener("keydown", m), window.addEventListener("keyup", y), () => {
    window.removeEventListener("keydown", m), window.removeEventListener("keyup", y);
  }), []), /* @__PURE__ */ F.jsx(
    "textarea",
    {
      ...t == null ? void 0 : t.input,
      placeholder: (n == null ? void 0 : n.composerPlaceholder) ?? "Type your message...",
      disabled: r,
      ref: u,
      value: o,
      "data-has-value": !!o,
      onChange: (g) => a(g.target.value),
      onKeyDown: (g) => {
        if (!r) {
          if (g.key === "Enter" && (g.preventDefault(), f ? (a(`${o}
`), setTimeout(() => {
            var v;
            return (v = u.current) == null ? void 0 : v.scroll({ behavior: "instant", top: u.current.scrollHeight });
          }, 0)) : (l(), setTimeout(() => i(!0, 9e3), 500))), g.key === "ArrowUp") {
            g.preventDefault();
            const v = p[(d == null ? void 0 : d.userId) ?? ""] ?? [];
            s < v.length - 1 && a(v[s + 1]), c(() => Math.min(s + 1, v.length - 1));
          }
          if (g.key === "ArrowDown") {
            g.preventDefault();
            const v = p[(d == null ? void 0 : d.userId) ?? ""] ?? [];
            a(s === 0 ? "" : v[s - 1]), c(() => Math.max(s - 1, -1));
          }
        }
      },
      ...e
    }
  );
}), IV = Ao(
  Ue(({ icon: e = W7, ...t }, n) => {
    var u, d;
    const { composer: r } = Ie((p) => p.theme), i = Ie((p) => p.sendFile), o = Ie((p) => p.addMessage), a = Ke(null);
    if (!Ie((p) => p.allowFileUpload))
      return null;
    const c = () => {
      var p;
      a.current && ((p = a.current) == null || p.click());
    }, l = async (p) => {
      var h;
      const f = (h = p.target.files) == null ? void 0 : h[0];
      if (f)
        try {
          const { fileUrl: m, type: y } = await i(f) ?? "";
          o({
            direction: "outgoing",
            sender: { name: "You" },
            timestamp: /* @__PURE__ */ new Date(),
            disableInput: !1,
            block: { type: y, url: m }
          });
        } catch (m) {
          console.error("Error sending file:", m);
        }
    };
    return /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
      /* @__PURE__ */ F.jsx("button", { type: "button", ref: n, ...t, ...(u = r == null ? void 0 : r.uploadButton) == null ? void 0 : u.container, onClick: c, children: /* @__PURE__ */ F.jsx(e, { ...(d = r == null ? void 0 : r.uploadButton) == null ? void 0 : d.icon }) }),
      /* @__PURE__ */ F.jsx("input", { type: "file", ref: a, style: { display: "none" }, onChange: l })
    ] });
  })
), PV = Ao(
  Ue(({ icon: e = N7, ...t }, n) => {
    var a, s;
    const { value: r, sendMessage: i } = yE(), { composer: o } = Ie((c) => c.theme);
    return /* @__PURE__ */ F.jsx(
      "button",
      {
        type: "button",
        ref: n,
        ...t,
        ...(a = o == null ? void 0 : o.button) == null ? void 0 : a.container,
        disabled: !r,
        onClick: i,
        children: /* @__PURE__ */ F.jsx(e, { ...(s = o == null ? void 0 : o.button) == null ? void 0 : s.icon })
      }
    );
  })
), $V = ({ children: e }) => {
  const [t, n] = Ve(!1), [r, i] = Ve(""), [o, a] = Ve(null), s = ({ title: l, content: u }) => {
    i(l), a(u), n(!0);
  }, c = () => {
    n(!1);
  };
  return /* @__PURE__ */ F.jsxs(vE.Provider, { value: { hideModal: c, showModal: s, title: r, content: o, open: t }, children: [
    /* @__PURE__ */ F.jsx(Ro, { open: t, onOpenChange: n, children: /* @__PURE__ */ F.jsx(Ro.Content, { title: r, children: o }) }),
    e
  ] });
}, uJ = ({ children: e, ...t }) => {
  const n = Ke(), r = Ke(null), i = v7({ ...t, messageContainerRef: r });
  return n.current || (n.current = i), /* @__PURE__ */ F.jsx(hE.Provider, { value: n.current, children: /* @__PURE__ */ F.jsx(DV, { children: e }) });
}, DV = ({ children: e }) => {
  const t = Ie((g) => g.client), n = Ie((g) => g.addMessage), r = Ie((g) => g.setMessages), i = Ie((g) => g.configuration), o = Ie((g) => g.setConnected), a = Ie((g) => g.userData), s = Ie((g) => g.userName), c = Ie((g) => g.userPictureUrl), l = Ie((g) => g.setIsTyping), u = Ie((g) => g.getMessages), d = ir((g) => g.setConversationId), p = ir((g) => g.user), f = ir((g) => g.conversationId), h = ir((g) => g.setUser), [m, y] = Ve(0);
  return Ne(() => {
    if (t)
      return t.on("messageSent", (g) => {
        const v = u(), b = v[v.length - 1];
        (v.length === 0 || b.block.type === "bubble" && b.block.block.type === "text" && b.block.block.text !== g) && n({
          direction: "outgoing",
          sender: { name: "You" },
          timestamp: /* @__PURE__ */ new Date(),
          block: {
            type: "bubble",
            block: {
              type: "text",
              text: g
            }
          },
          disableInput: !1
        });
      });
  }, [f]), Ne(() => {
    if (t)
      return t.on("message", (g) => {
        try {
          const { payload: v, disableInput: b, id: _, conversationId: S } = g;
          if (f !== S)
            return;
          l(!1, 0), n({
            id: _,
            direction: "incoming",
            sender: { name: i.botName ?? "Bot", avatar: i.botAvatar },
            timestamp: new Date(g.sentOn),
            block: v,
            disableInput: b
          });
        } catch {
          console.error("Invalid message payload");
        }
      });
  }, [f]), Ne(() => {
    if (t)
      return t.on("conversation", (g) => {
        d(g);
      });
  }, []), Bv(async () => {
    if (t)
      return t.on("error", () => {
        y((g) => g + 1);
      });
  }), Bv(async () => {
    if (!t || f && t.conversationId === f)
      return;
    let g;
    try {
      g = await t.connect(p, a, {
        name: s,
        pictureUrl: c
      }), o(!0);
    } catch (b) {
      console.error(b), o(!1);
      return;
    }
    h(g), f && await t.conversationExists(f) ? await t.switchConversation(f) : await t.newConversation();
    const v = [];
    for (const b of await t.listMessages())
      try {
        const { payload: _, authorId: S, sentOn: x, disableInput: A, id: I } = b, P = S === t.userId ? "outgoing" : "incoming";
        v.push({
          id: I,
          direction: P,
          sender: P === "outgoing" ? { name: "You" } : { name: i.botName ?? "Bot", avatar: i.botAvatar },
          timestamp: new Date(x),
          block: _,
          disableInput: A
        });
      } catch {
        console.error("Invalid message payload");
      }
    return r(v.reverse()), () => {
      t.disconnect();
    };
  }, [m, f]), /* @__PURE__ */ F.jsx(F.Fragment, { children: e });
};
function Nn(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
const NV = D["useId".toString()] || (() => {
});
let jV = 0;
function dl(e) {
  const [t, n] = D.useState(NV());
  return ha(() => {
    e || n(
      (r) => r ?? String(jV++)
    );
  }, [
    e
  ]), e || (t ? `radix-${t}` : "");
}
function GE({ prop: e, defaultProp: t, onChange: n = () => {
} }) {
  const [r, i] = MV({
    defaultProp: t,
    onChange: n
  }), o = e !== void 0, a = o ? e : r, s = Bn(n), c = an((l) => {
    if (o) {
      const d = typeof l == "function" ? l(e) : l;
      d !== e && s(d);
    } else
      i(l);
  }, [
    o,
    e,
    i,
    s
  ]);
  return [
    a,
    c
  ];
}
function MV({ defaultProp: e, onChange: t }) {
  const n = Ve(e), [r] = n, i = Ke(r), o = Bn(t);
  return Ne(() => {
    i.current !== r && (o(r), i.current = r);
  }, [
    r,
    i,
    o
  ]), n;
}
function qV(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Bn(e);
  Ne(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r), () => t.removeEventListener("keydown", r);
  }, [
    n,
    t
  ]);
}
const hh = "dismissableLayer.update", LV = "dismissableLayer.pointerDownOutside", FV = "dismissableLayer.focusOutside";
let bb;
const UV = /* @__PURE__ */ gr({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), BV = /* @__PURE__ */ Ue((e, t) => {
  var n;
  const { disableOutsidePointerEvents: r = !1, onEscapeKeyDown: i, onPointerDownOutside: o, onFocusOutside: a, onInteractOutside: s, onDismiss: c, ...l } = e, u = Ir(UV), [d, p] = Ve(null), f = (n = d == null ? void 0 : d.ownerDocument) !== null && n !== void 0 ? n : globalThis == null ? void 0 : globalThis.document, [, h] = Ve({}), m = ur(
    t,
    (I) => p(I)
  ), y = Array.from(u.layers), [g] = [
    ...u.layersWithOutsidePointerEventsDisabled
  ].slice(-1), v = y.indexOf(g), b = d ? y.indexOf(d) : -1, _ = u.layersWithOutsidePointerEventsDisabled.size > 0, S = b >= v, x = zV((I) => {
    const P = I.target, R = [
      ...u.branches
    ].some(
      (M) => M.contains(P)
    );
    !S || R || (o == null || o(I), s == null || s(I), I.defaultPrevented || c == null || c());
  }, f), A = ZV((I) => {
    const P = I.target;
    [
      ...u.branches
    ].some(
      (M) => M.contains(P)
    ) || (a == null || a(I), s == null || s(I), I.defaultPrevented || c == null || c());
  }, f);
  return qV((I) => {
    b === u.layers.size - 1 && (i == null || i(I), !I.defaultPrevented && c && (I.preventDefault(), c()));
  }, f), Ne(() => {
    if (d)
      return r && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (bb = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(d)), u.layers.add(d), wb(), () => {
        r && u.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = bb);
      };
  }, [
    d,
    f,
    r,
    u
  ]), Ne(() => () => {
    d && (u.layers.delete(d), u.layersWithOutsidePointerEventsDisabled.delete(d), wb());
  }, [
    d,
    u
  ]), Ne(() => {
    const I = () => h({});
    return document.addEventListener(hh, I), () => document.removeEventListener(hh, I);
  }, []), /* @__PURE__ */ Me(Rn.div, vo({}, l, {
    ref: m,
    style: {
      pointerEvents: _ ? S ? "auto" : "none" : void 0,
      ...e.style
    },
    onFocusCapture: Nn(e.onFocusCapture, A.onFocusCapture),
    onBlurCapture: Nn(e.onBlurCapture, A.onBlurCapture),
    onPointerDownCapture: Nn(e.onPointerDownCapture, x.onPointerDownCapture)
  }));
});
function zV(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Bn(e), r = Ke(!1), i = Ke(() => {
  });
  return Ne(() => {
    const o = (s) => {
      if (s.target && !r.current) {
        let l = function() {
          XE(LV, n, c, {
            discrete: !0
          });
        };
        const c = {
          originalEvent: s
        };
        s.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = l, t.addEventListener("click", i.current, {
          once: !0
        })) : l();
      }
      r.current = !1;
    }, a = window.setTimeout(() => {
      t.addEventListener("pointerdown", o);
    }, 0);
    return () => {
      window.clearTimeout(a), t.removeEventListener("pointerdown", o), t.removeEventListener("click", i.current);
    };
  }, [
    t,
    n
  ]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function ZV(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Bn(e), r = Ke(!1);
  return Ne(() => {
    const i = (o) => {
      o.target && !r.current && XE(FV, n, {
        originalEvent: o
      }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [
    t,
    n
  ]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function wb() {
  const e = new CustomEvent(hh);
  document.dispatchEvent(e);
}
function XE(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, o = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  t && i.addEventListener(e, t, {
    once: !0
  }), r ? pD(i, o) : i.dispatchEvent(o);
}
const Xf = "focusScope.autoFocusOnMount", Qf = "focusScope.autoFocusOnUnmount", xb = {
  bubbles: !1,
  cancelable: !0
}, VV = /* @__PURE__ */ Ue((e, t) => {
  const { loop: n = !1, trapped: r = !1, onMountAutoFocus: i, onUnmountAutoFocus: o, ...a } = e, [s, c] = Ve(null), l = Bn(i), u = Bn(o), d = Ke(null), p = ur(
    t,
    (m) => c(m)
  ), f = Ke({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  Ne(() => {
    if (r) {
      let m = function(b) {
        if (f.paused || !s)
          return;
        const _ = b.target;
        s.contains(_) ? d.current = _ : Ei(d.current, {
          select: !0
        });
      }, y = function(b) {
        if (f.paused || !s)
          return;
        const _ = b.relatedTarget;
        _ !== null && (s.contains(_) || Ei(d.current, {
          select: !0
        }));
      }, g = function(b) {
        const _ = document.activeElement;
        for (const S of b)
          S.removedNodes.length > 0 && (s != null && s.contains(_) || Ei(s));
      };
      document.addEventListener("focusin", m), document.addEventListener("focusout", y);
      const v = new MutationObserver(g);
      return s && v.observe(s, {
        childList: !0,
        subtree: !0
      }), () => {
        document.removeEventListener("focusin", m), document.removeEventListener("focusout", y), v.disconnect();
      };
    }
  }, [
    r,
    s,
    f.paused
  ]), Ne(() => {
    if (s) {
      Sb.add(f);
      const m = document.activeElement;
      if (!s.contains(m)) {
        const g = new CustomEvent(Xf, xb);
        s.addEventListener(Xf, l), s.dispatchEvent(g), g.defaultPrevented || (HV(GV(QE(s)), {
          select: !0
        }), document.activeElement === m && Ei(s));
      }
      return () => {
        s.removeEventListener(Xf, l), setTimeout(() => {
          const g = new CustomEvent(Qf, xb);
          s.addEventListener(Qf, u), s.dispatchEvent(g), g.defaultPrevented || Ei(m ?? document.body, {
            select: !0
          }), s.removeEventListener(Qf, u), Sb.remove(f);
        }, 0);
      };
    }
  }, [
    s,
    l,
    u,
    f
  ]);
  const h = an((m) => {
    if (!n && !r || f.paused)
      return;
    const y = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey, g = document.activeElement;
    if (y && g) {
      const v = m.currentTarget, [b, _] = WV(v);
      b && _ ? !m.shiftKey && g === _ ? (m.preventDefault(), n && Ei(b, {
        select: !0
      })) : m.shiftKey && g === b && (m.preventDefault(), n && Ei(_, {
        select: !0
      })) : g === v && m.preventDefault();
    }
  }, [
    n,
    r,
    f.paused
  ]);
  return /* @__PURE__ */ Me(Rn.div, vo({
    tabIndex: -1
  }, a, {
    ref: p,
    onKeyDown: h
  }));
});
function HV(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Ei(r, {
      select: t
    }), document.activeElement !== n)
      return;
}
function WV(e) {
  const t = QE(e), n = _b(t, e), r = _b(t.reverse(), e);
  return [
    n,
    r
  ];
}
function QE(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    t.push(n.currentNode);
  return t;
}
function _b(e, t) {
  for (const n of e)
    if (!KV(n, {
      upTo: t
    }))
      return n;
}
function KV(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  for (; e; ) {
    if (t !== void 0 && e === t)
      return !1;
    if (getComputedStyle(e).display === "none")
      return !0;
    e = e.parentElement;
  }
  return !1;
}
function JV(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Ei(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({
      preventScroll: !0
    }), e !== n && JV(e) && t && e.select();
  }
}
const Sb = YV();
function YV() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = kb(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = kb(e, t), (n = e[0]) === null || n === void 0 || n.resume();
    }
  };
}
function kb(e, t) {
  const n = [
    ...e
  ], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function GV(e) {
  return e.filter(
    (t) => t.tagName !== "A"
  );
}
function XV(e, t) {
  return $b((n, r) => {
    const i = t[n][r];
    return i ?? n;
  }, e);
}
const Yi = (e) => {
  const { present: t, children: n } = e, r = QV(t), i = typeof n == "function" ? n({
    present: r.isPresent
  }) : Go.only(n), o = ur(r.ref, i.ref);
  return typeof n == "function" || r.isPresent ? /* @__PURE__ */ Uu(i, {
    ref: o
  }) : null;
};
Yi.displayName = "Presence";
function QV(e) {
  const [t, n] = Ve(), r = Ke({}), i = Ke(e), o = Ke("none"), a = e ? "mounted" : "unmounted", [s, c] = XV(a, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return Ne(() => {
    const l = qc(r.current);
    o.current = s === "mounted" ? l : "none";
  }, [
    s
  ]), ha(() => {
    const l = r.current, u = i.current;
    if (u !== e) {
      const p = o.current, f = qc(l);
      e ? c("MOUNT") : f === "none" || (l == null ? void 0 : l.display) === "none" ? c("UNMOUNT") : c(u && p !== f ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [
    e,
    c
  ]), ha(() => {
    if (t) {
      const l = (d) => {
        const f = qc(r.current).includes(d.animationName);
        d.target === t && f && Db(
          () => c("ANIMATION_END")
        );
      }, u = (d) => {
        d.target === t && (o.current = qc(r.current));
      };
      return t.addEventListener("animationstart", u), t.addEventListener("animationcancel", l), t.addEventListener("animationend", l), () => {
        t.removeEventListener("animationstart", u), t.removeEventListener("animationcancel", l), t.removeEventListener("animationend", l);
      };
    } else
      c("ANIMATION_END");
  }, [
    t,
    c
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(s),
    ref: an((l) => {
      l && (r.current = getComputedStyle(l)), n(l);
    }, [])
  };
}
function qc(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
let ep = 0;
function eH() {
  Ne(() => {
    var e, t;
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (e = n[0]) !== null && e !== void 0 ? e : Eb()), document.body.insertAdjacentElement("beforeend", (t = n[1]) !== null && t !== void 0 ? t : Eb()), ep++, () => {
      ep === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(
        (r) => r.remove()
      ), ep--;
    };
  }, []);
}
function Eb() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e;
}
var Ur = function() {
  return Ur = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, Ur.apply(this, arguments);
};
function eC(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function tH(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = t.length, o; r < i; r++)
      (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), o[r] = t[r]);
  return e.concat(o || Array.prototype.slice.call(t));
}
var fl = "right-scroll-bar-position", pl = "width-before-scroll-bar", nH = "with-scroll-bars-hidden", rH = "--removed-body-scroll-bar-size";
function iH(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function oH(e, t) {
  var n = Ve(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
function aH(e, t) {
  return oH(t || null, function(n) {
    return e.forEach(function(r) {
      return iH(r, n);
    });
  });
}
function sH(e) {
  return e;
}
function cH(e, t) {
  t === void 0 && (t = sH);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(o) {
      var a = t(o, r);
      return n.push(a), function() {
        n = n.filter(function(s) {
          return s !== a;
        });
      };
    },
    assignSyncMedium: function(o) {
      for (r = !0; n.length; ) {
        var a = n;
        n = [], a.forEach(o);
      }
      n = {
        push: function(s) {
          return o(s);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(o) {
      r = !0;
      var a = [];
      if (n.length) {
        var s = n;
        n = [], s.forEach(o), a = n;
      }
      var c = function() {
        var u = a;
        a = [], u.forEach(o);
      }, l = function() {
        return Promise.resolve().then(c);
      };
      l(), n = {
        push: function(u) {
          a.push(u), l();
        },
        filter: function(u) {
          return a = a.filter(u), n;
        }
      };
    }
  };
  return i;
}
function lH(e) {
  e === void 0 && (e = {});
  var t = cH(null);
  return t.options = Ur({ async: !0, ssr: !1 }, e), t;
}
var tC = function(e) {
  var t = e.sideCar, n = eC(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return D.createElement(r, Ur({}, n));
};
tC.isSideCarExport = !0;
function uH(e, t) {
  return e.useMedium(t), tC;
}
var nC = lH(), tp = function() {
}, Gd = D.forwardRef(function(e, t) {
  var n = D.useRef(null), r = D.useState({
    onScrollCapture: tp,
    onWheelCapture: tp,
    onTouchMoveCapture: tp
  }), i = r[0], o = r[1], a = e.forwardProps, s = e.children, c = e.className, l = e.removeScrollBar, u = e.enabled, d = e.shards, p = e.sideCar, f = e.noIsolation, h = e.inert, m = e.allowPinchZoom, y = e.as, g = y === void 0 ? "div" : y, v = eC(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), b = p, _ = aH([n, t]), S = Ur(Ur({}, v), i);
  return D.createElement(
    D.Fragment,
    null,
    u && D.createElement(b, { sideCar: nC, removeScrollBar: l, shards: d, noIsolation: f, inert: h, setCallbacks: o, allowPinchZoom: !!m, lockRef: n }),
    a ? D.cloneElement(D.Children.only(s), Ur(Ur({}, S), { ref: _ })) : D.createElement(g, Ur({}, S, { className: c, ref: _ }), s)
  );
});
Gd.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Gd.classNames = {
  fullWidth: pl,
  zeroRight: fl
};
var Cb, dH = function() {
  if (Cb)
    return Cb;
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function fH() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = dH();
  return t && e.setAttribute("nonce", t), e;
}
function pH(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function hH(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var mH = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = fH()) && (pH(t, n), hH(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, yH = function() {
  var e = mH();
  return function(t, n) {
    D.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, rC = function() {
  var e = yH(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, gH = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, np = function(e) {
  return parseInt(e || "", 10) || 0;
}, vH = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [np(n), np(r), np(i)];
}, bH = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return gH;
  var t = vH(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, wH = rC(), xH = function(e, t, n, r) {
  var i = e.left, o = e.top, a = e.right, s = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(nH, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(s, "px ").concat(r, `;
  }
  body {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(o, `px;
    padding-right: `).concat(a, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(s, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(fl, ` {
    right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(pl, ` {
    margin-right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(fl, " .").concat(fl, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(pl, " .").concat(pl, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body {
    `).concat(rH, ": ").concat(s, `px;
  }
`);
}, _H = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r, o = D.useMemo(function() {
    return bH(i);
  }, [i]);
  return D.createElement(wH, { styles: xH(o, !t, i, n ? "" : "!important") });
}, mh = !1;
if (typeof window < "u")
  try {
    var Lc = Object.defineProperty({}, "passive", {
      get: function() {
        return mh = !0, !0;
      }
    });
    window.addEventListener("test", Lc, Lc), window.removeEventListener("test", Lc, Lc);
  } catch {
    mh = !1;
  }
var Lo = mh ? { passive: !1 } : !1, SH = function(e) {
  return e.tagName === "TEXTAREA";
}, iC = function(e, t) {
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !SH(e) && n[t] === "visible")
  );
}, kH = function(e) {
  return iC(e, "overflowY");
}, EH = function(e) {
  return iC(e, "overflowX");
}, Tb = function(e, t) {
  var n = t;
  do {
    typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
    var r = oC(e, n);
    if (r) {
      var i = aC(e, n), o = i[1], a = i[2];
      if (o > a)
        return !0;
    }
    n = n.parentNode;
  } while (n && n !== document.body);
  return !1;
}, CH = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, TH = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, oC = function(e, t) {
  return e === "v" ? kH(t) : EH(t);
}, aC = function(e, t) {
  return e === "v" ? CH(t) : TH(t);
}, RH = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, AH = function(e, t, n, r, i) {
  var o = RH(e, window.getComputedStyle(t).direction), a = o * r, s = n.target, c = t.contains(s), l = !1, u = a > 0, d = 0, p = 0;
  do {
    var f = aC(e, s), h = f[0], m = f[1], y = f[2], g = m - y - o * h;
    (h || g) && oC(e, s) && (d += g, p += h), s = s.parentNode;
  } while (
    // portaled content
    !c && s !== document.body || // self content
    c && (t.contains(s) || t === s)
  );
  return (u && (i && d === 0 || !i && a > d) || !u && (i && p === 0 || !i && -a > p)) && (l = !0), l;
}, Fc = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, Rb = function(e) {
  return [e.deltaX, e.deltaY];
}, Ab = function(e) {
  return e && "current" in e ? e.current : e;
}, OH = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, IH = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, PH = 0, Fo = [];
function $H(e) {
  var t = D.useRef([]), n = D.useRef([0, 0]), r = D.useRef(), i = D.useState(PH++)[0], o = D.useState(function() {
    return rC();
  })[0], a = D.useRef(e);
  D.useEffect(function() {
    a.current = e;
  }, [e]), D.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var m = tH([e.lockRef.current], (e.shards || []).map(Ab), !0).filter(Boolean);
      return m.forEach(function(y) {
        return y.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), m.forEach(function(y) {
          return y.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var s = D.useCallback(function(m, y) {
    if ("touches" in m && m.touches.length === 2)
      return !a.current.allowPinchZoom;
    var g = Fc(m), v = n.current, b = "deltaX" in m ? m.deltaX : v[0] - g[0], _ = "deltaY" in m ? m.deltaY : v[1] - g[1], S, x = m.target, A = Math.abs(b) > Math.abs(_) ? "h" : "v";
    if ("touches" in m && A === "h" && x.type === "range")
      return !1;
    var I = Tb(A, x);
    if (!I)
      return !0;
    if (I ? S = A : (S = A === "v" ? "h" : "v", I = Tb(A, x)), !I)
      return !1;
    if (!r.current && "changedTouches" in m && (b || _) && (r.current = S), !S)
      return !0;
    var P = r.current || S;
    return AH(P, y, m, P === "h" ? b : _, !0);
  }, []), c = D.useCallback(function(m) {
    var y = m;
    if (!(!Fo.length || Fo[Fo.length - 1] !== o)) {
      var g = "deltaY" in y ? Rb(y) : Fc(y), v = t.current.filter(function(S) {
        return S.name === y.type && S.target === y.target && OH(S.delta, g);
      })[0];
      if (v && v.should) {
        y.cancelable && y.preventDefault();
        return;
      }
      if (!v) {
        var b = (a.current.shards || []).map(Ab).filter(Boolean).filter(function(S) {
          return S.contains(y.target);
        }), _ = b.length > 0 ? s(y, b[0]) : !a.current.noIsolation;
        _ && y.cancelable && y.preventDefault();
      }
    }
  }, []), l = D.useCallback(function(m, y, g, v) {
    var b = { name: m, delta: y, target: g, should: v };
    t.current.push(b), setTimeout(function() {
      t.current = t.current.filter(function(_) {
        return _ !== b;
      });
    }, 1);
  }, []), u = D.useCallback(function(m) {
    n.current = Fc(m), r.current = void 0;
  }, []), d = D.useCallback(function(m) {
    l(m.type, Rb(m), m.target, s(m, e.lockRef.current));
  }, []), p = D.useCallback(function(m) {
    l(m.type, Fc(m), m.target, s(m, e.lockRef.current));
  }, []);
  D.useEffect(function() {
    return Fo.push(o), e.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", c, Lo), document.addEventListener("touchmove", c, Lo), document.addEventListener("touchstart", u, Lo), function() {
      Fo = Fo.filter(function(m) {
        return m !== o;
      }), document.removeEventListener("wheel", c, Lo), document.removeEventListener("touchmove", c, Lo), document.removeEventListener("touchstart", u, Lo);
    };
  }, []);
  var f = e.removeScrollBar, h = e.inert;
  return D.createElement(
    D.Fragment,
    null,
    h ? D.createElement(o, { styles: IH(i) }) : null,
    f ? D.createElement(_H, { gapMode: "margin" }) : null
  );
}
const DH = uH(nC, $H);
var sC = D.forwardRef(function(e, t) {
  return D.createElement(Gd, Ur({}, e, { ref: t, sideCar: DH }));
});
sC.classNames = Gd.classNames;
const NH = sC;
var jH = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Uo = /* @__PURE__ */ new WeakMap(), Uc = /* @__PURE__ */ new WeakMap(), Bc = {}, rp = 0, cC = function(e) {
  return e && (e.host || cC(e.parentNode));
}, MH = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = cC(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, qH = function(e, t, n, r) {
  var i = MH(t, Array.isArray(e) ? e : [e]);
  Bc[n] || (Bc[n] = /* @__PURE__ */ new WeakMap());
  var o = Bc[n], a = [], s = /* @__PURE__ */ new Set(), c = new Set(i), l = function(d) {
    !d || s.has(d) || (s.add(d), l(d.parentNode));
  };
  i.forEach(l);
  var u = function(d) {
    !d || c.has(d) || Array.prototype.forEach.call(d.children, function(p) {
      if (s.has(p))
        u(p);
      else {
        var f = p.getAttribute(r), h = f !== null && f !== "false", m = (Uo.get(p) || 0) + 1, y = (o.get(p) || 0) + 1;
        Uo.set(p, m), o.set(p, y), a.push(p), m === 1 && h && Uc.set(p, !0), y === 1 && p.setAttribute(n, "true"), h || p.setAttribute(r, "true");
      }
    });
  };
  return u(t), s.clear(), rp++, function() {
    a.forEach(function(d) {
      var p = Uo.get(d) - 1, f = o.get(d) - 1;
      Uo.set(d, p), o.set(d, f), p || (Uc.has(d) || d.removeAttribute(r), Uc.delete(d)), f || d.removeAttribute(n);
    }), rp--, rp || (Uo = /* @__PURE__ */ new WeakMap(), Uo = /* @__PURE__ */ new WeakMap(), Uc = /* @__PURE__ */ new WeakMap(), Bc = {});
  };
}, LH = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = t || jH(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), qH(r, i, n, "aria-hidden")) : function() {
    return null;
  };
};
const lC = "Dialog", [uC, dJ] = yd(lC), [FH, bi] = uC(lC), UH = (e) => {
  const { __scopeDialog: t, children: n, open: r, defaultOpen: i, onOpenChange: o, modal: a = !0 } = e, s = Ke(null), c = Ke(null), [l = !1, u] = GE({
    prop: r,
    defaultProp: i,
    onChange: o
  });
  return /* @__PURE__ */ Me(FH, {
    scope: t,
    triggerRef: s,
    contentRef: c,
    contentId: dl(),
    titleId: dl(),
    descriptionId: dl(),
    open: l,
    onOpenChange: u,
    onOpenToggle: an(
      () => u(
        (d) => !d
      ),
      [
        u
      ]
    ),
    modal: a
  }, n);
}, BH = "DialogTrigger", zH = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeDialog: n, ...r } = e, i = bi(BH, n), o = ur(t, i.triggerRef);
  return /* @__PURE__ */ Me(Rn.button, bt({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": i.open,
    "aria-controls": i.contentId,
    "data-state": py(i.open)
  }, r, {
    ref: o,
    onClick: Nn(e.onClick, i.onOpenToggle)
  }));
}), ZH = "DialogPortal", [fJ, dC] = uC(ZH, {
  forceMount: void 0
}), yh = "DialogOverlay", VH = /* @__PURE__ */ Ue((e, t) => {
  const n = dC(yh, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = bi(yh, e.__scopeDialog);
  return o.modal ? /* @__PURE__ */ Me(Yi, {
    present: r || o.open
  }, /* @__PURE__ */ Me(HH, bt({}, i, {
    ref: t
  }))) : null;
}), HH = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeDialog: n, ...r } = e, i = bi(yh, n);
  return (
    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    /* @__PURE__ */ Me(NH, {
      as: pm,
      allowPinchZoom: !0,
      shards: [
        i.contentRef
      ]
    }, /* @__PURE__ */ Me(Rn.div, bt({
      "data-state": py(i.open)
    }, r, {
      ref: t,
      style: {
        pointerEvents: "auto",
        ...r.style
      }
    })))
  );
}), qs = "DialogContent", WH = /* @__PURE__ */ Ue((e, t) => {
  const n = dC(qs, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = bi(qs, e.__scopeDialog);
  return /* @__PURE__ */ Me(Yi, {
    present: r || o.open
  }, o.modal ? /* @__PURE__ */ Me(KH, bt({}, i, {
    ref: t
  })) : /* @__PURE__ */ Me(JH, bt({}, i, {
    ref: t
  })));
}), KH = /* @__PURE__ */ Ue((e, t) => {
  const n = bi(qs, e.__scopeDialog), r = Ke(null), i = ur(t, n.contentRef, r);
  return Ne(() => {
    const o = r.current;
    if (o)
      return LH(o);
  }, []), /* @__PURE__ */ Me(fC, bt({}, e, {
    ref: i,
    trapFocus: n.open,
    disableOutsidePointerEvents: !0,
    onCloseAutoFocus: Nn(e.onCloseAutoFocus, (o) => {
      var a;
      o.preventDefault(), (a = n.triggerRef.current) === null || a === void 0 || a.focus();
    }),
    onPointerDownOutside: Nn(e.onPointerDownOutside, (o) => {
      const a = o.detail.originalEvent, s = a.button === 0 && a.ctrlKey === !0;
      (a.button === 2 || s) && o.preventDefault();
    }),
    onFocusOutside: Nn(
      e.onFocusOutside,
      (o) => o.preventDefault()
    )
  }));
}), JH = /* @__PURE__ */ Ue((e, t) => {
  const n = bi(qs, e.__scopeDialog), r = Ke(!1), i = Ke(!1);
  return /* @__PURE__ */ Me(fC, bt({}, e, {
    ref: t,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    onCloseAutoFocus: (o) => {
      var a;
      if ((a = e.onCloseAutoFocus) === null || a === void 0 || a.call(e, o), !o.defaultPrevented) {
        var s;
        r.current || (s = n.triggerRef.current) === null || s === void 0 || s.focus(), o.preventDefault();
      }
      r.current = !1, i.current = !1;
    },
    onInteractOutside: (o) => {
      var a, s;
      (a = e.onInteractOutside) === null || a === void 0 || a.call(e, o), o.defaultPrevented || (r.current = !0, o.detail.originalEvent.type === "pointerdown" && (i.current = !0));
      const c = o.target;
      ((s = n.triggerRef.current) === null || s === void 0 ? void 0 : s.contains(c)) && o.preventDefault(), o.detail.originalEvent.type === "focusin" && i.current && o.preventDefault();
    }
  }));
}), fC = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: o, ...a } = e, s = bi(qs, n), c = Ke(null), l = ur(t, c);
  return eH(), /* @__PURE__ */ Me($i, null, /* @__PURE__ */ Me(VV, {
    asChild: !0,
    loop: !0,
    trapped: r,
    onMountAutoFocus: i,
    onUnmountAutoFocus: o
  }, /* @__PURE__ */ Me(BV, bt({
    role: "dialog",
    id: s.contentId,
    "aria-describedby": s.descriptionId,
    "aria-labelledby": s.titleId,
    "data-state": py(s.open)
  }, a, {
    ref: l,
    onDismiss: () => s.onOpenChange(!1)
  }))), !1);
}), YH = "DialogTitle", GH = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeDialog: n, ...r } = e, i = bi(YH, n);
  return /* @__PURE__ */ Me(Rn.h2, bt({
    id: i.titleId
  }, r, {
    ref: t
  }));
}), XH = "DialogClose", QH = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeDialog: n, ...r } = e, i = bi(XH, n);
  return /* @__PURE__ */ Me(Rn.button, bt({
    type: "button"
  }, r, {
    ref: t,
    onClick: Nn(
      e.onClick,
      () => i.onOpenChange(!1)
    )
  }));
});
function py(e) {
  return e ? "open" : "closed";
}
const eW = UH, tW = zH, nW = VH, rW = WH, iW = GH, pC = QH;
function oW({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ D.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ D.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ D.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M6 18L18 6M6 6l12 12"
  }));
}
const aW = D.forwardRef(oW), hC = aW;
function Ro({
  open: e,
  onOpenChange: t,
  children: n
}) {
  return /* @__PURE__ */ F.jsx(eW, { open: e, onOpenChange: t, children: n });
}
function sW({ title: e, children: t }) {
  var r, i, o, a, s, c, l, u;
  const { modal: n } = Ie((d) => d.theme);
  return /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
    /* @__PURE__ */ F.jsx(nW, { ...n == null ? void 0 : n.overlay }),
    /* @__PURE__ */ F.jsx("div", { ...n == null ? void 0 : n.container, children: /* @__PURE__ */ F.jsxs(rW, { ...(r = n == null ? void 0 : n.dialog) == null ? void 0 : r.container, children: [
      /* @__PURE__ */ F.jsxs("div", { ...(o = (i = n == null ? void 0 : n.dialog) == null ? void 0 : i.title) == null ? void 0 : o.container, children: [
        /* @__PURE__ */ F.jsx(iW, { ...(s = (a = n == null ? void 0 : n.dialog) == null ? void 0 : a.title) == null ? void 0 : s.text, children: e }),
        /* @__PURE__ */ F.jsx(pC, { children: /* @__PURE__ */ F.jsx(hC, { role: "button", tabIndex: 0, ...(l = (c = n == null ? void 0 : n.dialog) == null ? void 0 : c.title) == null ? void 0 : l.closeIcon }) })
      ] }),
      /* @__PURE__ */ F.jsx("div", { ...(u = n == null ? void 0 : n.dialog) == null ? void 0 : u.content, children: t })
    ] }) })
  ] });
}
Ro.Button = tW;
Ro.Close = pC;
Ro.Content = sW;
const cW = Ue(({ children: e, ...t }, n) => {
  const { container: r } = Ie((i) => i.theme);
  return /* @__PURE__ */ F.jsxs("div", { ...t, ...r, ref: n, children: [
    /* @__PURE__ */ F.jsx(mZ, {}),
    /* @__PURE__ */ F.jsxs($V, { children: [
      /* @__PURE__ */ F.jsx(lW, {}),
      e
    ] })
  ] });
}), lW = () => {
  const { modal: e } = Ie((r) => r.theme), t = Ie((r) => r.connected), { showModal: n } = bE();
  return Ne(() => {
    var r, i, o, a;
    t || n({
      title: "Connection Error",
      content: /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
        /* @__PURE__ */ F.jsx("p", { ...(i = (r = e == null ? void 0 : e.dialog) == null ? void 0 : r.newConversation) == null ? void 0 : i.text, children: "There was an error connecting to the server. Please check your internet connection and try again." }),
        /* @__PURE__ */ F.jsx(Ro.Close, { asChild: !0, children: /* @__PURE__ */ F.jsx(
          "button",
          {
            type: "button",
            ...(a = (o = e == null ? void 0 : e.dialog) == null ? void 0 : o.newConversation) == null ? void 0 : a.button,
            onClick: () => window.location.reload(),
            children: "Restart"
          }
        ) })
      ] })
    });
  }, [t]), /* @__PURE__ */ F.jsx(F.Fragment, {});
}, pJ = Ue(({ children: e, onClick: t, ...n }, r) => {
  const { fab: i } = Ie((s) => s.theme), { container: o, icon: a } = i ?? {};
  return /* @__PURE__ */ F.jsx("div", { ...n, ...o, ref: r, onClick: t, children: /* @__PURE__ */ F.jsx("div", { ...a }) });
}), mC = "Collapsible", [uW, hJ] = yd(mC), [dW, hy] = uW(mC), fW = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeCollapsible: n, open: r, defaultOpen: i, disabled: o, onOpenChange: a, ...s } = e, [c = !1, l] = GE({
    prop: r,
    defaultProp: i,
    onChange: a
  });
  return /* @__PURE__ */ Me(dW, {
    scope: n,
    disabled: o,
    contentId: dl(),
    open: c,
    onOpenToggle: an(
      () => l(
        (u) => !u
      ),
      [
        l
      ]
    )
  }, /* @__PURE__ */ Me(Rn.div, bt({
    "data-state": my(c),
    "data-disabled": o ? "" : void 0
  }, s, {
    ref: t
  })));
}), pW = "CollapsibleTrigger", hW = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeCollapsible: n, ...r } = e, i = hy(pW, n);
  return /* @__PURE__ */ Me(Rn.button, bt({
    type: "button",
    "aria-controls": i.contentId,
    "aria-expanded": i.open || !1,
    "data-state": my(i.open),
    "data-disabled": i.disabled ? "" : void 0,
    disabled: i.disabled
  }, r, {
    ref: t,
    onClick: Nn(e.onClick, i.onOpenToggle)
  }));
}), yC = "CollapsibleContent", mW = /* @__PURE__ */ Ue((e, t) => {
  const { forceMount: n, ...r } = e, i = hy(yC, e.__scopeCollapsible);
  return /* @__PURE__ */ Me(
    Yi,
    {
      present: n || i.open
    },
    ({ present: o }) => /* @__PURE__ */ Me(yW, bt({}, r, {
      ref: t,
      present: o
    }))
  );
}), yW = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeCollapsible: n, present: r, children: i, ...o } = e, a = hy(yC, n), [s, c] = Ve(r), l = Ke(null), u = ur(t, l), d = Ke(0), p = d.current, f = Ke(0), h = f.current, m = a.open || s, y = Ke(m), g = Ke();
  return Ne(() => {
    const v = requestAnimationFrame(
      () => y.current = !1
    );
    return () => cancelAnimationFrame(v);
  }, []), ha(() => {
    const v = l.current;
    if (v) {
      g.current = g.current || {
        transitionDuration: v.style.transitionDuration,
        animationName: v.style.animationName
      }, v.style.transitionDuration = "0s", v.style.animationName = "none";
      const b = v.getBoundingClientRect();
      d.current = b.height, f.current = b.width, y.current || (v.style.transitionDuration = g.current.transitionDuration, v.style.animationName = g.current.animationName), c(r);
    }
  }, [
    a.open,
    r
  ]), /* @__PURE__ */ Me(Rn.div, bt({
    "data-state": my(a.open),
    "data-disabled": a.disabled ? "" : void 0,
    id: a.contentId,
    hidden: !m
  }, o, {
    ref: u,
    style: {
      "--radix-collapsible-content-height": p ? `${p}px` : void 0,
      "--radix-collapsible-content-width": h ? `${h}px` : void 0,
      ...e.style
    }
  }), m && i);
});
function my(e) {
  return e ? "open" : "closed";
}
const gW = fW, vW = hW, bW = mW, wW = (e) => /* @__PURE__ */ D.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", viewBox: "0 0 16 16", ...e }, /* @__PURE__ */ D.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "M15.5 5.5v-5m0 0h-5m5 0L8.833 7.167m-2.5-5H4.5c-1.4 0-2.1 0-2.635.272A2.5 2.5 0 0 0 .772 3.532C.5 4.066.5 4.767.5 6.167V11.5c0 1.4 0 2.1.272 2.635a2.5 2.5 0 0 0 1.093 1.092C2.4 15.5 3.1 15.5 4.5 15.5h5.333c1.4 0 2.1 0 2.635-.273a2.5 2.5 0 0 0 1.093-1.092c.272-.535.272-1.235.272-2.635V9.667" })), xW = ({ ...e }) => {
  var a, s;
  const { header: t, modal: n } = Ie((c) => c.theme), r = Ie((c) => c.restartConversation), { showModal: i } = bE(), o = (c) => {
    var l, u, d, p;
    c.stopPropagation(), i({
      title: "Restart Conversation",
      content: /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
        /* @__PURE__ */ F.jsx("p", { ...(u = (l = n == null ? void 0 : n.dialog) == null ? void 0 : l.newConversation) == null ? void 0 : u.text, children: "Are you sure you want to restart a new conversation?" }),
        /* @__PURE__ */ F.jsx(Ro.Close, { asChild: !0, children: /* @__PURE__ */ F.jsx("button", { type: "button", ...(p = (d = n == null ? void 0 : n.dialog) == null ? void 0 : d.newConversation) == null ? void 0 : p.button, onClick: r, children: "Restart" }) })
      ] })
    });
  };
  return /* @__PURE__ */ F.jsx(
    P7,
    {
      ...e,
      ...(s = (a = t == null ? void 0 : t.content) == null ? void 0 : a.actions) == null ? void 0 : s.icons,
      role: "button",
      tabIndex: 0,
      onClick: o,
      onKeyDown: (c) => {
        c.key === "Enter" && o(c);
      }
    }
  );
}, _W = ({ ...e }) => {
  var i, o;
  const { header: t } = Ie((a) => a.theme), n = Ie((a) => a.closeWindow), r = (a) => {
    a.stopPropagation(), n == null || n();
  };
  return /* @__PURE__ */ F.jsx(
    hC,
    {
      ...e,
      ...(o = (i = t == null ? void 0 : t.content) == null ? void 0 : i.actions) == null ? void 0 : o.icons,
      role: "button",
      tabIndex: 0,
      onClick: r,
      onKeyDown: (a) => {
        a.key === "Enter" && r(a);
      }
    }
  );
}, SW = Ao(
  Ue(({ defaultOpen: e, ...t }, n) => {
    const { header: r } = Ie((a) => a.theme), [i, o] = Ve(!!e);
    return /* @__PURE__ */ F.jsx(gW, { open: i, onOpenChange: o, ...t, ...r == null ? void 0 : r.container, ref: n });
  })
), kW = Ue((e, t) => {
  var r;
  const { header: n } = Ie((i) => i.theme);
  return /* @__PURE__ */ F.jsx(vW, { ...e, ...(r = n == null ? void 0 : n.content) == null ? void 0 : r.container, ref: t });
}), EW = Ue((e, t) => {
  var r;
  const { header: n } = Ie((i) => i.theme);
  return /* @__PURE__ */ F.jsx(bW, { ...e, ...(r = n == null ? void 0 : n.expandedContent) == null ? void 0 : r.container, ref: t });
}), CW = Ue(({ src: e, ...t }, n) => {
  var o;
  const { header: r } = Ie((a) => a.theme), i = Ie((a) => a.getClientId)();
  return /* @__PURE__ */ F.jsx(T1, { ...t, ref: n, userId: i, src: e, ...(o = r == null ? void 0 : r.content) == null ? void 0 : o.avatar });
}), TW = Ue((e, t) => {
  var r;
  const { header: n } = Ie((i) => i.theme);
  return /* @__PURE__ */ F.jsx("h2", { ...e, ...(r = n == null ? void 0 : n.content) == null ? void 0 : r.title, ref: t });
}), RW = Ue((e, t) => {
  var r;
  const { header: n } = Ie((i) => i.theme);
  return /* @__PURE__ */ F.jsx("p", { ...e, ...(r = n == null ? void 0 : n.content) == null ? void 0 : r.description, ref: t });
}), AW = Ue((e, t) => {
  var r, i;
  const { header: n } = Ie((o) => o.theme);
  return /* @__PURE__ */ F.jsx("div", { ...e, ...(i = (r = n == null ? void 0 : n.content) == null ? void 0 : r.actions) == null ? void 0 : i.container, ref: t });
}), OW = ({ icon: e, title: t, link: n, ...r }) => {
  var s, c, l, u, d, p, f, h, m, y, g, v;
  const { header: i } = Ie((b) => b.theme), o = e ?? wW, a = (b) => {
    b && k6(b);
  };
  return !n && !t ? null : n ? /* @__PURE__ */ F.jsxs(
    "a",
    {
      ...r,
      ...(c = (s = i == null ? void 0 : i.expandedContent) == null ? void 0 : s.descriptionItems) == null ? void 0 : c.container,
      href: n,
      target: "_blank",
      rel: "noreferrer noopener",
      children: [
        /* @__PURE__ */ F.jsx(o, { ...(u = (l = i == null ? void 0 : i.expandedContent) == null ? void 0 : l.descriptionItems) == null ? void 0 : u.icon }),
        /* @__PURE__ */ F.jsx("p", { ...(p = (d = i == null ? void 0 : i.expandedContent) == null ? void 0 : d.descriptionItems) == null ? void 0 : p.link, children: t })
      ]
    }
  ) : /* @__PURE__ */ F.jsxs(
    "div",
    {
      ...r,
      ...(h = (f = i == null ? void 0 : i.expandedContent) == null ? void 0 : f.descriptionItems) == null ? void 0 : h.container,
      onClick: (b) => {
        a(b.currentTarget.textContent);
      },
      children: [
        /* @__PURE__ */ F.jsx(o, { ...(y = (m = i == null ? void 0 : i.expandedContent) == null ? void 0 : m.descriptionItems) == null ? void 0 : y.icon }),
        /* @__PURE__ */ F.jsx("p", { ...(v = (g = i == null ? void 0 : i.expandedContent) == null ? void 0 : g.descriptionItems) == null ? void 0 : v.text, children: t })
      ]
    }
  );
}, rr = Object.assign(SW, {
  Content: kW,
  ExpandedContent: EW,
  Avatar: CW,
  Description: RW,
  Title: TW,
  Actions: AW,
  DescriptionItem: OW
}), IW = () => {
  var o, a, s, c, l, u, d, p, f, h, m, y, g, v, b, _, S, x, A;
  const { header: e } = Ie((I) => I.theme), t = Ie((I) => I.configuration), n = Ie((I) => I.closeWindow), r = Ie((I) => !I.disableRestartConversation), i = !!((o = t.email) != null && o.title) || !!((a = t.phone) != null && a.title) || !!((s = t.website) != null && s.title) || !!((c = t.termsOfService) != null && c.link) || !!((l = t.privacyPolicy) != null && l.link);
  return /* @__PURE__ */ F.jsxs(rr, { open: i ? void 0 : !1, "data-disabled": i ? void 0 : "", children: [
    /* @__PURE__ */ F.jsxs(rr.Content, { children: [
      /* @__PURE__ */ F.jsx(rr.Avatar, { src: t.botAvatar, children: t.botName || "Bot" }),
      /* @__PURE__ */ F.jsx(rr.Title, { children: t.botName || "Bot" }),
      t.botDescription && /* @__PURE__ */ F.jsx(rr.Description, { children: t.botDescription }),
      /* @__PURE__ */ F.jsxs(rr.Actions, { children: [
        r && /* @__PURE__ */ F.jsx(xW, {}),
        n && /* @__PURE__ */ F.jsx(_W, {})
      ] })
    ] }),
    /* @__PURE__ */ F.jsxs(rr.ExpandedContent, { children: [
      /* @__PURE__ */ F.jsxs("div", { "data-links": "", ...(u = e == null ? void 0 : e.expandedContent) == null ? void 0 : u.group, children: [
        /* @__PURE__ */ F.jsx(
          rr.DescriptionItem,
          {
            "data-email": "",
            icon: L9,
            title: (d = t.email) == null ? void 0 : d.title,
            link: (p = t.email) == null ? void 0 : p.link
          }
        ),
        /* @__PURE__ */ F.jsx(
          rr.DescriptionItem,
          {
            "data-phone": "",
            icon: K9,
            title: (f = t.phone) == null ? void 0 : f.title,
            link: (h = t.phone) == null ? void 0 : h.link
          }
        ),
        /* @__PURE__ */ F.jsx(
          rr.DescriptionItem,
          {
            "data-website": "",
            link: (m = t.website) == null ? void 0 : m.link,
            icon: B9,
            title: (y = t.website) == null ? void 0 : y.title
          }
        )
      ] }),
      /* @__PURE__ */ F.jsxs("div", { "data-legal": "", ...(g = e == null ? void 0 : e.expandedContent) == null ? void 0 : g.group, children: [
        /* @__PURE__ */ F.jsx(
          rr.DescriptionItem,
          {
            "data-terms": "",
            link: (v = t.termsOfService) == null ? void 0 : v.link,
            icon: j9,
            title: (b = t.termsOfService) == null ? void 0 : b.title
          }
        ),
        /* @__PURE__ */ F.jsx(
          rr.DescriptionItem,
          {
            "data-privacy": "",
            link: (_ = t.privacyPolicy) == null ? void 0 : _.link,
            icon: V9,
            title: (S = t.privacyPolicy) == null ? void 0 : S.title
          }
        )
      ] }),
      /* @__PURE__ */ F.jsx("div", { ...(A = (x = e == null ? void 0 : e.expandedContent) == null ? void 0 : x.descriptionItems) == null ? void 0 : A.poweredBy, children: " by Botpress" })
    ] })
  ] });
}, mJ = rr, PW = Ao(({ ...e }) => {
  const { loadingIndicator: t } = Ie((n) => n.theme);
  return /* @__PURE__ */ F.jsx("div", { ...e, ...t == null ? void 0 : t.container, children: /* @__PURE__ */ F.jsx("div", { ...t == null ? void 0 : t.loader }) });
}), Ob = Ue(
  ({ direction: e, block: t, scroll: n, disableInput: r, children: i, sender: o, ...a }, s) => {
    var m, y, g, v;
    const [c, l] = Ve([]), { message: u } = Ie((b) => b.theme), { botAvatar: d, botName: p } = Ie((b) => b.configuration), f = Ie((b) => b.getClientId)();
    YZ(() => {
      n();
    }), Ne(() => {
      c.length === 0 && n();
    }, [c.length]);
    const h = C1(f ?? "", 15);
    return /* @__PURE__ */ F.jsx(gE.Provider, { value: { isLoading: c, setIsLoading: l }, children: /* @__PURE__ */ F.jsxs(
      "div",
      {
        ...a,
        ...u == null ? void 0 : u.container,
        "data-loaded": c.length === 0,
        "data-disable-input": !!r,
        "data-direction": e,
        ref: s,
        children: [
          /* @__PURE__ */ F.jsxs(S1, { "data-color": h, ...(m = u == null ? void 0 : u.avatar) == null ? void 0 : m.container, children: [
            /* @__PURE__ */ F.jsx(k1, { ...(y = u == null ? void 0 : u.avatar) == null ? void 0 : y.image, src: (o == null ? void 0 : o.avatar) ?? d }),
            /* @__PURE__ */ F.jsx(E1, { ...(g = u == null ? void 0 : u.avatar) == null ? void 0 : g.fallback, children: (o == null ? void 0 : o.name[0]) ?? ((v = p ?? "Bot") == null ? void 0 : v[0]) })
          ] }),
          t && /* @__PURE__ */ F.jsx(yc, { block: t, styles: u == null ? void 0 : u.blocks }),
          i
        ]
      }
    ) });
  }
), $W = /* @__PURE__ */ gr(void 0);
function DW(e) {
  const t = Ir($W);
  return e || t || "ltr";
}
function NW(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
function jW(e, t) {
  return $b((n, r) => {
    const i = t[n][r];
    return i ?? n;
  }, e);
}
const gC = "ScrollArea", [vC, yJ] = yd(gC), [MW, wr] = vC(gC), qW = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeScrollArea: n, type: r = "hover", dir: i, scrollHideDelay: o = 600, ...a } = e, [s, c] = Ve(null), [l, u] = Ve(null), [d, p] = Ve(null), [f, h] = Ve(null), [m, y] = Ve(null), [g, v] = Ve(0), [b, _] = Ve(0), [S, x] = Ve(!1), [A, I] = Ve(!1), P = ur(
    t,
    (M) => c(M)
  ), R = DW(i);
  return /* @__PURE__ */ Me(MW, {
    scope: n,
    type: r,
    dir: R,
    scrollHideDelay: o,
    scrollArea: s,
    viewport: l,
    onViewportChange: u,
    content: d,
    onContentChange: p,
    scrollbarX: f,
    onScrollbarXChange: h,
    scrollbarXEnabled: S,
    onScrollbarXEnabledChange: x,
    scrollbarY: m,
    onScrollbarYChange: y,
    scrollbarYEnabled: A,
    onScrollbarYEnabledChange: I,
    onCornerWidthChange: v,
    onCornerHeightChange: _
  }, /* @__PURE__ */ Me(Rn.div, bt({
    dir: R
  }, a, {
    ref: P,
    style: {
      position: "relative",
      // Pass corner sizes as CSS vars to reduce re-renders of context consumers
      "--radix-scroll-area-corner-width": g + "px",
      "--radix-scroll-area-corner-height": b + "px",
      ...e.style
    }
  })));
}), LW = "ScrollAreaViewport", FW = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeScrollArea: n, children: r, ...i } = e, o = wr(LW, n), a = Ke(null), s = ur(t, a, o.onViewportChange);
  return /* @__PURE__ */ Me($i, null, /* @__PURE__ */ Me("style", {
    dangerouslySetInnerHTML: {
      __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
    }
  }), /* @__PURE__ */ Me(Rn.div, bt({
    "data-radix-scroll-area-viewport": ""
  }, i, {
    ref: s,
    style: {
      /**
      * We don't support `visible` because the intention is to have at least one scrollbar
      * if this component is used and `visible` will behave like `auto` in that case
      * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
      *
      * We don't handle `auto` because the intention is for the native implementation
      * to be hidden if using this component. We just want to ensure the node is scrollable
      * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
      * the browser from having to work out whether to render native scrollbars or not,
      * we tell it to with the intention of hiding them in CSS.
      */
      overflowX: o.scrollbarXEnabled ? "scroll" : "hidden",
      overflowY: o.scrollbarYEnabled ? "scroll" : "hidden",
      ...e.style
    }
  }), /* @__PURE__ */ Me("div", {
    ref: o.onContentChange,
    style: {
      minWidth: "100%",
      display: "table"
    }
  }, r)));
}), wi = "ScrollAreaScrollbar", UW = /* @__PURE__ */ Ue((e, t) => {
  const { forceMount: n, ...r } = e, i = wr(wi, e.__scopeScrollArea), { onScrollbarXEnabledChange: o, onScrollbarYEnabledChange: a } = i, s = e.orientation === "horizontal";
  return Ne(() => (s ? o(!0) : a(!0), () => {
    s ? o(!1) : a(!1);
  }), [
    s,
    o,
    a
  ]), i.type === "hover" ? /* @__PURE__ */ Me(BW, bt({}, r, {
    ref: t,
    forceMount: n
  })) : i.type === "scroll" ? /* @__PURE__ */ Me(zW, bt({}, r, {
    ref: t,
    forceMount: n
  })) : i.type === "auto" ? /* @__PURE__ */ Me(bC, bt({}, r, {
    ref: t,
    forceMount: n
  })) : i.type === "always" ? /* @__PURE__ */ Me(yy, bt({}, r, {
    ref: t
  })) : null;
}), BW = /* @__PURE__ */ Ue((e, t) => {
  const { forceMount: n, ...r } = e, i = wr(wi, e.__scopeScrollArea), [o, a] = Ve(!1);
  return Ne(() => {
    const s = i.scrollArea;
    let c = 0;
    if (s) {
      const l = () => {
        window.clearTimeout(c), a(!0);
      }, u = () => {
        c = window.setTimeout(
          () => a(!1),
          i.scrollHideDelay
        );
      };
      return s.addEventListener("pointerenter", l), s.addEventListener("pointerleave", u), () => {
        window.clearTimeout(c), s.removeEventListener("pointerenter", l), s.removeEventListener("pointerleave", u);
      };
    }
  }, [
    i.scrollArea,
    i.scrollHideDelay
  ]), /* @__PURE__ */ Me(Yi, {
    present: n || o
  }, /* @__PURE__ */ Me(bC, bt({
    "data-state": o ? "visible" : "hidden"
  }, r, {
    ref: t
  })));
}), zW = /* @__PURE__ */ Ue((e, t) => {
  const { forceMount: n, ...r } = e, i = wr(wi, e.__scopeScrollArea), o = e.orientation === "horizontal", a = Qd(
    () => c("SCROLL_END"),
    100
  ), [s, c] = jW("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return Ne(() => {
    if (s === "idle") {
      const l = window.setTimeout(
        () => c("HIDE"),
        i.scrollHideDelay
      );
      return () => window.clearTimeout(l);
    }
  }, [
    s,
    i.scrollHideDelay,
    c
  ]), Ne(() => {
    const l = i.viewport, u = o ? "scrollLeft" : "scrollTop";
    if (l) {
      let d = l[u];
      const p = () => {
        const f = l[u];
        d !== f && (c("SCROLL"), a()), d = f;
      };
      return l.addEventListener("scroll", p), () => l.removeEventListener("scroll", p);
    }
  }, [
    i.viewport,
    o,
    c,
    a
  ]), /* @__PURE__ */ Me(Yi, {
    present: n || s !== "hidden"
  }, /* @__PURE__ */ Me(yy, bt({
    "data-state": s === "hidden" ? "hidden" : "visible"
  }, r, {
    ref: t,
    onPointerEnter: Nn(
      e.onPointerEnter,
      () => c("POINTER_ENTER")
    ),
    onPointerLeave: Nn(
      e.onPointerLeave,
      () => c("POINTER_LEAVE")
    )
  })));
}), bC = /* @__PURE__ */ Ue((e, t) => {
  const n = wr(wi, e.__scopeScrollArea), { forceMount: r, ...i } = e, [o, a] = Ve(!1), s = e.orientation === "horizontal", c = Qd(() => {
    if (n.viewport) {
      const l = n.viewport.offsetWidth < n.viewport.scrollWidth, u = n.viewport.offsetHeight < n.viewport.scrollHeight;
      a(s ? l : u);
    }
  }, 10);
  return Aa(n.viewport, c), Aa(n.content, c), /* @__PURE__ */ Me(Yi, {
    present: r || o
  }, /* @__PURE__ */ Me(yy, bt({
    "data-state": o ? "visible" : "hidden"
  }, i, {
    ref: t
  })));
}), yy = /* @__PURE__ */ Ue((e, t) => {
  const { orientation: n = "vertical", ...r } = e, i = wr(wi, e.__scopeScrollArea), o = Ke(null), a = Ke(0), [s, c] = Ve({
    content: 0,
    viewport: 0,
    scrollbar: {
      size: 0,
      paddingStart: 0,
      paddingEnd: 0
    }
  }), l = SC(s.viewport, s.content), u = {
    ...r,
    sizes: s,
    onSizesChange: c,
    hasThumb: l > 0 && l < 1,
    onThumbChange: (p) => o.current = p,
    onThumbPointerUp: () => a.current = 0,
    onThumbPointerDown: (p) => a.current = p
  };
  function d(p, f) {
    return GW(p, a.current, s, f);
  }
  return n === "horizontal" ? /* @__PURE__ */ Me(ZW, bt({}, u, {
    ref: t,
    onThumbPositionChange: () => {
      if (i.viewport && o.current) {
        const p = i.viewport.scrollLeft, f = Ib(p, s, i.dir);
        o.current.style.transform = `translate3d(${f}px, 0, 0)`;
      }
    },
    onWheelScroll: (p) => {
      i.viewport && (i.viewport.scrollLeft = p);
    },
    onDragScroll: (p) => {
      i.viewport && (i.viewport.scrollLeft = d(p, i.dir));
    }
  })) : n === "vertical" ? /* @__PURE__ */ Me(VW, bt({}, u, {
    ref: t,
    onThumbPositionChange: () => {
      if (i.viewport && o.current) {
        const p = i.viewport.scrollTop, f = Ib(p, s);
        o.current.style.transform = `translate3d(0, ${f}px, 0)`;
      }
    },
    onWheelScroll: (p) => {
      i.viewport && (i.viewport.scrollTop = p);
    },
    onDragScroll: (p) => {
      i.viewport && (i.viewport.scrollTop = d(p));
    }
  })) : null;
}), ZW = /* @__PURE__ */ Ue((e, t) => {
  const { sizes: n, onSizesChange: r, ...i } = e, o = wr(wi, e.__scopeScrollArea), [a, s] = Ve(), c = Ke(null), l = ur(t, c, o.onScrollbarXChange);
  return Ne(() => {
    c.current && s(getComputedStyle(c.current));
  }, [
    c
  ]), /* @__PURE__ */ Me(xC, bt({
    "data-orientation": "horizontal"
  }, i, {
    ref: l,
    sizes: n,
    style: {
      bottom: 0,
      left: o.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
      right: o.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
      "--radix-scroll-area-thumb-width": Xd(n) + "px",
      ...e.style
    },
    onThumbPointerDown: (u) => e.onThumbPointerDown(u.x),
    onDragScroll: (u) => e.onDragScroll(u.x),
    onWheelScroll: (u, d) => {
      if (o.viewport) {
        const p = o.viewport.scrollLeft + u.deltaX;
        e.onWheelScroll(p), EC(p, d) && u.preventDefault();
      }
    },
    onResize: () => {
      c.current && o.viewport && a && r({
        content: o.viewport.scrollWidth,
        viewport: o.viewport.offsetWidth,
        scrollbar: {
          size: c.current.clientWidth,
          paddingStart: Lu(a.paddingLeft),
          paddingEnd: Lu(a.paddingRight)
        }
      });
    }
  }));
}), VW = /* @__PURE__ */ Ue((e, t) => {
  const { sizes: n, onSizesChange: r, ...i } = e, o = wr(wi, e.__scopeScrollArea), [a, s] = Ve(), c = Ke(null), l = ur(t, c, o.onScrollbarYChange);
  return Ne(() => {
    c.current && s(getComputedStyle(c.current));
  }, [
    c
  ]), /* @__PURE__ */ Me(xC, bt({
    "data-orientation": "vertical"
  }, i, {
    ref: l,
    sizes: n,
    style: {
      top: 0,
      right: o.dir === "ltr" ? 0 : void 0,
      left: o.dir === "rtl" ? 0 : void 0,
      bottom: "var(--radix-scroll-area-corner-height)",
      "--radix-scroll-area-thumb-height": Xd(n) + "px",
      ...e.style
    },
    onThumbPointerDown: (u) => e.onThumbPointerDown(u.y),
    onDragScroll: (u) => e.onDragScroll(u.y),
    onWheelScroll: (u, d) => {
      if (o.viewport) {
        const p = o.viewport.scrollTop + u.deltaY;
        e.onWheelScroll(p), EC(p, d) && u.preventDefault();
      }
    },
    onResize: () => {
      c.current && o.viewport && a && r({
        content: o.viewport.scrollHeight,
        viewport: o.viewport.offsetHeight,
        scrollbar: {
          size: c.current.clientHeight,
          paddingStart: Lu(a.paddingTop),
          paddingEnd: Lu(a.paddingBottom)
        }
      });
    }
  }));
}), [HW, wC] = vC(wi), xC = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeScrollArea: n, sizes: r, hasThumb: i, onThumbChange: o, onThumbPointerUp: a, onThumbPointerDown: s, onThumbPositionChange: c, onDragScroll: l, onWheelScroll: u, onResize: d, ...p } = e, f = wr(wi, n), [h, m] = Ve(null), y = ur(
    t,
    (P) => m(P)
  ), g = Ke(null), v = Ke(""), b = f.viewport, _ = r.content - r.viewport, S = Bn(u), x = Bn(c), A = Qd(d, 10);
  function I(P) {
    if (g.current) {
      const R = P.clientX - g.current.left, M = P.clientY - g.current.top;
      l({
        x: R,
        y: M
      });
    }
  }
  return Ne(() => {
    const P = (R) => {
      const M = R.target;
      (h == null ? void 0 : h.contains(M)) && S(R, _);
    };
    return document.addEventListener("wheel", P, {
      passive: !1
    }), () => document.removeEventListener("wheel", P, {
      passive: !1
    });
  }, [
    b,
    h,
    _,
    S
  ]), Ne(x, [
    r,
    x
  ]), Aa(h, A), Aa(f.content, A), /* @__PURE__ */ Me(HW, {
    scope: n,
    scrollbar: h,
    hasThumb: i,
    onThumbChange: Bn(o),
    onThumbPointerUp: Bn(a),
    onThumbPositionChange: x,
    onThumbPointerDown: Bn(s)
  }, /* @__PURE__ */ Me(Rn.div, bt({}, p, {
    ref: y,
    style: {
      position: "absolute",
      ...p.style
    },
    onPointerDown: Nn(e.onPointerDown, (P) => {
      P.button === 0 && (P.target.setPointerCapture(P.pointerId), g.current = h.getBoundingClientRect(), v.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", f.viewport && (f.viewport.style.scrollBehavior = "auto"), I(P));
    }),
    onPointerMove: Nn(e.onPointerMove, I),
    onPointerUp: Nn(e.onPointerUp, (P) => {
      const R = P.target;
      R.hasPointerCapture(P.pointerId) && R.releasePointerCapture(P.pointerId), document.body.style.webkitUserSelect = v.current, f.viewport && (f.viewport.style.scrollBehavior = ""), g.current = null;
    })
  })));
}), gh = "ScrollAreaThumb", WW = /* @__PURE__ */ Ue((e, t) => {
  const { forceMount: n, ...r } = e, i = wC(gh, e.__scopeScrollArea);
  return /* @__PURE__ */ Me(Yi, {
    present: n || i.hasThumb
  }, /* @__PURE__ */ Me(KW, bt({
    ref: t
  }, r)));
}), KW = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeScrollArea: n, style: r, ...i } = e, o = wr(gh, n), a = wC(gh, n), { onThumbPositionChange: s } = a, c = ur(
    t,
    (d) => a.onThumbChange(d)
  ), l = Ke(), u = Qd(() => {
    l.current && (l.current(), l.current = void 0);
  }, 100);
  return Ne(() => {
    const d = o.viewport;
    if (d) {
      const p = () => {
        if (u(), !l.current) {
          const f = XW(d, s);
          l.current = f, s();
        }
      };
      return s(), d.addEventListener("scroll", p), () => d.removeEventListener("scroll", p);
    }
  }, [
    o.viewport,
    u,
    s
  ]), /* @__PURE__ */ Me(Rn.div, bt({
    "data-state": a.hasThumb ? "visible" : "hidden"
  }, i, {
    ref: c,
    style: {
      width: "var(--radix-scroll-area-thumb-width)",
      height: "var(--radix-scroll-area-thumb-height)",
      ...r
    },
    onPointerDownCapture: Nn(e.onPointerDownCapture, (d) => {
      const f = d.target.getBoundingClientRect(), h = d.clientX - f.left, m = d.clientY - f.top;
      a.onThumbPointerDown({
        x: h,
        y: m
      });
    }),
    onPointerUp: Nn(e.onPointerUp, a.onThumbPointerUp)
  }));
}), _C = "ScrollAreaCorner", JW = /* @__PURE__ */ Ue((e, t) => {
  const n = wr(_C, e.__scopeScrollArea), r = !!(n.scrollbarX && n.scrollbarY);
  return n.type !== "scroll" && r ? /* @__PURE__ */ Me(YW, bt({}, e, {
    ref: t
  })) : null;
}), YW = /* @__PURE__ */ Ue((e, t) => {
  const { __scopeScrollArea: n, ...r } = e, i = wr(_C, n), [o, a] = Ve(0), [s, c] = Ve(0), l = !!(o && s);
  return Aa(i.scrollbarX, () => {
    var u;
    const d = ((u = i.scrollbarX) === null || u === void 0 ? void 0 : u.offsetHeight) || 0;
    i.onCornerHeightChange(d), c(d);
  }), Aa(i.scrollbarY, () => {
    var u;
    const d = ((u = i.scrollbarY) === null || u === void 0 ? void 0 : u.offsetWidth) || 0;
    i.onCornerWidthChange(d), a(d);
  }), l ? /* @__PURE__ */ Me(Rn.div, bt({}, r, {
    ref: t,
    style: {
      width: o,
      height: s,
      position: "absolute",
      right: i.dir === "ltr" ? 0 : void 0,
      left: i.dir === "rtl" ? 0 : void 0,
      bottom: 0,
      ...e.style
    }
  })) : null;
});
function Lu(e) {
  return e ? parseInt(e, 10) : 0;
}
function SC(e, t) {
  const n = e / t;
  return isNaN(n) ? 0 : n;
}
function Xd(e) {
  const t = SC(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, r = (e.scrollbar.size - n) * t;
  return Math.max(r, 18);
}
function GW(e, t, n, r = "ltr") {
  const i = Xd(n), o = i / 2, a = t || o, s = i - a, c = n.scrollbar.paddingStart + a, l = n.scrollbar.size - n.scrollbar.paddingEnd - s, u = n.content - n.viewport, d = r === "ltr" ? [
    0,
    u
  ] : [
    u * -1,
    0
  ];
  return kC([
    c,
    l
  ], d)(e);
}
function Ib(e, t, n = "ltr") {
  const r = Xd(t), i = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, o = t.scrollbar.size - i, a = t.content - t.viewport, s = o - r, c = n === "ltr" ? [
    0,
    a
  ] : [
    a * -1,
    0
  ], l = NW(e, c);
  return kC([
    0,
    a
  ], [
    0,
    s
  ])(l);
}
function kC(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1])
      return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function EC(e, t) {
  return e > 0 && e < t;
}
const XW = (e, t = () => {
}) => {
  let n = {
    left: e.scrollLeft,
    top: e.scrollTop
  }, r = 0;
  return function i() {
    const o = {
      left: e.scrollLeft,
      top: e.scrollTop
    }, a = n.left !== o.left, s = n.top !== o.top;
    (a || s) && t(), n = o, r = window.requestAnimationFrame(i);
  }(), () => window.cancelAnimationFrame(r);
};
function Qd(e, t) {
  const n = Bn(e), r = Ke(0);
  return Ne(
    () => () => window.clearTimeout(r.current),
    []
  ), an(() => {
    window.clearTimeout(r.current), r.current = window.setTimeout(n, t);
  }, [
    n,
    t
  ]);
}
function Aa(e, t) {
  const n = Bn(t);
  ha(() => {
    let r = 0;
    if (e) {
      const i = new ResizeObserver(() => {
        cancelAnimationFrame(r), r = window.requestAnimationFrame(n);
      });
      return i.observe(e), () => {
        window.cancelAnimationFrame(r), i.unobserve(e);
      };
    }
  }, [
    e,
    n
  ]);
}
const QW = qW, eK = FW, tK = UW, nK = WW, rK = JW;
var CC = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(it, function() {
    var n = 1e3, r = 6e4, i = 36e5, o = "millisecond", a = "second", s = "minute", c = "hour", l = "day", u = "week", d = "month", p = "quarter", f = "year", h = "date", m = "Invalid Date", y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, g = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, v = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(L) {
      var $ = ["th", "st", "nd", "rd"], j = L % 100;
      return "[" + L + ($[(j - 20) % 10] || $[j] || $[0]) + "]";
    } }, b = function(L, $, j) {
      var z = String(L);
      return !z || z.length >= $ ? L : "" + Array($ + 1 - z.length).join(j) + L;
    }, _ = { s: b, z: function(L) {
      var $ = -L.utcOffset(), j = Math.abs($), z = Math.floor(j / 60), H = j % 60;
      return ($ <= 0 ? "+" : "-") + b(z, 2, "0") + ":" + b(H, 2, "0");
    }, m: function L($, j) {
      if ($.date() < j.date())
        return -L(j, $);
      var z = 12 * (j.year() - $.year()) + (j.month() - $.month()), H = $.clone().add(z, d), X = j - H < 0, E = $.clone().add(z + (X ? -1 : 1), d);
      return +(-(z + (j - H) / (X ? H - E : E - H)) || 0);
    }, a: function(L) {
      return L < 0 ? Math.ceil(L) || 0 : Math.floor(L);
    }, p: function(L) {
      return { M: d, y: f, w: u, d: l, D: h, h: c, m: s, s: a, ms: o, Q: p }[L] || String(L || "").toLowerCase().replace(/s$/, "");
    }, u: function(L) {
      return L === void 0;
    } }, S = "en", x = {};
    x[S] = v;
    var A = "$isDayjsObject", I = function(L) {
      return L instanceof V || !(!L || !L[A]);
    }, P = function L($, j, z) {
      var H;
      if (!$)
        return S;
      if (typeof $ == "string") {
        var X = $.toLowerCase();
        x[X] && (H = X), j && (x[X] = j, H = X);
        var E = $.split("-");
        if (!H && E.length > 1)
          return L(E[0]);
      } else {
        var ee = $.name;
        x[ee] = $, H = ee;
      }
      return !z && H && (S = H), H || !z && S;
    }, R = function(L, $) {
      if (I(L))
        return L.clone();
      var j = typeof $ == "object" ? $ : {};
      return j.date = L, j.args = arguments, new V(j);
    }, M = _;
    M.l = P, M.i = I, M.w = function(L, $) {
      return R(L, { locale: $.$L, utc: $.$u, x: $.$x, $offset: $.$offset });
    };
    var V = function() {
      function L(j) {
        this.$L = P(j.locale, null, !0), this.parse(j), this.$x = this.$x || j.x || {}, this[A] = !0;
      }
      var $ = L.prototype;
      return $.parse = function(j) {
        this.$d = function(z) {
          var H = z.date, X = z.utc;
          if (H === null)
            return /* @__PURE__ */ new Date(NaN);
          if (M.u(H))
            return /* @__PURE__ */ new Date();
          if (H instanceof Date)
            return new Date(H);
          if (typeof H == "string" && !/Z$/i.test(H)) {
            var E = H.match(y);
            if (E) {
              var ee = E[2] - 1 || 0, de = (E[7] || "0").substring(0, 3);
              return X ? new Date(Date.UTC(E[1], ee, E[3] || 1, E[4] || 0, E[5] || 0, E[6] || 0, de)) : new Date(E[1], ee, E[3] || 1, E[4] || 0, E[5] || 0, E[6] || 0, de);
            }
          }
          return new Date(H);
        }(j), this.init();
      }, $.init = function() {
        var j = this.$d;
        this.$y = j.getFullYear(), this.$M = j.getMonth(), this.$D = j.getDate(), this.$W = j.getDay(), this.$H = j.getHours(), this.$m = j.getMinutes(), this.$s = j.getSeconds(), this.$ms = j.getMilliseconds();
      }, $.$utils = function() {
        return M;
      }, $.isValid = function() {
        return this.$d.toString() !== m;
      }, $.isSame = function(j, z) {
        var H = R(j);
        return this.startOf(z) <= H && H <= this.endOf(z);
      }, $.isAfter = function(j, z) {
        return R(j) < this.startOf(z);
      }, $.isBefore = function(j, z) {
        return this.endOf(z) < R(j);
      }, $.$g = function(j, z, H) {
        return M.u(j) ? this[z] : this.set(H, j);
      }, $.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, $.valueOf = function() {
        return this.$d.getTime();
      }, $.startOf = function(j, z) {
        var H = this, X = !!M.u(z) || z, E = M.p(j), ee = function(Ae, pe) {
          var ue = M.w(H.$u ? Date.UTC(H.$y, pe, Ae) : new Date(H.$y, pe, Ae), H);
          return X ? ue : ue.endOf(l);
        }, de = function(Ae, pe) {
          return M.w(H.toDate()[Ae].apply(H.toDate("s"), (X ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(pe)), H);
        }, T = this.$W, be = this.$M, ke = this.$D, Se = "set" + (this.$u ? "UTC" : "");
        switch (E) {
          case f:
            return X ? ee(1, 0) : ee(31, 11);
          case d:
            return X ? ee(1, be) : ee(0, be + 1);
          case u:
            var Pe = this.$locale().weekStart || 0, Be = (T < Pe ? T + 7 : T) - Pe;
            return ee(X ? ke - Be : ke + (6 - Be), be);
          case l:
          case h:
            return de(Se + "Hours", 0);
          case c:
            return de(Se + "Minutes", 1);
          case s:
            return de(Se + "Seconds", 2);
          case a:
            return de(Se + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, $.endOf = function(j) {
        return this.startOf(j, !1);
      }, $.$set = function(j, z) {
        var H, X = M.p(j), E = "set" + (this.$u ? "UTC" : ""), ee = (H = {}, H[l] = E + "Date", H[h] = E + "Date", H[d] = E + "Month", H[f] = E + "FullYear", H[c] = E + "Hours", H[s] = E + "Minutes", H[a] = E + "Seconds", H[o] = E + "Milliseconds", H)[X], de = X === l ? this.$D + (z - this.$W) : z;
        if (X === d || X === f) {
          var T = this.clone().set(h, 1);
          T.$d[ee](de), T.init(), this.$d = T.set(h, Math.min(this.$D, T.daysInMonth())).$d;
        } else
          ee && this.$d[ee](de);
        return this.init(), this;
      }, $.set = function(j, z) {
        return this.clone().$set(j, z);
      }, $.get = function(j) {
        return this[M.p(j)]();
      }, $.add = function(j, z) {
        var H, X = this;
        j = Number(j);
        var E = M.p(z), ee = function(be) {
          var ke = R(X);
          return M.w(ke.date(ke.date() + Math.round(be * j)), X);
        };
        if (E === d)
          return this.set(d, this.$M + j);
        if (E === f)
          return this.set(f, this.$y + j);
        if (E === l)
          return ee(1);
        if (E === u)
          return ee(7);
        var de = (H = {}, H[s] = r, H[c] = i, H[a] = n, H)[E] || 1, T = this.$d.getTime() + j * de;
        return M.w(T, this);
      }, $.subtract = function(j, z) {
        return this.add(-1 * j, z);
      }, $.format = function(j) {
        var z = this, H = this.$locale();
        if (!this.isValid())
          return H.invalidDate || m;
        var X = j || "YYYY-MM-DDTHH:mm:ssZ", E = M.z(this), ee = this.$H, de = this.$m, T = this.$M, be = H.weekdays, ke = H.months, Se = H.meridiem, Pe = function(pe, ue, xe, fe) {
          return pe && (pe[ue] || pe(z, X)) || xe[ue].slice(0, fe);
        }, Be = function(pe) {
          return M.s(ee % 12 || 12, pe, "0");
        }, Ae = Se || function(pe, ue, xe) {
          var fe = pe < 12 ? "AM" : "PM";
          return xe ? fe.toLowerCase() : fe;
        };
        return X.replace(g, function(pe, ue) {
          return ue || function(xe) {
            switch (xe) {
              case "YY":
                return String(z.$y).slice(-2);
              case "YYYY":
                return M.s(z.$y, 4, "0");
              case "M":
                return T + 1;
              case "MM":
                return M.s(T + 1, 2, "0");
              case "MMM":
                return Pe(H.monthsShort, T, ke, 3);
              case "MMMM":
                return Pe(ke, T);
              case "D":
                return z.$D;
              case "DD":
                return M.s(z.$D, 2, "0");
              case "d":
                return String(z.$W);
              case "dd":
                return Pe(H.weekdaysMin, z.$W, be, 2);
              case "ddd":
                return Pe(H.weekdaysShort, z.$W, be, 3);
              case "dddd":
                return be[z.$W];
              case "H":
                return String(ee);
              case "HH":
                return M.s(ee, 2, "0");
              case "h":
                return Be(1);
              case "hh":
                return Be(2);
              case "a":
                return Ae(ee, de, !0);
              case "A":
                return Ae(ee, de, !1);
              case "m":
                return String(de);
              case "mm":
                return M.s(de, 2, "0");
              case "s":
                return String(z.$s);
              case "ss":
                return M.s(z.$s, 2, "0");
              case "SSS":
                return M.s(z.$ms, 3, "0");
              case "Z":
                return E;
            }
            return null;
          }(pe) || E.replace(":", "");
        });
      }, $.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, $.diff = function(j, z, H) {
        var X, E = this, ee = M.p(z), de = R(j), T = (de.utcOffset() - this.utcOffset()) * r, be = this - de, ke = function() {
          return M.m(E, de);
        };
        switch (ee) {
          case f:
            X = ke() / 12;
            break;
          case d:
            X = ke();
            break;
          case p:
            X = ke() / 3;
            break;
          case u:
            X = (be - T) / 6048e5;
            break;
          case l:
            X = (be - T) / 864e5;
            break;
          case c:
            X = be / i;
            break;
          case s:
            X = be / r;
            break;
          case a:
            X = be / n;
            break;
          default:
            X = be;
        }
        return H ? X : M.a(X);
      }, $.daysInMonth = function() {
        return this.endOf(d).$D;
      }, $.$locale = function() {
        return x[this.$L];
      }, $.locale = function(j, z) {
        if (!j)
          return this.$L;
        var H = this.clone(), X = P(j, z, !0);
        return X && (H.$L = X), H;
      }, $.clone = function() {
        return M.w(this.$d, this);
      }, $.toDate = function() {
        return new Date(this.valueOf());
      }, $.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, $.toISOString = function() {
        return this.$d.toISOString();
      }, $.toString = function() {
        return this.$d.toUTCString();
      }, L;
    }(), U = V.prototype;
    return R.prototype = U, [["$ms", o], ["$s", a], ["$m", s], ["$H", c], ["$W", l], ["$M", d], ["$y", f], ["$D", h]].forEach(function(L) {
      U[L[1]] = function($) {
        return this.$g($, L[0], L[1]);
      };
    }), R.extend = function(L, $) {
      return L.$i || (L($, V, R), L.$i = !0), R;
    }, R.locale = P, R.isDayjs = I, R.unix = function(L) {
      return R(1e3 * L);
    }, R.en = x[S], R.Ls = x, R.p = {}, R;
  });
})(CC);
var iK = CC.exports;
const ef = /* @__PURE__ */ Vi(iK);
var TC = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(it, function() {
    return function(n, r, i) {
      r.prototype.isToday = function() {
        var o = "YYYY-MM-DD", a = i();
        return this.format(o) === a.format(o);
      };
    };
  });
})(TC);
var oK = TC.exports;
const aK = /* @__PURE__ */ Vi(oK);
var RC = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(it, function() {
    return function(n, r, i) {
      r.prototype.isYesterday = function() {
        var o = "YYYY-MM-DD", a = i().subtract(1, "day");
        return this.format(o) === a.format(o);
      };
    };
  });
})(RC);
var sK = RC.exports;
const cK = /* @__PURE__ */ Vi(sK);
ef.extend(aK);
ef.extend(cK);
function lK(e, t = "day") {
  if (!e || e.length === 0)
    return [];
  const n = [];
  n.push(Pb(e[0].timestamp));
  for (let r = 0; r < e.length; r++)
    if (n.push(e[r]), r + 1 < e.length) {
      const i = e[r].timestamp, o = e[r + 1].timestamp;
      ef(i).isSame(o, t) || n.push(Pb(o));
    }
  return n;
}
function Pb(e) {
  return {
    id: su(),
    direction: "system",
    sender: { name: "system" },
    timestamp: e,
    block: {
      type: "text",
      text: uK(e)
    }
  };
}
function uK(e, t = !1) {
  const n = ef(e), r = "h:mma";
  return n.isToday() ? t ? `Today  ${n.format(r)}` : "Today" : n.isYesterday() ? t ? `Yesterday  ${n.format(r)}` : "Yesterday" : t ? n.format(`YYYY-MM-DD  ${r}`) : n.format("YYYY-MM-DD");
}
const dK = Ao(({ scrollDownButton: e, ...t }) => {
  var v, b, _, S, x, A, I, P, R, M, V, U, L;
  const { messageList: n } = Ie(($) => $.theme), r = ir(($) => $.conversationId), i = Ie(($) => $.messages)[r ?? ""] ?? [], o = Ie(($) => $.setState), a = Ie(($) => $.client), s = Ie(($) => $.getClientId)(), c = Ie(($) => $.configuration), l = Ie(($) => $.messageContainerRef), u = Ie(($) => $.isTyping), d = Ie(($) => $.setIsTyping), p = ho(() => lK(i), [i]), [f, h] = Ve(!0), { y: m } = n7(l), y = () => {
    if (!l.current)
      return;
    const { scrollHeight: $ } = l.current;
    f && l.current.scrollTo({ top: $ });
  };
  Ne(() => a == null ? void 0 : a.on("isTyping", ({ isTyping: $, timeout: j }) => {
    d($, j);
  }), []), Ne(() => {
    const $ = i[i.length - 1];
    o({ disableComposer: !!($ != null && $.disableInput) });
  }, [i.length]), Ne(() => {
    if (!l.current)
      return;
    const { offsetHeight: $, scrollHeight: j, scrollTop: z } = l.current;
    h(j <= z + $ + 100);
  }, [m]);
  const g = e != null && e.icon ? e == null ? void 0 : e.icon : A7;
  return /* @__PURE__ */ F.jsxs(QW, { ...(v = n == null ? void 0 : n.scrollbar) == null ? void 0 : v.container, scrollHideDelay: 300, type: "hover", children: [
    /* @__PURE__ */ F.jsx(eK, { ...(b = n == null ? void 0 : n.scrollbar) == null ? void 0 : b.viewport, ref: l, children: /* @__PURE__ */ F.jsxs("ul", { ...t, ...n == null ? void 0 : n.container, children: [
      /* @__PURE__ */ F.jsxs("li", { ...(_ = n == null ? void 0 : n.marquee) == null ? void 0 : _.container, children: [
        /* @__PURE__ */ F.jsx(T1, { userId: s, src: c.botAvatar, ...(S = n == null ? void 0 : n.marquee) == null ? void 0 : S.avatar, children: (c.botName || "Bot").slice(0, 1) }),
        /* @__PURE__ */ F.jsxs("div", { ...(x = n == null ? void 0 : n.marquee) == null ? void 0 : x.content, children: [
          /* @__PURE__ */ F.jsx("h1", { ...(A = n == null ? void 0 : n.marquee) == null ? void 0 : A.title, children: c.botName || "Bot" }),
          /* @__PURE__ */ F.jsx("p", { ...(I = n == null ? void 0 : n.marquee) == null ? void 0 : I.description, children: c.botDescription })
        ] })
      ] }),
      p.map(($, j) => /* @__PURE__ */ F.jsx(Ob, { scroll: y, ...$ }, j)),
      u && /* @__PURE__ */ F.jsx(Ob, { scroll: y, direction: "incoming", children: /* @__PURE__ */ F.jsx(PW, {}) }),
      /* @__PURE__ */ F.jsx("li", { "data-is-at-bottom": f, ...(P = n == null ? void 0 : n.scrollDownButton) == null ? void 0 : P.container, children: !!i.length && /* @__PURE__ */ F.jsxs(
        "button",
        {
          type: "button",
          "data-is-at-bottom": f,
          ...(R = n == null ? void 0 : n.scrollDownButton) == null ? void 0 : R.button,
          onClick: () => {
            var $, j;
            return (j = l.current) == null ? void 0 : j.scrollBy({ top: ($ = l.current) == null ? void 0 : $.scrollHeight });
          },
          children: [
            (e == null ? void 0 : e.text) ?? "Back",
            " ",
            /* @__PURE__ */ F.jsx(g, { ...(M = n == null ? void 0 : n.scrollDownButton) == null ? void 0 : M.icon })
          ]
        }
      ) })
    ] }) }),
    /* @__PURE__ */ F.jsx(tK, { orientation: "vertical", ...(V = n == null ? void 0 : n.scrollbar) == null ? void 0 : V.background, children: /* @__PURE__ */ F.jsx(nK, { ...(U = n == null ? void 0 : n.scrollbar) == null ? void 0 : U.thumb }) }),
    /* @__PURE__ */ F.jsx(rK, { ...(L = n == null ? void 0 : n.scrollbar) == null ? void 0 : L.corner })
  ] });
}), gJ = () => /* @__PURE__ */ F.jsxs(cW, { children: [
  /* @__PURE__ */ F.jsx(IW, {}),
  /* @__PURE__ */ F.jsx(dK, {}),
  /* @__PURE__ */ F.jsxs(AV, { children: [
    /* @__PURE__ */ F.jsx(IV, {}),
    /* @__PURE__ */ F.jsx(OV, {}),
    /* @__PURE__ */ F.jsx(PV, {})
  ] })
] }), Ja = Z.object({
  title: Z.string(),
  link: Z.string().optional()
}), fK = Z.object({
  composerPlaceholder: Z.string().optional(),
  botName: Z.string().optional(),
  botAvatar: Z.string().optional(),
  botDescription: Z.string().optional(),
  website: Ja.optional(),
  email: Ja.optional(),
  phone: Ja.optional(),
  privacyPolicy: Ja.optional(),
  termsOfService: Ja.optional()
}), pK = Z.enum([
  "heading1",
  "heading2",
  "heading3",
  "text",
  "horizontalRule",
  "link",
  "italic",
  "bold",
  "orderedList",
  "unorderedList",
  "listItem",
  "lineBreak",
  "pre"
]), hK = Z.object({}).passthrough().transform((e) => e), we = Z.object({
  className: Z.string().optional(),
  style: hK.optional()
}), ip = Z.object({
  container: we.optional(),
  image: we.optional(),
  fallback: we.optional()
}), mK = Z.object({
  button: we.optional(),
  text: Z.record(pK, we.optional()),
  image: Z.object({
    image: we.optional(),
    placeholder: we.optional()
  }).optional(),
  audio: we.optional(),
  video: we.optional(),
  file: Z.object({
    container: we.optional(),
    title: we.optional(),
    icon: we.optional()
  }).optional(),
  location: Z.object({
    container: we.optional(),
    title: we.optional(),
    icon: we.optional()
  }).optional(),
  column: we.optional(),
  row: we.optional(),
  bubble: we.optional(),
  carousel: Z.object({
    container: we.optional(),
    slidesContainer: we.optional(),
    backButton: we.optional(),
    nextButton: we.optional()
  }).optional(),
  dropdown: Z.object({
    button: Z.object({
      container: we.optional(),
      icon: we.optional(),
      text: we.optional()
    }).optional(),
    content: Z.object({
      container: we.optional(),
      item: we.optional()
    }).optional()
  }).optional()
}), yK = Z.object({
  container: we.optional(),
  modal: Z.object({
    overlay: we.optional(),
    container: we.optional(),
    dialog: Z.object({
      container: we.optional(),
      title: Z.object({
        container: we.optional(),
        text: we.optional(),
        closeIcon: we.optional()
      }).optional(),
      content: we.optional(),
      newConversation: Z.object({
        text: we.optional(),
        button: we.optional()
      }).optional()
    }).optional()
  }).optional(),
  notification: Z.object({
    container: we.optional(),
    title: we.optional(),
    description: we.optional(),
    icon: we.optional(),
    closeIcon: we.optional()
  }).optional(),
  header: Z.object({
    container: we.optional(),
    content: Z.object({
      container: we.optional(),
      title: we.optional(),
      description: we.optional(),
      avatar: ip.optional(),
      actions: Z.object({
        container: we.optional(),
        icons: we.optional()
      }).optional()
    }),
    expandedContent: Z.object({
      container: we.optional(),
      group: we.optional(),
      descriptionItems: Z.object({
        container: we.optional(),
        icon: we.optional(),
        text: we.optional(),
        link: we.optional(),
        poweredBy: we.optional()
      }).optional()
    }).optional(),
    description: Z.object({
      container: we.optional(),
      title: we.optional(),
      subtitle: we.optional()
    }).optional(),
    newConversationIcon: we.optional()
  }).optional(),
  composer: Z.object({
    container: we.optional(),
    input: we.optional(),
    uploadButton: Z.object({
      container: we.optional(),
      icon: we.optional()
    }).optional(),
    button: Z.object({
      container: we.optional(),
      icon: we.optional()
    }).optional()
  }).optional(),
  fab: Z.object({
    icon: we.optional(),
    container: we.optional()
  }).optional(),
  messageList: Z.object({
    scrollbar: Z.object({
      container: we.optional(),
      viewport: we.optional(),
      thumb: we.optional(),
      corner: we.optional(),
      background: we.optional()
    }).optional(),
    container: we.optional(),
    marquee: Z.object({
      content: we.optional(),
      title: we.optional(),
      description: we.optional(),
      avatar: ip.optional(),
      container: we.optional()
    }).optional(),
    scrollDownButton: Z.object({
      container: we.optional(),
      button: we.optional(),
      icon: we.optional()
    }).optional()
  }).optional(),
  message: Z.object({
    container: we.optional(),
    avatar: ip.optional(),
    blocks: mK.optional()
  }).optional(),
  loadingIndicator: Z.object({
    container: we.optional(),
    loader: we.optional()
  }).optional()
}), gK = Z.enum(["opened", "closed", "initial"]), vK = Z.object({
  name: Z.string().optional(),
  pictureUrl: Z.string().optional(),
  data: Z.record(Z.unknown()).optional()
}), bK = Z.enum(["messaging", "pushpin"]), wK = Z.object({
  configuration: fK.optional().catch(void 0),
  theme: yK.optional().catch(void 0),
  style: Z.string().optional().catch(void 0),
  user: vK.optional().catch(void 0)
}), vJ = wK.extend({
  clientId: Z.string(),
  botId: Z.string(),
  selector: Z.string().optional().catch(void 0),
  webchatScriptUrl: Z.string().optional().catch(void 0),
  fabScriptUrl: Z.string().optional().catch(void 0),
  messagingUrl: Z.string().optional().catch(void 0),
  pushpinUrl: Z.string().optional().catch(void 0),
  clientMode: bK.optional().catch(void 0),
  defaultState: gK.optional().catch(void 0)
});
export {
  T1 as Avatar,
  yc as Block,
  AV as Composer,
  PV as ComposerButton,
  OV as ComposerInput,
  cW as Container,
  pJ as Fab,
  IW as Header,
  mJ as HeaderRoot,
  PW as LoadingIndicator,
  Ob as Message,
  dK as MessageList,
  Ro as Modal,
  $V as ModalProvider,
  xW as RestartConversation,
  IV as UploadButton,
  gJ as Webchat,
  uJ as WebchatProvider,
  rJ as __adapters,
  ip as avatarThemeSchema,
  mK as blockThemeSchema,
  bK as clientModePropsSchema,
  wK as configPropsSchema,
  fK as configurationSchema,
  hK as cssStyleSchema,
  Ja as descriptionItemSchema,
  w6 as fileTypes,
  S6 as getClient,
  vJ as initPropsSchema,
  x6 as isFileType,
  pK as markdownTypeSchema,
  RV as renderers,
  gK as statePropsSchema,
  we as styleOptionSchema,
  yK as themeSchema,
  cJ as useClient,
  Ie as useWebchatStore,
  vK as userPropsSchema
};
