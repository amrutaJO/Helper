import csstreeParse from 'css-tree/parser';
import csstreeWalk from 'css-tree/walker';
import csstreeGenerate from 'css-tree/generator';
import { parse } from '@twind/core';
import { parseColor, editabelColorRe } from './index-eab4ec48.js';
function parseHTML(markup, onClass) {
    let mode = 1, startIndex = 0, quote = '', attributeName = '', commit = (currentIndex)=>{
        5 == mode && 'class' == attributeName && false === onClass(startIndex, currentIndex, quote) && (markup = '');
    };
    for(let position = 0; position < markup.length; position++){
        let char = markup[position];
        if (1 == mode) '<' == char && (mode = '!--' == markup.substr(position + 1, 3) ? 4 : 3);
        else if (4 == mode) '>' == char && '--' == markup.slice(position - 2, position) && (mode = 1);
        else if (quote) {
            if (char == quote && '\\' != markup[position - 1]) {
                commit(position);
                mode = 2;
                quote = '';
            }
        } else if ('"' == char || "'" == char) {
            quote = char;
            startIndex += 1;
        } else if ('>' == char) {
            commit(position);
            mode = 1;
        } else if (mode) {
            // MODE_SLASH
            // Ignore everything until the tag ends
            if ('=' == char) {
                attributeName = markup.slice(startIndex, position);
                mode = 5;
                startIndex = position + 1;
            } else if ('/' == char && (mode < 5 || '>' == markup[position + 1])) {
                commit(position);
                mode = // For now we are using a simple parser adapted from htm (https://github.com/developit/htm/blob/master/src/build.mjs)
                // If we find any issues we can switch to something more sophisticated like
                // - https://github.com/acrazing/html5parser
                // - https://github.com/fb55/htmlparser2
                0;
            } else if (/\s/.test(char)) {
                // <a class=font-bold>
                commit(position);
                mode = 2;
                startIndex = position + 1;
            }
        }
    }
}
function fixClassList(value, quote) {
    // const value = markup.slice(startIndex, endIndex)
    // Lets handle some special react cases:
    //   * arbitrary values for `content-`
    //     <span class="before:content-[&#x27;asas&#x27;]"></span>
    //     <span class="before:content-[&quot;asas&quot;]"></span>
    //
    //   * self-referenced groups
    //     <span class="flex(&amp; col)"></span>
    //
    //     If a class name contains `'`, `"`, or `&` those will be replaced with HTML entities
    //     To fix this we replace those for depending on the actual symbol that is being used
    //     As an alternative we could always escape class names direcly in twind like react does
    //     but this works for now
    return ('"' == quote ? // `'` -> &#39; &apos; &#x27;
    value.replace(/(=|\[)(?:&#39;|&apos;|&#x27;)|(?:&#39;|&apos;|&#x27;)(])/g, "$1'$2") : "'" == quote ? // `"` -> &#34; &quot; &#x22;
    value.replace(/(=|\[)(?:&#34;|&quot;|&#x22;)|(?:&#34;|&quot;|&#x22;)(])/g, '$1"$2') : value).replace(/(&#38;|&amp;|&#x26;)/g, '&');
}
function adjustRuleLocation(token, rule, offset) {
    let start = rule.l[0], end = rule.l[1], index = rule.a.length, value = rule.a[--index];
    for(; index--;){
        let active = rule.a[index];
        if ('(' == active || '&' == active || /[~@]$/.test(active)) break;
        value = active + value;
        if (token.slice(start - active.length, end) === value) start -= active.length;
        else break;
    }
    return {
        start: offset + start,
        end: offset + end
    };
}
function documentationAt(content, offset, { isIgnored  }) {
    let result = null;
    return parseHTML(content, (startIndex, endIndex, quote)=>{
        if (startIndex <= offset && offset < endIndex) {
            // offset is within this classList
            let token = content.slice(startIndex, endIndex), // TODO: after fixClassList the positions maybe invalid
            rules = parse(fixClassList(token, quote));
            for (let rule of rules){
                let start = startIndex + rule.l[0], end = startIndex + rule.l[1];
                if (start <= offset && offset < end) {
                    // found our rule
                    if (!isIgnored(rule.n)) {
                        var rule1;
                        result = {
                            ...adjustRuleLocation(token, rule, startIndex),
                            value: [
                                ...(rule1 = rule).v,
                                (rule1.i ? '!' : '') + rule1.n
                            ].join(':')
                        };
                    }
                    break;
                }
                if (offset < end) break;
            }
            return false;
        }
        if (offset < startIndex) return false;
    }), result;
}
function collectColors(content, { classes , isIgnored  }) {
    let colors = [];
    return parseHTML(content, (startIndex, endIndex, quote)=>{
        let token = content.slice(startIndex, endIndex), rules = parse(fixClassList(token, quote));
        for (let rule of rules){
            if (isIgnored(rule.n)) continue;
            let completion = classes.get(rule.n);
            if (completion?.color) {
                let color = parseColor(completion.color);
                if (color) {
                    colors.push({
                        ...adjustRuleLocation(token, rule, startIndex),
                        value: completion.color,
                        rgba: color
                    });
                    continue;
                }
            }
            let editableMatch = rule.n.match(editabelColorRe);
            if (editableMatch) {
                let { 1: currentColor  } = editableMatch, color1 = parseColor(currentColor);
                if (color1) {
                    colors.push({
                        ...adjustRuleLocation(token, rule, startIndex),
                        value: currentColor,
                        rgba: color1,
                        editable: true
                    });
                    continue;
                }
            }
        }
    }), colors;
}
function validate(content, { variants , classes , isIgnored , generateCSS  }) {
    let diagnostics = [];
    return parseHTML(content, (startIndex, endIndex, quote)=>{
        let token = content.slice(startIndex, endIndex), rules = parse(fixClassList(token, quote));
        for (let rule of rules){
            if (isIgnored(rule.n)) continue;
            let css = generateCSS(rule.n), ast = csstreeParse(css, {
                positions: false,
                parseAtrulePrelude: false,
                parseRulePrelude: false,
                parseValue: false,
                parseCustomProperty: false,
                onParseError (error) {
                    diagnostics.push({
                        ...adjustRuleLocation(token, rule, startIndex),
                        code: 'invalidCSS',
                        message: `Failed to parse CSS of class ${JSON.stringify(rule.n)}: ${error.message}`,
                        severity: 'error',
                        value: rule.n
                    });
                }
            });
            ast && // TODO: csstree-validator uses createRequire to fetch mdn-data -> this does not work in the browser
            // if (typeof document !== 'object') {
            //   const cssValidator = await import('csstree-validator')
            //   // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            //   for (const error of cssValidator.validate(ast)) {
            //     diagnostics.push({
            //       ...adjustRuleLocation(token, rule, startIndex),
            //       code: 'invalidCSS',
            //       // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            //       message: error.message,
            //       severity: 'warning',
            //       value: rule.n,
            //     })
            //   }
            // }
            'object' == typeof document && csstreeWalk(ast, {
                visit: 'SelectorList',
                enter (node) {
                    let selector = csstreeGenerate(node);
                    try {
                        document.querySelector(selector);
                    } catch (error) {
                        /:(-webkit-|-moz-|-ms-)/.test(selector) ? diagnostics.push({
                            ...adjustRuleLocation(token, rule, startIndex),
                            code: 'invalidCSS',
                            message: `Vendor specific selector ${JSON.stringify(selector)} for class ${JSON.stringify(rule.n)}`,
                            severity: 'hint',
                            value: rule.n
                        }) : diagnostics.push({
                            ...adjustRuleLocation(token, rule, startIndex),
                            code: 'invalidCSS',
                            message: `Invalid selector ${JSON.stringify(selector)} for class ${JSON.stringify(rule.n)}`,
                            severity: 'warning',
                            value: rule.n
                        });
                    }
                }
            });
            classes.has(rule.n) || css || diagnostics.push({
                ...adjustRuleLocation(token, rule, startIndex),
                code: 'invalidClass',
                message: `Invalid class ${JSON.stringify(rule.n)}`,
                severity: 'error',
                value: rule.n
            });
            for (let variant of rule.v){
                let className = variant + ':' + rule.n;
                if (isIgnored(className)) continue;
                let css1 = generateCSS(className), ast1 = csstreeParse(css1, {
                    positions: false,
                    parseAtrulePrelude: false,
                    parseRulePrelude: false,
                    parseValue: false,
                    parseCustomProperty: false,
                    onParseError (error) {
                        diagnostics.push({
                            ...adjustRuleLocation(token, rule, startIndex),
                            code: 'invalidCSS',
                            message: `Failed to parse CSS of variant ${JSON.stringify(variant)}: ${error.message}`,
                            severity: 'error',
                            value: rule.n
                        });
                    }
                });
                ast1 && 'object' == typeof document && csstreeWalk(ast1, {
                    visit: 'SelectorList',
                    enter (node) {
                        let selector = csstreeGenerate(node);
                        try {
                            document.querySelector(selector);
                        } catch  {
                            /:(-webkit-|-moz-|-ms-)/.test(selector) ? diagnostics.push({
                                ...adjustRuleLocation(token, rule, startIndex),
                                code: 'invalidCSS',
                                message: `Vendor specific selector ${JSON.stringify(selector)} for variant ${JSON.stringify(variant)}`,
                                severity: 'hint',
                                value: rule.n
                            }) : diagnostics.push({
                                ...adjustRuleLocation(token, rule, startIndex),
                                code: 'invalidCSS',
                                message: `Invalid selector ${JSON.stringify(selector)} for variant ${JSON.stringify(variant)}`,
                                severity: 'warning',
                                value: rule.n
                            });
                        }
                    }
                });
                variants.has(variant + ':') || css1 || diagnostics.push({
                    ...adjustRuleLocation(token, rule, startIndex),
                    code: 'invalidVariant',
                    message: `Invalid variant ${JSON.stringify(variant)}`,
                    severity: 'error',
                    value: variant
                });
            }
        }
    }), diagnostics;
}
function extractBoundary(content, position) {
    return find('class="', /[^\\]"/) || find("class='", /[^\\]'/) || find("class=", /[\s"'`=;>]/) || // svelte class toggle
    // 'class:...',
    find("class:", /[\s"'/=]/);
    function find(search, invalid, before = /\s/) {
        let startIndex = content.lastIndexOf(search, position);
        // found and the char before is a white space
        if (-1 !== startIndex && before.test(content[startIndex - 1])) {
            let boundary = content.slice(startIndex + search.length, position);
            return(// maybe an expression like class="{...}"
            // TODO: for now ignore expression
            /{/.test(boundary[0]) || invalid.test(boundary) ? null : {
                start: startIndex + search.length,
                end: position,
                content: boundary
            });
        }
        return null;
    }
}
export { collectColors, documentationAt, extractBoundary, validate };
//# sourceMappingURL=html-9ea8d9f3.js.map
