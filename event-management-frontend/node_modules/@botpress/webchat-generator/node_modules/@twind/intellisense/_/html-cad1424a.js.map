{"version":3,"file":"html-cad1424a.js","sources":["../../../core/src/internal/parse-html.ts","../../src/internal/adjust-rule-location.ts","../../src/languages/html.ts","../../../core/src/internal/to-class-name.ts"],"sourcesContent":["// For now we are using a simple parser adapted from htm (https://github.com/developit/htm/blob/master/src/build.mjs)\n// If we find any issues we can switch to something more sophisticated like\n// - https://github.com/acrazing/html5parser\n// - https://github.com/fb55/htmlparser2\n\nconst MODE_SLASH = 0\nconst MODE_TEXT = 1\nconst MODE_WHITESPACE = 2\nconst MODE_TAGNAME = 3\nconst MODE_COMMENT = 4\nconst MODE_ATTRIBUTE = 5\n\nexport function parseHTML(\n  markup: string,\n  onClass: (startIndex: number, endIndex: number, quote: string) => false | unknown,\n): void {\n  let mode = MODE_TEXT\n  let startIndex = 0\n  let quote = ''\n  let attributeName = ''\n\n  const commit = (currentIndex: number): void => {\n    if (mode == MODE_ATTRIBUTE && attributeName == 'class') {\n      if (onClass(startIndex, currentIndex, quote) === false) {\n        markup = ''\n      }\n    }\n  }\n\n  for (let position = 0; position < markup.length; position++) {\n    const char = markup[position]\n\n    if (mode == MODE_TEXT) {\n      if (char == '<') {\n        mode = markup.substr(position + 1, 3) == '!--' ? MODE_COMMENT : MODE_TAGNAME\n      }\n    } else if (mode == MODE_COMMENT) {\n      // Ignore everything until the last three characters are '-', '-' and '>'\n      if (char == '>' && markup.slice(position - 2, position) == '--') {\n        mode = MODE_TEXT\n      }\n    } else if (quote) {\n      if (char == quote && markup[position - 1] != '\\\\') {\n        commit(position)\n        mode = MODE_WHITESPACE\n        quote = ''\n      }\n    } else if (char == '\"' || char == \"'\") {\n      quote = char\n      startIndex += 1\n    } else if (char == '>') {\n      commit(position)\n      mode = MODE_TEXT\n    } else if (!mode) {\n      // MODE_SLASH\n      // Ignore everything until the tag ends\n    } else if (char == '=') {\n      attributeName = markup.slice(startIndex, position)\n      mode = MODE_ATTRIBUTE\n      startIndex = position + 1\n    } else if (char == '/' && (mode < MODE_ATTRIBUTE || markup[position + 1] == '>')) {\n      commit(position)\n      mode = MODE_SLASH\n    } else if (/\\s/.test(char)) {\n      // <a class=font-bold>\n      commit(position)\n      mode = MODE_WHITESPACE\n      startIndex = position + 1\n    }\n  }\n}\n\nexport function fixClassList(value: string, quote: string): string {\n  // const value = markup.slice(startIndex, endIndex)\n\n  // Lets handle some special react cases:\n  //   * arbitrary values for `content-`\n  //     <span class=\"before:content-[&#x27;asas&#x27;]\"></span>\n  //     <span class=\"before:content-[&quot;asas&quot;]\"></span>\n  //\n  //   * self-referenced groups\n  //     <span class=\"flex(&amp; col)\"></span>\n  //\n  //     If a class name contains `'`, `\"`, or `&` those will be replaced with HTML entities\n  //     To fix this we replace those for depending on the actual symbol that is being used\n  //     As an alternative we could always escape class names direcly in twind like react does\n  //     but this works for now\n  return (\n    quote == `\"`\n      ? // `'` -> &#39; &apos; &#x27;\n        value.replace(/(=|\\[)(?:&#39;|&apos;|&#x27;)|(?:&#39;|&apos;|&#x27;)(])/g, `$1'$2`)\n      : quote == `'`\n      ? // `\"` -> &#34; &quot; &#x22;\n        value.replace(/(=|\\[)(?:&#34;|&quot;|&#x22;)|(?:&#34;|&quot;|&#x22;)(])/g, `$1\"$2`)\n      : value\n  ).replace(/(&#38;|&amp;|&#x26;)/g, '&')\n}\n","import type { ParsedDevRule } from '@twind/core'\n\nexport function adjustRuleLocation(\n  token: string,\n  rule: ParsedDevRule,\n  offset: number,\n): { start: number; end: number } {\n  let start = rule.l[0]\n  const end = rule.l[1]\n  let index = rule.a.length\n  let value = rule.a[--index]\n\n  while (index--) {\n    const active = rule.a[index]\n\n    if (active == '(' || active == '&' || /[~@]$/.test(active)) {\n      break\n    }\n\n    value = active + value\n    if (token.slice(start - active.length, end) === value) {\n      start -= active.length\n    } else {\n      break\n    }\n  }\n\n  return {\n    start: offset + start,\n    end: offset + end,\n  }\n}\n","import type { ParsedDevRule } from '@twind/core'\nimport type { ColorInformation, Diagnostics, DocumentationAt } from '../types'\nimport type { IntellisenseContext, Boundary } from '../internal/types'\n\nimport csstreeParse from 'css-tree/parser'\nimport csstreeWalk from 'css-tree/walker'\nimport csstreeGenerate from 'css-tree/generator'\n\nimport { parse } from '@twind/core'\nimport { fixClassList, parseHTML } from '../../../core/src/internal/parse-html'\nimport { toClassName } from '../../../core/src/internal/to-class-name'\n\nimport { editabelColorRe, parseColor } from '../internal/color'\nimport { adjustRuleLocation } from '../internal/adjust-rule-location'\n\nexport function documentationAt(\n  content: string,\n  offset: number,\n  { isIgnored }: IntellisenseContext,\n): DocumentationAt | null {\n  let result: DocumentationAt | null = null\n\n  parseHTML(content, (startIndex, endIndex, quote) => {\n    if (startIndex <= offset && offset < endIndex) {\n      // offset is within this classList\n      const token = content.slice(startIndex, endIndex)\n\n      // TODO: after fixClassList the positions maybe invalid\n      const rules = parse(fixClassList(token, quote)) as ParsedDevRule[]\n\n      for (const rule of rules) {\n        const start = startIndex + rule.l[0]\n        const end = startIndex + rule.l[1]\n\n        if (start <= offset && offset < end) {\n          // found our rule\n          if (!isIgnored(rule.n)) {\n            result = {\n              ...adjustRuleLocation(token, rule, startIndex),\n              value: toClassName(rule),\n            }\n          }\n\n          return false\n        }\n\n        if (offset < end) {\n          return false\n        }\n      }\n\n      return false\n    }\n\n    if (offset < startIndex) {\n      return false\n    }\n  })\n\n  return result\n}\n\nexport function collectColors(\n  content: string,\n  { classes, isIgnored }: IntellisenseContext,\n): ColorInformation[] {\n  const colors: ColorInformation[] = []\n\n  parseHTML(content, (startIndex, endIndex, quote) => {\n    const token = content.slice(startIndex, endIndex)\n    const rules = parse(fixClassList(token, quote)) as ParsedDevRule[]\n\n    for (const rule of rules) {\n      if (isIgnored(rule.n)) continue\n\n      const completion = classes.get(rule.n)\n\n      if (completion?.color) {\n        const color = parseColor(completion.color)\n\n        if (color) {\n          colors.push({\n            ...adjustRuleLocation(token, rule, startIndex),\n            value: completion.color,\n            rgba: color,\n          })\n\n          continue\n        }\n      }\n\n      const editableMatch = rule.n.match(editabelColorRe)\n\n      if (editableMatch) {\n        const { 1: currentColor } = editableMatch\n        const color = parseColor(currentColor)\n\n        if (color) {\n          colors.push({\n            ...adjustRuleLocation(token, rule, startIndex),\n            value: currentColor,\n            rgba: color,\n            editable: true,\n          })\n\n          continue\n        }\n      }\n    }\n  })\n\n  return colors\n}\n\nexport function validate(\n  content: string,\n  { variants, classes, isIgnored, generateCSS }: IntellisenseContext,\n): Diagnostics[] {\n  const diagnostics: Diagnostics[] = []\n\n  parseHTML(content, (startIndex, endIndex, quote) => {\n    const token = content.slice(startIndex, endIndex)\n    const rules = parse(fixClassList(token, quote)) as ParsedDevRule[]\n\n    for (const rule of rules) {\n      if (isIgnored(rule.n)) continue\n\n      const css = generateCSS(rule.n)\n\n      const ast = csstreeParse(css, {\n        positions: false,\n        parseAtrulePrelude: false,\n        parseRulePrelude: false,\n        parseValue: false,\n        parseCustomProperty: false,\n        onParseError(error) {\n          diagnostics.push({\n            ...adjustRuleLocation(token, rule, startIndex),\n            code: 'invalidCSS',\n            message: `Failed to parse CSS of class ${JSON.stringify(rule.n)}: ${error.message}`,\n            severity: 'error',\n            value: rule.n,\n          })\n        },\n      })\n\n      if (ast) {\n        // TODO: csstree-validator uses createRequire to fetch mdn-data -> this does not work in the browser\n        // if (typeof document !== 'object') {\n        //   const cssValidator = await import('csstree-validator')\n\n        //   // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        //   for (const error of cssValidator.validate(ast)) {\n        //     diagnostics.push({\n        //       ...adjustRuleLocation(token, rule, startIndex),\n        //       code: 'invalidCSS',\n        //       // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        //       message: error.message,\n        //       severity: 'warning',\n        //       value: rule.n,\n        //     })\n        //   }\n        // }\n\n        if (typeof document == 'object') {\n          csstreeWalk(ast, {\n            visit: 'SelectorList',\n            enter(node) {\n              const selector = csstreeGenerate(node)\n              try {\n                document.querySelector(selector)\n              } catch (error) {\n                // Some thrown errors are because of specific pseudo classes\n                // lets filter them to prevent unnecessary warnings\n                // ::-moz-focus-inner\n                // :-moz-focusring\n                if (/:(-webkit-|-moz-|-ms-)/.test(selector)) {\n                  diagnostics.push({\n                    ...adjustRuleLocation(token, rule, startIndex),\n                    code: 'invalidCSS',\n                    message: `Vendor specific selector ${JSON.stringify(\n                      selector,\n                    )} for class ${JSON.stringify(rule.n)}`,\n                    severity: 'hint',\n                    value: rule.n,\n                  })\n                } else {\n                  diagnostics.push({\n                    ...adjustRuleLocation(token, rule, startIndex),\n                    code: 'invalidCSS',\n                    message: `Invalid selector ${JSON.stringify(\n                      selector,\n                    )} for class ${JSON.stringify(rule.n)}`,\n                    severity: 'warning',\n                    value: rule.n,\n                  })\n                }\n              }\n            },\n          })\n        }\n      }\n\n      if (!(classes.has(rule.n) || css)) {\n        diagnostics.push({\n          ...adjustRuleLocation(token, rule, startIndex),\n          code: 'invalidClass',\n          message: `Invalid class ${JSON.stringify(rule.n)}`,\n          severity: 'error',\n          value: rule.n,\n        })\n      }\n\n      for (const variant of rule.v) {\n        const className = variant + ':' + rule.n\n        if (isIgnored(className)) continue\n\n        const css = generateCSS(className)\n\n        const ast = csstreeParse(css, {\n          positions: false,\n          parseAtrulePrelude: false,\n          parseRulePrelude: false,\n          parseValue: false,\n          parseCustomProperty: false,\n          onParseError(error) {\n            diagnostics.push({\n              ...adjustRuleLocation(token, rule, startIndex),\n              code: 'invalidCSS',\n              message: `Failed to parse CSS of variant ${JSON.stringify(variant)}: ${\n                error.message\n              }`,\n              severity: 'error',\n              value: rule.n,\n            })\n          },\n        })\n\n        if (ast) {\n          if (typeof document == 'object') {\n            csstreeWalk(ast, {\n              visit: 'SelectorList',\n              enter(node) {\n                const selector = csstreeGenerate(node)\n                try {\n                  document.querySelector(selector)\n                } catch {\n                  // Some thrown errors are because of specific pseudo classes\n                  // lets filter them to prevent unnecessary warnings\n                  // ::-moz-focus-inner\n                  // :-moz-focusring\n                  if (/:(-webkit-|-moz-|-ms-)/.test(selector)) {\n                    diagnostics.push({\n                      ...adjustRuleLocation(token, rule, startIndex),\n                      code: 'invalidCSS',\n                      message: `Vendor specific selector ${JSON.stringify(\n                        selector,\n                      )} for variant ${JSON.stringify(variant)}`,\n                      severity: 'hint',\n                      value: rule.n,\n                    })\n                  } else {\n                    diagnostics.push({\n                      ...adjustRuleLocation(token, rule, startIndex),\n                      code: 'invalidCSS',\n                      message: `Invalid selector ${JSON.stringify(\n                        selector,\n                      )} for variant ${JSON.stringify(variant)}`,\n                      severity: 'warning',\n                      value: rule.n,\n                    })\n                  }\n                }\n              },\n            })\n          }\n        }\n\n        if (!(variants.has(variant + ':') || css)) {\n          diagnostics.push({\n            ...adjustRuleLocation(token, rule, startIndex),\n            code: 'invalidVariant',\n            message: `Invalid variant ${JSON.stringify(variant)}`,\n            severity: 'error',\n            value: variant,\n          })\n        }\n      }\n    }\n  })\n\n  return diagnostics\n}\n\nexport function extractBoundary(content: string, position: number): Boundary | null {\n  return (\n    find(`class=\"`, /[^\\\\]\"/) ||\n    find(`class='`, /[^\\\\]'/) ||\n    find(`class=`, /[\\s\"'`=;>]/) ||\n    // svelte class toggle\n    // 'class:...',\n    find(`class:`, /[\\s\"'/=]/)\n  )\n\n  function find(search: string, invalid: RegExp, before = /\\s/): Boundary | null {\n    const startIndex = content.lastIndexOf(search, position)\n\n    // found and the char before is a white space\n    if (startIndex !== -1 && before.test(content[startIndex - 1])) {\n      const boundary = content.slice(startIndex + search.length, position)\n\n      // maybe an expression like class=\"{...}\"\n      // TODO: for now ignore expression\n      if (/{/.test(boundary[0])) {\n        return null\n      }\n\n      if (invalid.test(boundary)) {\n        return null\n      }\n\n      return { start: startIndex + search.length, end: position, content: boundary }\n    }\n\n    return null\n  }\n}\n","import type { ParsedRule } from '../parse'\n\nexport function toClassName(rule: ParsedRule): string {\n  return [...rule.v, (rule.i ? '!' : '') + rule.n].join(':')\n}\n"],"names":["parseHTML","markup","onClass","mode","startIndex","quote","attributeName","commit","currentIndex","position","length","char","substr","slice","MODE_TEXT","test","fixClassList","value","replace","adjustRuleLocation","token","rule","offset","start","l","end","index","a","active","documentationAt","content","isIgnored","result","endIndex","rules","parse","n","v","i","join","collectColors","classes","colors","completion","get","color","parseColor","push","rgba","editableMatch","match","editabelColorRe","currentColor","editable","validate","variants","generateCSS","diagnostics","css","ast","csstreeParse","positions","parseAtrulePrelude","parseRulePrelude","parseValue","parseCustomProperty","onParseError","error","code","message","JSON","stringify","severity","document","csstreeWalk","visit","enter","node","selector","csstreeGenerate","querySelector","has","variant","className","extractBoundary","find","search","invalid","before","lastIndexOf","boundary"],"mappings":"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"}