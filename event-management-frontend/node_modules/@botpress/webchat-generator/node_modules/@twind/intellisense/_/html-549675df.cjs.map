{"version":3,"file":"html-549675df.cjs","sources":["../../../core/src/internal/parse-html.ts","../../src/internal/adjust-rule-location.ts","../../src/languages/html.ts","../../../core/src/internal/to-class-name.ts"],"sourcesContent":["// For now we are using a simple parser adapted from htm (https://github.com/developit/htm/blob/master/src/build.mjs)\n// If we find any issues we can switch to something more sophisticated like\n// - https://github.com/acrazing/html5parser\n// - https://github.com/fb55/htmlparser2\n\nconst MODE_SLASH = 0\nconst MODE_TEXT = 1\nconst MODE_WHITESPACE = 2\nconst MODE_TAGNAME = 3\nconst MODE_COMMENT = 4\nconst MODE_ATTRIBUTE = 5\n\nexport function parseHTML(\n  markup: string,\n  onClass: (startIndex: number, endIndex: number, quote: string) => false | unknown,\n): void {\n  let mode = MODE_TEXT\n  let startIndex = 0\n  let quote = ''\n  let attributeName = ''\n\n  const commit = (currentIndex: number): void => {\n    if (mode == MODE_ATTRIBUTE && attributeName == 'class') {\n      if (onClass(startIndex, currentIndex, quote) === false) {\n        markup = ''\n      }\n    }\n  }\n\n  for (let position = 0; position < markup.length; position++) {\n    const char = markup[position]\n\n    if (mode == MODE_TEXT) {\n      if (char == '<') {\n        mode = markup.substr(position + 1, 3) == '!--' ? MODE_COMMENT : MODE_TAGNAME\n      }\n    } else if (mode == MODE_COMMENT) {\n      // Ignore everything until the last three characters are '-', '-' and '>'\n      if (char == '>' && markup.slice(position - 2, position) == '--') {\n        mode = MODE_TEXT\n      }\n    } else if (quote) {\n      if (char == quote && markup[position - 1] != '\\\\') {\n        commit(position)\n        mode = MODE_WHITESPACE\n        quote = ''\n      }\n    } else if (char == '\"' || char == \"'\") {\n      quote = char\n      startIndex += 1\n    } else if (char == '>') {\n      commit(position)\n      mode = MODE_TEXT\n    } else if (!mode) {\n      // MODE_SLASH\n      // Ignore everything until the tag ends\n    } else if (char == '=') {\n      attributeName = markup.slice(startIndex, position)\n      mode = MODE_ATTRIBUTE\n      startIndex = position + 1\n    } else if (char == '/' && (mode < MODE_ATTRIBUTE || markup[position + 1] == '>')) {\n      commit(position)\n      mode = MODE_SLASH\n    } else if (/\\s/.test(char)) {\n      // <a class=font-bold>\n      commit(position)\n      mode = MODE_WHITESPACE\n      startIndex = position + 1\n    }\n  }\n}\n\nexport function fixClassList(value: string, quote: string): string {\n  // const value = markup.slice(startIndex, endIndex)\n\n  // Lets handle some special react cases:\n  //   * arbitrary values for `content-`\n  //     <span class=\"before:content-[&#x27;asas&#x27;]\"></span>\n  //     <span class=\"before:content-[&quot;asas&quot;]\"></span>\n  //\n  //   * self-referenced groups\n  //     <span class=\"flex(&amp; col)\"></span>\n  //\n  //     If a class name contains `'`, `\"`, or `&` those will be replaced with HTML entities\n  //     To fix this we replace those for depending on the actual symbol that is being used\n  //     As an alternative we could always escape class names direcly in twind like react does\n  //     but this works for now\n  return (\n    quote == `\"`\n      ? // `'` -> &#39; &apos; &#x27;\n        value.replace(/(=|\\[)(?:&#39;|&apos;|&#x27;)|(?:&#39;|&apos;|&#x27;)(])/g, `$1'$2`)\n      : quote == `'`\n      ? // `\"` -> &#34; &quot; &#x22;\n        value.replace(/(=|\\[)(?:&#34;|&quot;|&#x22;)|(?:&#34;|&quot;|&#x22;)(])/g, `$1\"$2`)\n      : value\n  ).replace(/(&#38;|&amp;|&#x26;)/g, '&')\n}\n","import type { ParsedDevRule } from '@twind/core'\n\nexport function adjustRuleLocation(\n  token: string,\n  rule: ParsedDevRule,\n  offset: number,\n): { start: number; end: number } {\n  let start = rule.l[0]\n  const end = rule.l[1]\n  let index = rule.a.length\n  let value = rule.a[--index]\n\n  while (index--) {\n    const active = rule.a[index]\n\n    if (active == '(' || active == '&' || /[~@]$/.test(active)) {\n      break\n    }\n\n    value = active + value\n    if (token.slice(start - active.length, end) === value) {\n      start -= active.length\n    } else {\n      break\n    }\n  }\n\n  return {\n    start: offset + start,\n    end: offset + end,\n  }\n}\n","import type { ParsedDevRule } from '@twind/core'\nimport type { ColorInformation, Diagnostics, DocumentationAt } from '../types'\nimport type { IntellisenseContext, Boundary } from '../internal/types'\n\nimport csstreeParse from 'css-tree/parser'\nimport csstreeWalk from 'css-tree/walker'\nimport csstreeGenerate from 'css-tree/generator'\n\nimport { parse } from '@twind/core'\nimport { fixClassList, parseHTML } from '../../../core/src/internal/parse-html'\nimport { toClassName } from '../../../core/src/internal/to-class-name'\n\nimport { editabelColorRe, parseColor } from '../internal/color'\nimport { adjustRuleLocation } from '../internal/adjust-rule-location'\n\nexport function documentationAt(\n  content: string,\n  offset: number,\n  { isIgnored }: IntellisenseContext,\n): DocumentationAt | null {\n  let result: DocumentationAt | null = null\n\n  parseHTML(content, (startIndex, endIndex, quote) => {\n    if (startIndex <= offset && offset < endIndex) {\n      // offset is within this classList\n      const token = content.slice(startIndex, endIndex)\n\n      // TODO: after fixClassList the positions maybe invalid\n      const rules = parse(fixClassList(token, quote)) as ParsedDevRule[]\n\n      for (const rule of rules) {\n        const start = startIndex + rule.l[0]\n        const end = startIndex + rule.l[1]\n\n        if (start <= offset && offset < end) {\n          // found our rule\n          if (!isIgnored(rule.n)) {\n            result = {\n              ...adjustRuleLocation(token, rule, startIndex),\n              value: toClassName(rule),\n            }\n          }\n\n          return false\n        }\n\n        if (offset < end) {\n          return false\n        }\n      }\n\n      return false\n    }\n\n    if (offset < startIndex) {\n      return false\n    }\n  })\n\n  return result\n}\n\nexport function collectColors(\n  content: string,\n  { classes, isIgnored }: IntellisenseContext,\n): ColorInformation[] {\n  const colors: ColorInformation[] = []\n\n  parseHTML(content, (startIndex, endIndex, quote) => {\n    const token = content.slice(startIndex, endIndex)\n    const rules = parse(fixClassList(token, quote)) as ParsedDevRule[]\n\n    for (const rule of rules) {\n      if (isIgnored(rule.n)) continue\n\n      const completion = classes.get(rule.n)\n\n      if (completion?.color) {\n        const color = parseColor(completion.color)\n\n        if (color) {\n          colors.push({\n            ...adjustRuleLocation(token, rule, startIndex),\n            value: completion.color,\n            rgba: color,\n          })\n\n          continue\n        }\n      }\n\n      const editableMatch = rule.n.match(editabelColorRe)\n\n      if (editableMatch) {\n        const { 1: currentColor } = editableMatch\n        const color = parseColor(currentColor)\n\n        if (color) {\n          colors.push({\n            ...adjustRuleLocation(token, rule, startIndex),\n            value: currentColor,\n            rgba: color,\n            editable: true,\n          })\n\n          continue\n        }\n      }\n    }\n  })\n\n  return colors\n}\n\nexport function validate(\n  content: string,\n  { variants, classes, isIgnored, generateCSS }: IntellisenseContext,\n): Diagnostics[] {\n  const diagnostics: Diagnostics[] = []\n\n  parseHTML(content, (startIndex, endIndex, quote) => {\n    const token = content.slice(startIndex, endIndex)\n    const rules = parse(fixClassList(token, quote)) as ParsedDevRule[]\n\n    for (const rule of rules) {\n      if (isIgnored(rule.n)) continue\n\n      const css = generateCSS(rule.n)\n\n      const ast = csstreeParse(css, {\n        positions: false,\n        parseAtrulePrelude: false,\n        parseRulePrelude: false,\n        parseValue: false,\n        parseCustomProperty: false,\n        onParseError(error) {\n          diagnostics.push({\n            ...adjustRuleLocation(token, rule, startIndex),\n            code: 'invalidCSS',\n            message: `Failed to parse CSS of class ${JSON.stringify(rule.n)}: ${error.message}`,\n            severity: 'error',\n            value: rule.n,\n          })\n        },\n      })\n\n      if (ast) {\n        // TODO: csstree-validator uses createRequire to fetch mdn-data -> this does not work in the browser\n        // if (typeof document !== 'object') {\n        //   const cssValidator = await import('csstree-validator')\n\n        //   // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        //   for (const error of cssValidator.validate(ast)) {\n        //     diagnostics.push({\n        //       ...adjustRuleLocation(token, rule, startIndex),\n        //       code: 'invalidCSS',\n        //       // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        //       message: error.message,\n        //       severity: 'warning',\n        //       value: rule.n,\n        //     })\n        //   }\n        // }\n\n        if (typeof document == 'object') {\n          csstreeWalk(ast, {\n            visit: 'SelectorList',\n            enter(node) {\n              const selector = csstreeGenerate(node)\n              try {\n                document.querySelector(selector)\n              } catch (error) {\n                // Some thrown errors are because of specific pseudo classes\n                // lets filter them to prevent unnecessary warnings\n                // ::-moz-focus-inner\n                // :-moz-focusring\n                if (/:(-webkit-|-moz-|-ms-)/.test(selector)) {\n                  diagnostics.push({\n                    ...adjustRuleLocation(token, rule, startIndex),\n                    code: 'invalidCSS',\n                    message: `Vendor specific selector ${JSON.stringify(\n                      selector,\n                    )} for class ${JSON.stringify(rule.n)}`,\n                    severity: 'hint',\n                    value: rule.n,\n                  })\n                } else {\n                  diagnostics.push({\n                    ...adjustRuleLocation(token, rule, startIndex),\n                    code: 'invalidCSS',\n                    message: `Invalid selector ${JSON.stringify(\n                      selector,\n                    )} for class ${JSON.stringify(rule.n)}`,\n                    severity: 'warning',\n                    value: rule.n,\n                  })\n                }\n              }\n            },\n          })\n        }\n      }\n\n      if (!(classes.has(rule.n) || css)) {\n        diagnostics.push({\n          ...adjustRuleLocation(token, rule, startIndex),\n          code: 'invalidClass',\n          message: `Invalid class ${JSON.stringify(rule.n)}`,\n          severity: 'error',\n          value: rule.n,\n        })\n      }\n\n      for (const variant of rule.v) {\n        const className = variant + ':' + rule.n\n        if (isIgnored(className)) continue\n\n        const css = generateCSS(className)\n\n        const ast = csstreeParse(css, {\n          positions: false,\n          parseAtrulePrelude: false,\n          parseRulePrelude: false,\n          parseValue: false,\n          parseCustomProperty: false,\n          onParseError(error) {\n            diagnostics.push({\n              ...adjustRuleLocation(token, rule, startIndex),\n              code: 'invalidCSS',\n              message: `Failed to parse CSS of variant ${JSON.stringify(variant)}: ${\n                error.message\n              }`,\n              severity: 'error',\n              value: rule.n,\n            })\n          },\n        })\n\n        if (ast) {\n          if (typeof document == 'object') {\n            csstreeWalk(ast, {\n              visit: 'SelectorList',\n              enter(node) {\n                const selector = csstreeGenerate(node)\n                try {\n                  document.querySelector(selector)\n                } catch {\n                  // Some thrown errors are because of specific pseudo classes\n                  // lets filter them to prevent unnecessary warnings\n                  // ::-moz-focus-inner\n                  // :-moz-focusring\n                  if (/:(-webkit-|-moz-|-ms-)/.test(selector)) {\n                    diagnostics.push({\n                      ...adjustRuleLocation(token, rule, startIndex),\n                      code: 'invalidCSS',\n                      message: `Vendor specific selector ${JSON.stringify(\n                        selector,\n                      )} for variant ${JSON.stringify(variant)}`,\n                      severity: 'hint',\n                      value: rule.n,\n                    })\n                  } else {\n                    diagnostics.push({\n                      ...adjustRuleLocation(token, rule, startIndex),\n                      code: 'invalidCSS',\n                      message: `Invalid selector ${JSON.stringify(\n                        selector,\n                      )} for variant ${JSON.stringify(variant)}`,\n                      severity: 'warning',\n                      value: rule.n,\n                    })\n                  }\n                }\n              },\n            })\n          }\n        }\n\n        if (!(variants.has(variant + ':') || css)) {\n          diagnostics.push({\n            ...adjustRuleLocation(token, rule, startIndex),\n            code: 'invalidVariant',\n            message: `Invalid variant ${JSON.stringify(variant)}`,\n            severity: 'error',\n            value: variant,\n          })\n        }\n      }\n    }\n  })\n\n  return diagnostics\n}\n\nexport function extractBoundary(content: string, position: number): Boundary | null {\n  return (\n    find(`class=\"`, /[^\\\\]\"/) ||\n    find(`class='`, /[^\\\\]'/) ||\n    find(`class=`, /[\\s\"'`=;>]/) ||\n    // svelte class toggle\n    // 'class:...',\n    find(`class:`, /[\\s\"'/=]/)\n  )\n\n  function find(search: string, invalid: RegExp, before = /\\s/): Boundary | null {\n    const startIndex = content.lastIndexOf(search, position)\n\n    // found and the char before is a white space\n    if (startIndex !== -1 && before.test(content[startIndex - 1])) {\n      const boundary = content.slice(startIndex + search.length, position)\n\n      // maybe an expression like class=\"{...}\"\n      // TODO: for now ignore expression\n      if (/{/.test(boundary[0])) {\n        return null\n      }\n\n      if (invalid.test(boundary)) {\n        return null\n      }\n\n      return { start: startIndex + search.length, end: position, content: boundary }\n    }\n\n    return null\n  }\n}\n","import type { ParsedRule } from '../parse'\n\nexport function toClassName(rule: ParsedRule): string {\n  return [...rule.v, (rule.i ? '!' : '') + rule.n].join(':')\n}\n"],"names":["parseHTML","markup","onClass","mode","startIndex","quote","attributeName","commit","currentIndex","position","length","char","substr","MODE_TAGNAME","slice","MODE_TEXT","test","fixClassList","value","replace","adjustRuleLocation","token","rule","offset","start","l","end","index","a","active","content","classes","isIgnored","colors","endIndex","rules","parse","n","completion","get","color","parseColor","push","rgba","editableMatch","match","editabelColorRe","currentColor","editable","result","v","i","join","find","search","invalid","before","lastIndexOf","boundary","variants","generateCSS","diagnostics","css","csstreeParse","positions","parseAtrulePrelude","parseRulePrelude","parseValue","parseCustomProperty","onParseError","error","code","message","JSON","stringify","severity","has","variant","className"],"mappings":"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"}