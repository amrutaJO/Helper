var _completion, _completion1, _completion2, _suggestion;
import { matchSorter } from 'match-sorter';
import cssbeautify from 'cssbeautify';
import QuickLRU from 'quick-lru';
import { twind, defineConfig, virtual, asArray, mql, getAutocompleteProvider, stringify, parse } from '@twind/core';
import genex from 'genex';
import { TinyColor, names } from '@ctrl/tinycolor';
/*
To set a bit: n |= mask;
To clear a bit: n &= ~mask;
To test if a bit is set: (n & mask)

Bit shifts for the primary bits:

| bits | trait                                                   | shift |
| ---- | ------------------------------------------------------- | ----- |
| 1    | dark mode                                               | 30    |
| 3    | layer: preflight, global, components, utilities, css    | 27    |
| 1    | screens: is this a responsive variation of a rule       | 26    |
| 4    | responsive based on min-width, max-width or width       | 22    |
| 4    | at-rules                                                | 18    |
| 18   | pseudo and group variants                               | 0     |

Layer: 0 - 7: 3 bits
  - defaults: 0 << 27
  - base: 1 << 27
  - components: 2 << 27
  - variants: 3 << 27
  - joints: 4 << 27
  - aliases: 5 << 27
  - utilities: 6 << 27
  - overrides: 7 << 27

These are calculated by serialize and added afterwards:

| bits | trait                               |
| ---- | ----------------------------------- |
| 4    | number of selectors (descending)    |
| 4    | number of declarations (descending) |
| 4    | greatest precedence of properties   |

These are added by shifting the primary bits using multiplication as js only
supports bit shift up to 32 bits.
*/ // Colon and dash count of string (ascending)
function seperatorPrecedence(string) {
    var _string_match;
    return (null == (_string_match = string.match(/[-=:;]/g)) ? void 0 : _string_match.length) || 0;
}
function atRulePrecedence(css) {
    // 0 - 15: 4 bits (max 144rem or 2304px)
    // rem -> bit
    // <20 ->  0 (<320px)
    //  20 ->  1 (320px)
    //  24 ->  2 (384px)
    //  28 ->  3 (448px)
    //  32 ->  4 (512px)
    //  36 ->  5 (576px)
    //  42 ->  6 (672px)
    //  48 ->  7 (768px)
    //  56 ->  8 (896px)
    //  64 ->  9 (1024px)
    //  72 -> 10 (1152px)
    //  80 -> 11 (1280px)
    //  96 -> 12 (1536px)
    // 112 -> 13 (1792px)
    // 128 -> 14 (2048px)
    // 144 -> 15 (2304px)
    // https://www.dcode.fr/function-equation-finder
    return Math.min(/(?:^|width[^\d]+)(\d+(?:.\d+)?)(p)?/.test(css) ? Math.max(0, 29.63 * (+RegExp.$1 / (RegExp.$2 ? 15 : 1)) ** 0.137 - 43) : 0, 15) << 22 | /* Shifts.responsive */ Math.min(seperatorPrecedence(css), 15) << 18;
}
function toCondition(value) {
    // "visible" -> /^visible$/
    // "(float)-(left|right|none)" -> /^(float)-(left|right|none)$/
    // "auto-rows-" -> /^auto-rows-/
    // "gap(-|$)" -> /^gap(-|$)/
    return 'string' == typeof value ? RegExp('^' + value + (value.includes('$') || '-' == value.slice(-1) ? '' : '$')) : value;
}
let simplePseudoClasses = [
    ':active',
    ':after',
    ':any-link',
    ':before',
    // ":blank", // Experimental
    ':checked',
    // ":current", // Experimental
    ':default',
    ':defined',
    ':disabled',
    ':empty',
    ':enabled',
    // ':first',
    ':first-child',
    ':first-letter',
    ':first-line',
    ':first-of-type',
    ':focus',
    ':focus-visible',
    ':focus-within',
    ':fullscreen',
    // ":future", // Experimental
    ':hover',
    ':in-range',
    ':indeterminate',
    ':invalid',
    ':last-child',
    ':last-of-type',
    ':link',
    // ":local-link", // Experimental
    // ":nth-col", // Experimental
    // ":nth-last-col", // Experimental
    ':only-child',
    ':only-of-type',
    ':optional',
    ':out-of-range',
    // ":past", // Experimental
    ':paused',
    ':picture-in-picture',
    ':placeholder-shown',
    ':playing',
    ':read-only',
    ':read-write',
    ':required',
    // ":root",
    // ":scope",
    ':target',
    // ":target-within", // Experimental
    // ":user-invalid", // Experimental
    // ":user-valid", // Experimental
    ':valid',
    ':visited'
], VARIANT_MARKER_RULE = /^…$/, colorNames = Object.keys(names), editabelColorRe = RegExp(`-\\[(${colorNames.join('|')}|(?:(?:#|(?:(?:hsl|rgb)a?|hwb|lab|lch|color)\\())[^]\\(]+)\\]$`, 'i'), colorCache = new QuickLRU({
    maxSize: 1000
});
function parseColor(value) {
    let result = colorCache.get(value);
    if (!result) {
        let color = new TinyColor(value);
        colorCache.set(value, result = color.isValid ? color.toRgb() : null);
    }
    return result;
}
function spacify(value) {
    return ('-' === value[0] ? '- ' : '') + value.replace(/[-\s]+/g, ' ');
}
let collator = new Intl.Collator('en', {
    numeric: true
});
function compareSuggestions(a, b, prefix) {
    // sort variants and classes
    let variantsFirst = !prefix;
    if ('variant' === a.type && 'class' === b.type) return variantsFirst ? -1 : 1;
    if ('class' === a.type && 'variant' === b.type) return variantsFirst ? 1 : -1;
    // Move special chars after "normal"
    if (!/^[-a-z\d]/i.test(a.value) && /^[-a-z\d]/i.test(b.value)) return 1;
    if (/^[-a-z\d]/i.test(a.value) && !/^[-a-z\d]/i.test(b.value)) return -1;
    let isVariant = 'variant' === a.type;
    // by min width
    if (isVariant) {
        var _a_description, _b_description;
        let aMinWidth = (null == (_a_description = a.description) ? void 0 : _a_description.startsWith('@')) && a.description.includes('min-width'), bMinWidth = (null == (_b_description = b.description) ? void 0 : _b_description.startsWith('@')) && b.description.includes('min-width');
        if (aMinWidth && !bMinWidth) return -1;
        if (!aMinWidth && bMinWidth) return 1;
        if (aMinWidth && bMinWidth) {
            let byAtRulePrecedence = atRulePrecedence(a.description) - atRulePrecedence(b.description);
            if (byAtRulePrecedence) return byAtRulePrecedence;
        }
    }
    // group by first part
    if (!prefix) {
        let aInitial = a.value.replace(/^-/, '').split('-', 1)[0], bInitial = b.value.replace(/^-/, '').split('-', 1)[0], byInitial = collator.compare(byName(aInitial), byName(bInitial));
        if (byInitial) return byInitial;
        // bump root class up
        if (a.value === aInitial && b.value !== bInitial) return -1;
        if (b.value === bInitial && a.value !== aInitial) return 1;
        let bySeperator = seperatorPrecedence(a.value) - seperatorPrecedence(b.value);
        if (bySeperator) return bySeperator;
    }
    // sort arbitrary values after other values
    let arbitrarySuffix = isVariant ? '[:' : '[';
    if (a.value.endsWith(arbitrarySuffix) && !b.value.endsWith(arbitrarySuffix)) return 1;
    if (!a.value.endsWith(arbitrarySuffix) && b.value.endsWith(arbitrarySuffix)) return -1;
    // sort modifier values after other values
    let modifierSuffix = isVariant ? '/:' : '/';
    if (a.value.endsWith(modifierSuffix) && !b.value.endsWith(modifierSuffix)) return 1;
    if (!a.value.endsWith(modifierSuffix) && b.value.endsWith(modifierSuffix)) return -1;
    if (!isVariant) {
        // opacity last
        if (a.value.includes('-opacity') && !b.value.includes('-opacity')) return 1;
        if (!a.value.includes('-opacity') && b.value.includes('-opacity')) return -1;
        // color next to last
        if (a.color && !b.color) return 1;
        if (!a.color && b.color) return -1;
    }
    // keep same rules together
    let byIndex = b.index - a.index;
    if (byIndex) return byIndex;
    // group by source
    if (a.source === b.source) {
        // sort negative classes after regular one
        if (a.value.startsWith('-') && !b.value.startsWith('-')) return 1;
        if (!a.value.startsWith('-') && b.value.startsWith('-')) return -1;
    }
    return collator.compare(byName(a.value), byName(b.value));
}
function byName(s) {
    return (s || '').replace(/\W/g, (c)=>String.fromCharCode(127 + c.charCodeAt(0))) + '\x00';
}
let MDN = 'https://developer.mozilla.org';
function createIntellisense(config, options = {}) {
    let suggestionCache = new QuickLRU({
        maxSize: 1000,
        ...options.cache
    }), documentationCache = new QuickLRU({
        maxSize: 1000,
        ...options.cache
    }), context = function(config, options = {}) {
        let tw = twind(defineConfig({
            hash: false,
            preflight: false,
            // disable autoprefix
            stringify (property, value) {
                return property + ':' + value;
            },
            presets: [
                defineConfig('function' == typeof config ? config.config : config)
            ],
            rules: [
                // Allows to generate CSS for a variant
                [
                    VARIANT_MARKER_RULE,
                    {
                        '…': '…'
                    }
                ]
            ],
            ignorelist: [
                // Prevent invalid class warning when generating documentation
                /-\[…]$/
            ]
        }), virtual(true)), ignorelist = asArray(tw.config.ignorelist).map(toCondition), isIgnored = (className)=>ignorelist.some((re)=>re.test(className)), variants = new Map(), classes = new Map(), suggestions = [], cssCache = new QuickLRU({
            maxSize: 1000,
            ...options.cache
        }), add = (target, { modifiers , ...completion })=>{
            if ('class' === completion.type && isIgnored(completion.name)) return;
            if (target.has(completion.name) && JSON.stringify(target.get(completion.name), [
                'type',
                'name'
            ]) !== JSON.stringify(completion, [
                'type',
                'name'
            ])) console.warn(`Duplicate ${completion.type}: ${JSON.stringify(completion.name)}`);
            else {
                (_completion = completion).value || (_completion.value = completion.name);
                (_completion1 = completion).filter || (_completion1.filter = spacify(completion.value));
                (_completion2 = completion).description || (_completion2.description = '');
                target.set(completion.name, completion);
                suggestions.push(completion);
                if (modifiers && modifiers.length) {
                    suggestions.push({
                        ...completion,
                        name: completion.name + '/',
                        value: completion.value + '/',
                        filter: spacify(completion.value + '/'),
                        description: ''
                    });
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    completion.modifiers = modifiers.map(({ modifier , theme , color , label  }, position)=>({
                            ...completion,
                            position,
                            name: `${completion.name}/${modifier}`,
                            value: `${completion.value}/${modifier}`,
                            filter: spacify(modifier),
                            description: label || '',
                            theme,
                            color: color && parseColor(color) ? color : void 0
                        })).filter((suggestion)=>{
                        return !('class' === completion.type && isIgnored(completion.name)) && (target.set(suggestion.name, suggestion), true);
                    });
                }
            }
        }, deferreds = [], context = {
            get theme () {
                return tw.theme;
            },
            get variants () {
                return Object.fromEntries(Array.from(variants.values(), (variant)=>[
                        variant.name.slice(0, -1),
                        variant.description || variant.name
                    ]));
            }
        }, nextIndex = 0;
        for (let screen of Object.keys(tw.theme('screens'))){
            let name = screen + ':';
            add(variants, {
                type: 'variant',
                source: "theme('screens')",
                index: nextIndex++,
                position: variants.size,
                name,
                theme: {
                    section: 'screens',
                    key: screen
                },
                description: mql(tw.theme('screens', screen))
            });
        }
        for (let [pattern, resolver] of tw.config.variants){
            let index = nextIndex++, position = 0, provider = 'function' == typeof resolver && getAutocompleteProvider(resolver);
            for (let value of asArray(pattern)){
                let condition = toCondition(value), source = condition.toString(), re = RegExp(condition.source.replace(/\\[dw][*+?]*/g, '\0'), condition.flags), pattern1 = genex(re), count = pattern1.count();
                count === 1 / 0 ? provider ? deferreds.push(()=>{
                    let match = Object.create([
                        String(value)
                    ], {
                        index: {
                            value: 0
                        },
                        input: {
                            value: String(value)
                        },
                        $$: {
                            value: ''
                        }
                    });
                    for (let completion of provider(match, context))'string' == typeof completion ? add(variants, {
                        type: 'variant',
                        source,
                        index,
                        position: position++,
                        name: completion + ':'
                    }) : add(variants, {
                        type: 'variant',
                        source,
                        index,
                        position: position++,
                        name: (completion.prefix || '') + (completion.suffix || '') + ':',
                        theme: completion.theme,
                        description: completion.label,
                        modifiers: completion.modifiers
                    });
                }) : console.warn(`Can not generate completion for variant ${condition}: infinite possibilities`) : pattern1.generate((value)=>{
                    let match = re.exec(value);
                    if (match) {
                        match.$$ = value.slice(match[0].length);
                        let base = value.replace(/\0/g, '');
                        if (provider) {
                            var _completion_prefix, _completion_suffix;
                            for (let completion of provider(match, context))'string' == typeof completion ? add(variants, {
                                type: 'variant',
                                source,
                                index,
                                position: position++,
                                name: base + completion + ':',
                                description: ''
                            }) : add(variants, {
                                type: 'variant',
                                source,
                                index,
                                position: position++,
                                name: (null != (_completion_prefix = completion.prefix) ? _completion_prefix : base) + (null != (_completion_suffix = completion.suffix) ? _completion_suffix : '') + ':',
                                theme: completion.theme,
                                description: completion.label,
                                modifiers: completion.modifiers
                            });
                        } else value.includes('\0') || value.endsWith('-') ? console.warn(`Can not generate completion for variant ${condition} with ${JSON.stringify(value)}: missing provider`) : add(variants, {
                            type: 'variant',
                            source,
                            index,
                            position: position++,
                            name: value + ':',
                            description: 'string' == typeof resolver ? resolver : ''
                        });
                    }
                });
            }
        }
        for (let pseudoClass of simplePseudoClasses){
            let name1 = pseudoClass.slice(1) + ':';
            variants.has(name1) || add(variants, {
                type: 'variant',
                source: 'builtin',
                index: nextIndex++,
                position: variants.size,
                name: name1,
                value: name1,
                description: `&${pseudoClass}`
            });
        }
        if (deferreds.length) for (let deferred of deferreds)deferred();
        for (let rule of tw.config.rules){
            let [pattern2, resolver1] = asArray(rule), index1 = nextIndex++, position1 = 0, provider1 = 'function' == typeof resolver1 && getAutocompleteProvider(resolver1);
            for (let value1 of asArray(pattern2)){
                if (value1 === VARIANT_MARKER_RULE) continue;
                let condition1 = toCondition(value1), source1 = condition1.toString(), re1 = RegExp(condition1.source.replace(/\\[dw][*+?]*/g, '\0'), condition1.flags), pattern3 = genex(re1), count1 = pattern3.count();
                if (count1 === 1 / 0) {
                    if (provider1) {
                        let match = Object.create([
                            String(value1)
                        ], {
                            index: {
                                value: 0
                            },
                            input: {
                                value: String(value1)
                            },
                            $$: {
                                value: ''
                            }
                        });
                        for (let completion of provider1(match, context))'string' == typeof completion ? add(classes, {
                            type: 'class',
                            source: source1,
                            index: index1,
                            position: position1++,
                            name: completion
                        }) : add(classes, {
                            type: 'class',
                            source: source1,
                            index: index1,
                            position: position1++,
                            name: (completion.prefix || '') + (completion.suffix || ''),
                            theme: completion.theme,
                            description: completion.label,
                            color: completion.color && parseColor(completion.color) ? completion.color : void 0,
                            modifiers: completion.modifiers
                        });
                    } else console.warn(`Can not generate completion for rule ${condition1}: infinite possibilities`);
                } else pattern3.generate((name)=>{
                    let match = re1.exec(name);
                    if (match) {
                        match.$$ = name.slice(match[0].length);
                        let base = name.replace(/\0/g, '');
                        if (provider1) {
                            var _completion_prefix, _completion_suffix;
                            for (let completion of provider1(match, context))'string' == typeof completion ? add(classes, {
                                type: 'class',
                                source: source1,
                                index: index1,
                                position: position1++,
                                name: base + completion
                            }) : add(classes, {
                                type: 'class',
                                source: source1,
                                index: index1,
                                position: position1++,
                                name: (null != (_completion_prefix = completion.prefix) ? _completion_prefix : base) + (null != (_completion_suffix = completion.suffix) ? _completion_suffix : ''),
                                theme: completion.theme,
                                description: completion.label,
                                color: completion.color && parseColor(completion.color) ? completion.color : void 0,
                                modifiers: completion.modifiers
                            });
                        } else name.includes('\0') || name.endsWith('-') ? console.warn(`Can not generate completion for rule ${condition1} with ${JSON.stringify(name)}: missing provider`) : add(classes, {
                            type: 'class',
                            source: source1,
                            index: index1,
                            position: position1++,
                            name
                        });
                    }
                });
            }
        }
        return suggestions.sort(compareSuggestions), {
            tw,
            variants,
            classes,
            suggestions,
            isIgnored,
            generateCSS: (token)=>{
                let result = cssCache.get(token);
                if (!result) {
                    tw.clear();
                    let isVariant = variants.has(token), name = isVariant && token.endsWith('[:') ? `${token.slice(0, -1)}…]:` : token.endsWith('[') ? `${token}…]` : isVariant && token.endsWith('/:') ? `${token.slice(0, -1)}…:` : token.endsWith('/') ? `${token}…` : token;
                    if (isVariant) {
                        name.endsWith(':') || (name += ':');
                        name += '…';
                    }
                    tw(name);
                    let css = stringify(tw.target), needle = `,${name}*/`, startIndex = css.indexOf(needle);
                    if (-1 === startIndex) result = css;
                    else {
                        let nextDeclarationStart = css.indexOf('/*', startIndex);
                        result = css.slice(startIndex + needle.length, -1 !== nextDeclarationStart ? nextDeclarationStart : css.length);
                    }
                    isVariant && (result = result.replace(/…:…;?/, ''));
                    cssCache.set(token, result);
                }
                return result;
            }
        };
    }(config, options), { mdnOrigin =MDN  } = options;
    // Precache empty input as it is the most common and take a while
    suggestionCache.set('', context.suggestions.map(toSuggestion));
    function toSuggestion(suggestion) {
        return 'variant' === suggestion.type ? {
            type: suggestion.type,
            name: suggestion.name,
            value: suggestion.value,
            description: suggestion.description,
            detail: suggestion.detail,
            color: suggestion.color
        } : {
            type: suggestion.type,
            name: suggestion.name,
            value: suggestion.value,
            description: (_suggestion = suggestion).description || (_suggestion.description = function(className) {
                let css = context.generateCSS(className), bodyStart = css.lastIndexOf('{'), bodyEnd = css.indexOf('}');
                return -1 === bodyStart || -1 === bodyEnd ? css : cssbeautify(`.x{${css.slice(bodyStart + 1, bodyEnd)}}`, {
                    indent: ''
                }).split('\n').slice(1, -1).join(' ');
            }(suggestion.name)),
            detail: suggestion.detail,
            color: suggestion.color
        };
    }
    let mdnIndexPromise = null, mdnCache = new QuickLRU({
        maxSize: 1000,
        ...options.cache
    });
    return {
        get theme () {
            return context.tw.theme;
        },
        get config () {
            return context.tw.config;
        },
        // eslint-disable-next-line @typescript-eslint/require-await
        async suggest (input, { prefix ='' , ignore  } = {}) {
            let key = JSON.stringify({
                input,
                prefix,
                ignore
            }), result = suggestionCache.get(key);
            if (!result) {
                let source = context.suggestions, threshold = matchSorter.rankings.MATCHES, token = prefix + input, match = /^(.+(?:-\[.+])?)\/([^/]+|\[.+])?$/.exec(token);
                if (match) {
                    let { 1: key1 , 2: modifier = ''  } = match, suggestion = context.classes.get(key1) || context.variants.get(key1);
                    if (null == suggestion ? void 0 : suggestion.modifiers) {
                        source = null == suggestion ? void 0 : suggestion.modifiers;
                        input = modifier;
                    }
                }
                if ('-' === token[0]) {
                    source = source.filter(({ name  })=>'-' === name[0]);
                    prefix ? prefix = prefix.slice(1) : input = input.slice(1);
                }
                (null == ignore ? void 0 : ignore.length) && (source = source.filter(({ value  })=>!ignore.includes(value)));
                prefix && (source = source.filter(({ type , value  })=>'variant' === type || value.startsWith(prefix)).map((suggestion)=>'variant' === suggestion.type ? suggestion : {
                        ...suggestion,
                        filter: spacify(suggestion.value.slice(prefix.length)),
                        value: suggestion.value.slice(prefix.length)
                    }));
                let { length  } = input.replace(/[-\s]+/g, '');
                if (0 === length) {
                    prefix && (source = source.sort((a, b)=>compareSuggestions(a, b, prefix)));
                    suggestionCache.set(key, result = source.map(toSuggestion));
                } else {
                    length < 2 && (threshold = matchSorter.rankings.CONTAINS);
                    // TODO: spacify should ignore `[...]`
                    let search = spacify(input);
                    suggestionCache.set(key, result = matchSorter(source, search, {
                        keys: [
                            'filter'
                        ],
                        threshold,
                        baseSort: (a, b)=>compareSuggestions(a.item, b.item, prefix)
                    }).map(toSuggestion));
                }
            }
            return result;
        },
        async suggestAt (content, position, language) {
            // html: class="..." | class='...' | class=...
            // markdown, mdx: <html>
            // javascript|typescript: "..." | '...' | `...`
            //  TODO: lit: html`...`
            // javascriptreact, typescriptreact: className="..." | className='...'| className={<js>} | class={<js>} | <html>
            // svelte: class:...= | class={<js>} | class="{<js>}" | class='{<js>}' | <html> | <js>
            // vue, vue-html: <html> | <js> | :class="{<js>}"> | :class="[<js>]"> // TODO :class="{underline: true}"
            // alpinejs: x-bind:class="! open ? 'hidden' : ''"
            // solidjs: classList={{ active: state.active, editing: state.currentId === row.id }}
            // TODO: *react, svelte
            // TODO: autocomplete for theme(): https://github.com/tailwindlabs/tailwindcss-intellisense/blob/1f1c3fcd7978865aff06fa1f8616c6b6447c1fa1/packages/tailwindcss-language-server/src/language/cssServer.ts#L159
            let { extractBoundary  } = 'html' === language ? await import('./html-ff866398.js') : {
                extractBoundary: (content, position)=>{
                    let start = Math.max(content.lastIndexOf(' ', position), content.lastIndexOf('\n', position), content.lastIndexOf('\t', position)) + 1, end = content.indexOf(' ', start);
                    return -1 === end && (end = content.indexOf('\n', start)), -1 === end && (end = content.indexOf('\t', start)), -1 === end && (end = content.length), {
                        start,
                        end,
                        content: content.slice(start, end)
                    };
                }
            }, boundary = extractBoundary(content, position);
            if (!boundary) return null;
            let isEmptyPosition = !boundary.content || /[\s():/!-@]$/.test(boundary.content), parsed = parse(boundary.content + (isEmptyPosition ? '\uffff' : '')), rule = parsed[parsed.length - 1];
            if (!rule || context.isIgnored(rule.n)) return null;
            let active = isEmptyPosition ? rule.a.slice(0, -1) : rule.a, negated = false, parts = [];
            for (let value of active){
                if ('(' == value || /[~@]$/.test(value)) {
                    parts.push('');
                    continue;
                }
                '!' == value[0] && (value = value.slice(1));
                if (value.endsWith(':')) {
                    parts.push('');
                    continue;
                }
                if ('-' == value[0]) {
                    value = value.slice(1);
                    negated = !negated;
                }
                value.endsWith('-') && (value = value.slice(0, -1));
                value && '&' != value && parts.push(value);
            }
            let prefix = (negated ? '-' : '') + parts.slice(0, -1).filter(Boolean).join('-');
            prefix && negated ? prefix = '-' + prefix + '-' : prefix && (prefix += '-');
            let input = (isEmptyPosition ? rule.n.replace(/\uffff$/, '') : rule.n).slice(prefix.length);
            return {
                start: position - input.length,
                end: position,
                suggestions: await this.suggest(input, {
                    prefix,
                    ignore: rule.v.map((v)=>v + ':')
                })
            };
        },
        // eslint-disable-next-line @typescript-eslint/require-await
        async documentationFor (token, { format ='md'  } = {}) {
            let theme;
            if (documentationCache.has(token)) return convert(documentationCache.get(token), format);
            let rule = parse(token)[0] || {
                n: token.endsWith(':') ? '' : token,
                v: token.endsWith(':') ? [
                    token
                ] : []
            }, css = cssbeautify(context.generateCSS(token), {
                autosemicolon: true,
                indent: '  '
            }), // { title: "display", url: "/en-US/docs/Web/CSS/display" },
            // { title: "@media", url: "/en-US/docs/Web/CSS/@media" },
            // { title: "prefers-contrast", url: "/en-US/docs/Web/CSS/@media/prefers-contrast" }
            // https://developer.mozilla.org/en-US/docs/Web/CSS/@media/index.json
            // {doc: { summary: "", "browserCompat": [ "css.properties.display" ] },
            // https://caniuse.com/mdn-css_properties_display
            mdnIndex = await (mdnIndexPromise || (mdnIndexPromise = (async ()=>{
                try {
                    let response = await fetch(`${mdnOrigin}/en-US/search-index.json`);
                    if (response.ok && 200 === response.status) {
                        let index = await response.json();
                        return index.filter(({ url  })=>url.includes('/CSS/'));
                    }
                } catch (error) {
                    console.warn('Failed to fetch MDN index');
                }
                return [];
            })())), cssFeatureLinks = mdnIndex.length && await Promise.all(Array.from(css.matchAll(/\\[!"'`*+.,;:\\/<=>?@#$%&^|~()[\]{}]|(@\S+|:?:[a-z-]+(?:\([^)]+\))?|[a-z-]+:)/g), (match)=>{
                let candidate = match[1];
                if (candidate && !candidate.startsWith('-')) {
                    // color: transparent
                    // @media (prefers-contrast:) -> @media, prefers-contrast
                    // &:hover -> :hover, hover
                    // ::backdrop -> ::backdrop, backdrop
                    // :nth-child(odd) -> :nth-child(odd), :nth-child(), :nth-child, nth-child
                    let candidates = new Set([
                        candidate,
                        // :nth-child(odd) -> :nth-child()
                        candidate.replace(/\(.+?\)/g, '()'),
                        // :nth-child(odd) -> :nth-child
                        candidate.replace(/\(.*?\)/g, ''),
                        // :nth-child(odd) -> nth-child
                        // ::backdrop -> backdrop
                        candidate.replace(/\(.*?\)|[^a-z-]+/gi, '')
                    ]);
                    for (let candidate1 of candidates){
                        let found = mdnIndex.find(({ title  })=>title === candidate1);
                        if (found) return {
                            match,
                            mdn: found
                        };
                    }
                }
            }).filter((result, index, list)=>result && list.indexOf(result) === index).map(async (result)=>{
                let cached = mdnCache.get(result.mdn.url);
                cached || mdnCache.set(result.mdn.url, cached = (async ()=>{
                    try {
                        let response = await fetch(`${mdnOrigin}${result.mdn.url}/index.json`);
                        // http://www.whateverorigin.org/get?url=https://developer.mozilla.org/en-US/search-index.json
                        // http://www.whateverorigin.org/get?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fsearch-index.json
                        // https://cors-anywhere.herokuapp.com/https://developer.mozilla.org/en-US/search-index.json
                        // https://mdn-twind-run.sastan.workers.dev/en-US/search-index.json
                        if (response.ok && 200 === response.status) {
                            let index = await response.json();
                            return {
                                title: index.doc.title,
                                summary: index.doc.summary,
                                browserCompat: index.doc.browserCompat
                            };
                        }
                    } catch (error) {
                        console.warn('Failed to fetch MDN index');
                    }
                    return {
                        title: result.mdn.title
                    };
                })());
                let { title , browserCompat  } = await cached, links = [
                    `[Documentation](${MDN}${result.mdn.url})`,
                    (null == browserCompat ? void 0 : browserCompat[0]) && `[Browser Support](https://caniuse.com/mdn-${browserCompat[0].replace(/\./g, '_')})`
                ].filter(Boolean).join(' • ');
                return `⁃ \`${title}\` (${links})`;
            })), sources = [];
            // TODO: arbitrary class/variant lookup would not work
            for (let completion of [
                ...rule.v.map((v)=>context.variants.get(v + ':')),
                context.classes.get(rule.n)
            ]){
                if (!completion) continue;
                let links = // regexp -> create links to Regex101 and Regexper
                completion.source.startsWith('/') && completion.source.endsWith('/') ? `[Regex101](https://regex101.com/?flavor=JavaScript&regex=${encodeURIComponent(completion.source.slice(1, -1))}&testString=${encodeURIComponent(completion.value)}) • [Regexper](https://regexper.com/#${encodeURIComponent(completion.source)})` : '';
                sources.push(`⁃ \`${completion.name}\` → \`${completion.source}\`${links && ' (' + links + ')'}`);
                if (completion.theme) {
                    var _context_tw_theme;
                    let { section , key  } = completion.theme, keys = completion.color || /color|fill|stroke/i.test(section) ? key.replace(/-/g, '.').split('.') : [
                        key
                    ], // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    obj = (theme || (theme = {}))[section] = {};
                    for(; keys.length;)// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    obj = obj[keys.shift()] = keys.length ? {} : null != (_context_tw_theme = context.tw.theme(section, key)) ? _context_tw_theme : '…';
                }
            }
            let result = [
                css && '```css\n' + css + '\n```',
                cssFeatureLinks && cssFeatureLinks.length && `### CSS Features\n\n${cssFeatureLinks.join('<br>')}\n`,
                theme && '### Theme\n\n```json\n' + JSON.stringify(theme, null, 2) + '\n```',
                sources.length && `### Source\n\n${sources.join('<br>')}\n`
            ].filter(Boolean).join('\n\n') || null;
            return documentationCache.set(token, result), convert(result, format);
        },
        async documentationAt (content, offset, language) {
            let result = null;
            if ('html' === language) {
                let { documentationAt  } = await import('./html-ff866398.js');
                result = documentationAt(content, offset, context);
            }
            if (result) {
                let documentation = await this.documentationFor(result.value);
                if (documentation) return {
                    ...result,
                    value: documentation
                };
            }
            return null;
        },
        async collectColors (content, language) {
            if ('html' === language) {
                let { collectColors  } = await import('./html-ff866398.js');
                return collectColors(content, context);
            }
            return [];
        },
        async validate (content, language) {
            if ('html' === language) {
                let { validate  } = await import('./html-ff866398.js');
                return validate(content, context);
            }
            return [];
        },
        *enumerate () {
            for (let completion of context.suggestions)yield toSuggestion(completion);
        }
    };
}
function convert(md, format) {
    return md && 'html' === format ? import('showdown').then((showdown)=>{
        let Converter = showdown.Converter || showdown.default.Converter, converter = new Converter({
            openLinksInNewWindow: true
        });
        return converter.setFlavor('github'), converter.makeHtml(md);
    }) : null != md ? md : null;
}
export { createIntellisense as c, editabelColorRe as e, parseColor as p };
//# sourceMappingURL=index-def1498f.js.map
