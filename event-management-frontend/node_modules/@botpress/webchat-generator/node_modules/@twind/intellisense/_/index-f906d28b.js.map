{"version":3,"file":"index-f906d28b.js","sources":["../../src/internal/create-context.ts","../../src/index.ts","../../../core/src/internal/precedence.ts","../../../core/src/internal/context.ts","../../src/internal/simple-pseudo-classes.ts","../../src/internal/constants.ts","../../src/internal/color.ts","../../src/internal/spacify.ts","../../src/internal/compare-suggestion.ts"],"sourcesContent":["import genex from 'genex'\n\nimport {\n  asArray,\n  type AutocompleteContext,\n  type AutocompleteItem,\n  defineConfig,\n  getAutocompleteProvider,\n  type MatchResult,\n  type MaybeArray,\n  mql,\n  type ScreenValue,\n  stringify,\n  twind,\n  type Twind,\n  type TwindConfig,\n  type TwindUserConfig,\n  virtual,\n} from '@twind/core'\n\nimport { toCondition } from '../../../core/src/internal/context'\n\nimport type { IntellisenseOptions } from '../types'\nimport type { IntellisenseContext, IntellisenseClass, IntellisenseVariant } from './types'\n\nimport { simplePseudoClasses } from './simple-pseudo-classes'\nimport { VARIANT_MARKER_RULE } from './constants'\nimport { parseColor } from './color'\nimport { spacify } from './spacify'\nimport { compareSuggestions } from './compare-suggestion'\nimport QuickLRU from 'quick-lru'\n\nexport function createIntellisenseContext(\n  config: Twind | TwindConfig | TwindUserConfig,\n  options: IntellisenseOptions = {},\n): IntellisenseContext {\n  const tw = twind(\n    defineConfig({\n      hash: false,\n      preflight: false,\n      // disable autoprefix\n      stringify(property, value) {\n        return property + ':' + value\n      },\n      presets: [\n        defineConfig((typeof config == 'function' ? config.config : config) as TwindUserConfig),\n      ],\n      rules: [\n        // Allows to generate CSS for a variant\n        [VARIANT_MARKER_RULE, { '…': '…' }],\n      ],\n      ignorelist: [\n        // Prevent invalid class warning when generating documentation\n        /-\\[…]$/,\n      ],\n    } as TwindUserConfig),\n    virtual(true),\n  )\n\n  const ignorelist = asArray(tw.config.ignorelist).map(toCondition)\n  const isIgnored = (className: string) => ignorelist.some((re) => re.test(className))\n  const variants: IntellisenseContext['variants'] = new Map()\n  const classes: IntellisenseContext['classes'] = new Map()\n  const suggestions: IntellisenseContext['suggestions'] = []\n\n  const cssCache = new QuickLRU<string, string>({ maxSize: 1000, ...options.cache })\n\n  const add = <T extends IntellisenseClass | IntellisenseVariant>(\n    target: Map<string, T>,\n    {\n      modifiers,\n      ...completion\n    }: Omit<T, 'filter' | 'value' | 'description' | 'modifiers'> & {\n      filter?: string\n      value?: string\n      description?: string\n      modifiers?: AutocompleteItem['modifiers']\n    },\n  ) => {\n    if (completion.type === 'class' && isIgnored(completion.name)) return\n\n    if (\n      target.has(completion.name) &&\n      JSON.stringify(target.get(completion.name), ['type', 'name']) !==\n        JSON.stringify(completion, ['type', 'name'])\n    ) {\n      console.warn(`Duplicate ${completion.type}: ${JSON.stringify(completion.name)}`)\n    } else {\n      completion.value ||= completion.name\n      completion.filter ||= spacify(completion.value)\n      completion.description ||= ''\n\n      target.set(completion.name, completion as T)\n      suggestions.push(completion as T)\n\n      if (modifiers && modifiers.length) {\n        suggestions.push({\n          ...(completion as T),\n          name: completion.name + '/',\n          value: completion.value + '/',\n          filter: spacify(completion.value + '/'),\n          description: '',\n        })\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        ;(completion as any).modifiers = modifiers\n          .map(({ modifier, theme, color, label }, position) => ({\n            ...(completion as Omit<T, 'modifiers'>),\n            position,\n            name: `${completion.name}/${modifier}`,\n            value: `${completion.value}/${modifier}`,\n            filter: spacify(modifier),\n            description: label || '',\n            theme,\n            color: color && parseColor(color) ? color : undefined,\n          }))\n          .filter((suggestion) => {\n            if (completion.type === 'class' && isIgnored(completion.name)) {\n              return false\n            }\n\n            target.set(suggestion.name, suggestion as T)\n\n            return true\n          })\n      }\n    }\n  }\n\n  const deferreds: (() => void)[] = []\n\n  const context: AutocompleteContext = {\n    get theme() {\n      return tw.theme\n    },\n    get variants() {\n      return Object.fromEntries(\n        Array.from(variants.values(), (variant) => [\n          variant.name.slice(0, -1),\n          variant.description || variant.name,\n        ]),\n      )\n    },\n  }\n\n  let nextIndex = 0\n\n  for (const screen of Object.keys(tw.theme('screens'))) {\n    const name = screen + ':'\n    add(variants, {\n      type: 'variant',\n      source: `theme('screens')`,\n      index: nextIndex++,\n      position: variants.size,\n      name,\n      theme: { section: 'screens', key: screen },\n      description: mql(tw.theme('screens', screen) as MaybeArray<ScreenValue>),\n    })\n  }\n\n  for (const [pattern, resolver] of tw.config.variants) {\n    const index = nextIndex++\n    let position = 0\n\n    const provider = typeof resolver === 'function' && getAutocompleteProvider(resolver)\n\n    for (const value of asArray(pattern)) {\n      const condition = toCondition(value)\n      const source = condition.toString()\n\n      const re = new RegExp(condition.source.replace(/\\\\[dw][*+?]*/g, '\\0'), condition.flags)\n      const pattern = genex(re)\n      const count = pattern.count()\n\n      if (count === Infinity) {\n        if (provider) {\n          deferreds.push(() => {\n            const match: MatchResult = Object.create([String(value)], {\n              index: { value: 0 },\n              input: { value: String(value) },\n              $$: { value: '' },\n            })\n\n            for (const completion of provider(match, context)) {\n              if (typeof completion === 'string') {\n                add(variants, {\n                  type: 'variant',\n                  source,\n                  index,\n                  position: position++,\n                  name: completion + ':',\n                })\n              } else {\n                add(variants, {\n                  type: 'variant',\n                  source,\n                  index,\n                  position: position++,\n                  name: (completion.prefix || '') + (completion.suffix || '') + ':',\n                  theme: completion.theme,\n                  description: completion.label,\n                  modifiers: completion.modifiers,\n                })\n              }\n            }\n          })\n        } else {\n          console.warn(\n            `Can not generate completion for variant ${condition}: infinite possibilities`,\n          )\n        }\n      } else {\n        pattern.generate((value) => {\n          const match = re.exec(value) as MatchResult | null\n\n          if (match) {\n            match.$$ = value.slice(match[0].length)\n\n            const base = value.replace(/\\0/g, '')\n\n            if (provider) {\n              for (const completion of provider(match, context)) {\n                if (typeof completion === 'string') {\n                  add(variants, {\n                    type: 'variant',\n                    source,\n                    index,\n                    position: position++,\n                    name: base + completion + ':',\n                    description: '',\n                  })\n                } else {\n                  add(variants, {\n                    type: 'variant',\n                    source,\n                    index,\n                    position: position++,\n                    name: (completion.prefix ?? base) + (completion.suffix ?? '') + ':',\n                    theme: completion.theme,\n                    description: completion.label,\n                    modifiers: completion.modifiers,\n                  })\n                }\n              }\n            } else {\n              if (value.includes('\\0') || value.endsWith('-')) {\n                console.warn(\n                  `Can not generate completion for variant ${condition} with ${JSON.stringify(\n                    value,\n                  )}: missing provider`,\n                )\n              } else {\n                add(variants, {\n                  type: 'variant',\n                  source,\n                  index,\n                  position: position++,\n                  name: value + ':',\n                  description: typeof resolver == 'string' ? resolver : '',\n                })\n              }\n            }\n          }\n        })\n      }\n    }\n  }\n\n  for (const pseudoClass of simplePseudoClasses) {\n    const name = pseudoClass.slice(1) + ':'\n    if (!variants.has(name)) {\n      add(variants, {\n        type: 'variant',\n        source: 'builtin',\n        index: nextIndex++,\n        position: variants.size,\n        name,\n        value: name,\n        description: `&${pseudoClass}`,\n      })\n    }\n  }\n\n  if (deferreds.length) {\n    for (const deferred of deferreds) {\n      deferred()\n    }\n  }\n\n  for (const rule of tw.config.rules) {\n    const [pattern, resolver] = asArray(rule)\n\n    const index = nextIndex++\n    let position = 0\n\n    const provider = typeof resolver === 'function' && getAutocompleteProvider(resolver)\n\n    for (const value of asArray(pattern)) {\n      if (value === VARIANT_MARKER_RULE) {\n        continue\n      }\n\n      const condition = toCondition(value)\n      const source = condition.toString()\n\n      const re = new RegExp(condition.source.replace(/\\\\[dw][*+?]*/g, '\\0'), condition.flags)\n      const pattern = genex(re)\n      const count = pattern.count()\n\n      if (count === Infinity) {\n        if (provider) {\n          const match: MatchResult = Object.create([String(value)], {\n            index: { value: 0 },\n            input: { value: String(value) },\n            $$: { value: '' },\n          })\n\n          for (const completion of provider(match, context)) {\n            if (typeof completion === 'string') {\n              add(classes, {\n                type: 'class',\n                source,\n                index,\n                position: position++,\n                name: completion,\n              })\n            } else {\n              add(classes, {\n                type: 'class',\n                source,\n                index,\n                position: position++,\n                name: (completion.prefix || '') + (completion.suffix || ''),\n                theme: completion.theme,\n                description: completion.label,\n                color:\n                  completion.color && parseColor(completion.color) ? completion.color : undefined,\n                modifiers: completion.modifiers,\n              })\n            }\n          }\n        } else {\n          console.warn(`Can not generate completion for rule ${condition}: infinite possibilities`)\n        }\n      } else {\n        pattern.generate((name) => {\n          const match = re.exec(name) as MatchResult | null\n\n          if (match) {\n            match.$$ = name.slice(match[0].length)\n            const base = name.replace(/\\0/g, '')\n\n            if (provider) {\n              for (const completion of provider(match, context)) {\n                if (typeof completion === 'string') {\n                  add(classes, {\n                    type: 'class',\n                    source,\n                    index,\n                    position: position++,\n                    name: base + completion,\n                  })\n                } else {\n                  add(classes, {\n                    type: 'class',\n                    source,\n                    index,\n                    position: position++,\n                    name: (completion.prefix ?? base) + (completion.suffix ?? ''),\n                    theme: completion.theme,\n                    description: completion.label,\n                    color:\n                      completion.color && parseColor(completion.color)\n                        ? completion.color\n                        : undefined,\n                    modifiers: completion.modifiers,\n                  })\n                }\n              }\n            } else {\n              if (name.includes('\\0') || name.endsWith('-')) {\n                console.warn(\n                  `Can not generate completion for rule ${condition} with ${JSON.stringify(\n                    name,\n                  )}: missing provider`,\n                )\n              } else {\n                add(classes, {\n                  type: 'class',\n                  source,\n                  index,\n                  position: position++,\n                  name,\n                })\n              }\n            }\n          }\n        })\n      }\n    }\n  }\n\n  suggestions.sort(compareSuggestions)\n\n  return {\n    tw,\n    variants,\n    classes,\n    suggestions,\n    isIgnored,\n    generateCSS: (token) => {\n      let result = cssCache.get(token)\n\n      if (!result) {\n        tw.clear()\n\n        const isVariant = variants.has(token)\n\n        let name =\n          isVariant && token.endsWith('[:')\n            ? `${token.slice(0, -1)}…]:`\n            : token.endsWith('[')\n            ? `${token}…]`\n            : isVariant && token.endsWith('/:')\n            ? `${token.slice(0, -1)}…:`\n            : token.endsWith('/')\n            ? `${token}…`\n            : token\n\n        if (isVariant) {\n          if (!name.endsWith(':')) {\n            name += ':'\n          }\n\n          name += '…'\n        }\n\n        tw(name)\n\n        const css = stringify(tw.target)\n\n        const needle = `,${name}*/`\n        const startIndex = css.indexOf(needle)\n\n        if (startIndex === -1) {\n          result = css\n        } else {\n          const nextDeclarationStart = css.indexOf('/*', startIndex)\n\n          result = css.slice(\n            startIndex + needle.length,\n            nextDeclarationStart !== -1 ? nextDeclarationStart : css.length,\n          )\n        }\n\n        if (isVariant) {\n          result = result.replace(/…:…;?/, '')\n        }\n\n        cssCache.set(token, result)\n      }\n\n      return result\n    },\n  }\n}\n","import type {\n  BaseTheme,\n  ExtractThemes,\n  Preset,\n  Twind,\n  TwindConfig,\n  TwindUserConfig,\n} from '@twind/core'\n\nimport { matchSorter, type MatchSorterOptions } from 'match-sorter'\nimport cssbeautify from 'cssbeautify'\nimport QuickLRU from 'quick-lru'\n\nimport type { Boundary } from './internal/types'\nimport type {\n  DocumentationAt,\n  DocumentationForOptions,\n  Intellisense,\n  IntellisenseOptions,\n  Suggestion,\n} from './types'\n\nimport { parse, type ParsedDevRule } from '@twind/core'\n\nimport { createIntellisenseContext } from './internal/create-context'\nimport { spacify } from './internal/spacify'\nimport { compareSuggestions } from './internal/compare-suggestion'\n\nexport * from './types'\n\nconst MDN = 'https://developer.mozilla.org'\n\nexport function createIntellisense<Theme extends BaseTheme = BaseTheme>(\n  twind: Twind<Theme>,\n  options?: IntellisenseOptions,\n): Intellisense<Theme>\n\nexport function createIntellisense<Theme extends BaseTheme = BaseTheme>(\n  config: TwindConfig<Theme>,\n  options?: IntellisenseOptions,\n): Intellisense<Theme>\n\nexport function createIntellisense<Theme = BaseTheme, Presets extends Preset<any>[] = Preset[]>(\n  config: TwindUserConfig<Theme, Presets>,\n  options?: IntellisenseOptions,\n): Intellisense<BaseTheme & ExtractThemes<Theme, Presets>>\n\nexport function createIntellisense(\n  config: Twind | TwindConfig | TwindUserConfig,\n  options: IntellisenseOptions = {},\n): Intellisense {\n  const suggestionCache = new QuickLRU<string, Suggestion[]>({ maxSize: 1000, ...options.cache })\n  const documentationCache = new QuickLRU<string, string | null>({\n    maxSize: 1000,\n    ...options.cache,\n  })\n\n  const context = createIntellisenseContext(config, options)\n  const { mdnOrigin = MDN } = options\n\n  // Precache empty input as it is the most common and take a while\n  suggestionCache.set('', context.suggestions.map(toSuggestion))\n\n  function generateClassDescription(className: string): string {\n    const css = context.generateCSS(className)\n\n    const bodyStart = css.lastIndexOf('{')\n    const bodyEnd = css.indexOf('}')\n\n    if (bodyStart === -1 || bodyEnd === -1) {\n      return css\n    }\n\n    return cssbeautify(`.x{${css.slice(bodyStart + 1, bodyEnd)}}`, { indent: '' })\n      .split('\\n')\n      .slice(1, -1)\n      .join(' ')\n  }\n\n  function toSuggestion(suggestion: Suggestion): Suggestion {\n    if (suggestion.type === 'variant') {\n      return {\n        type: suggestion.type,\n        name: suggestion.name,\n        value: suggestion.value,\n        description: suggestion.description,\n        detail: suggestion.detail,\n        color: suggestion.color,\n      }\n    }\n\n    return {\n      type: suggestion.type,\n      name: suggestion.name,\n      value: suggestion.value,\n      description: (suggestion.description ||= generateClassDescription(suggestion.name)),\n      detail: suggestion.detail,\n      color: suggestion.color,\n    }\n  }\n\n  let mdnIndexPromise: Promise<{ title: string; url: string }[]> | null = null\n  const mdnCache = new QuickLRU<\n    string,\n    Promise<{ title: string; summary?: string | undefined; browserCompat?: string[] | undefined }>\n  >({\n    maxSize: 1000,\n    ...options.cache,\n  })\n  return {\n    get theme() {\n      return context.tw.theme\n    },\n    get config() {\n      return context.tw.config\n    },\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async suggest(input, { prefix = '', ignore } = {}) {\n      const key = JSON.stringify({ input, prefix, ignore })\n      let result = suggestionCache.get(key)\n\n      if (!result) {\n        let source = context.suggestions\n        let threshold: MatchSorterOptions['threshold'] = matchSorter.rankings.MATCHES\n\n        const token = prefix + input\n\n        const match = /^(.+(?:-\\[.+])?)\\/([^/]+|\\[.+])?$/.exec(token)\n        if (match) {\n          const { 1: key, 2: modifier = '' } = match\n          const suggestion = context.classes.get(key) || context.variants.get(key)\n          if (suggestion?.modifiers) {\n            source = suggestion?.modifiers\n            input = modifier\n          }\n        }\n\n        if (token[0] === '-') {\n          source = source.filter(({ name }) => name[0] === '-')\n\n          if (prefix) {\n            prefix = prefix.slice(1)\n          } else {\n            input = input.slice(1)\n          }\n        }\n\n        if (ignore?.length) {\n          source = source.filter(({ value }) => !ignore.includes(value))\n        }\n\n        if (prefix) {\n          source = source\n            .filter(({ type, value }) => type === 'variant' || value.startsWith(prefix))\n            .map((suggestion) =>\n              suggestion.type === 'variant'\n                ? suggestion\n                : {\n                    ...suggestion,\n                    filter: spacify(suggestion.value.slice(prefix.length)),\n                    value: suggestion.value.slice(prefix.length),\n                  },\n            )\n        }\n\n        const { length } = input.replace(/[-\\s]+/g, '')\n\n        if (length === 0) {\n          if (prefix) {\n            source = source.sort((a, b) => compareSuggestions(a, b, prefix))\n          }\n\n          suggestionCache.set(key, (result = source.map(toSuggestion)))\n        } else {\n          if (length < 2) {\n            threshold = matchSorter.rankings.CONTAINS\n          }\n\n          // TODO: spacify should ignore `[...]`\n          const search = spacify(input)\n\n          suggestionCache.set(\n            key,\n            (result = matchSorter(source, search, {\n              keys: ['filter'],\n              threshold,\n              baseSort: (a, b) => compareSuggestions(a.item, b.item, prefix),\n            }).map(toSuggestion)),\n          )\n        }\n      }\n\n      return result\n    },\n    async suggestAt(content, position, language) {\n      // html: class=\"...\" | class='...' | class=...\n      // markdown, mdx: <html>\n      // javascript|typescript: \"...\" | '...' | `...`\n      //  TODO: lit: html`...`\n      // javascriptreact, typescriptreact: className=\"...\" | className='...'| className={<js>} | class={<js>} | <html>\n      // svelte: class:...= | class={<js>} | class=\"{<js>}\" | class='{<js>}' | <html> | <js>\n      // vue, vue-html: <html> | <js> | :class=\"{<js>}\"> | :class=\"[<js>]\"> // TODO :class=\"{underline: true}\"\n      // alpinejs: x-bind:class=\"! open ? 'hidden' : ''\"\n      // solidjs: classList={{ active: state.active, editing: state.currentId === row.id }}\n\n      // TODO: *react, svelte\n\n      // TODO: autocomplete for theme(): https://github.com/tailwindlabs/tailwindcss-intellisense/blob/1f1c3fcd7978865aff06fa1f8616c6b6447c1fa1/packages/tailwindcss-language-server/src/language/cssServer.ts#L159\n      const { extractBoundary } =\n        language === 'html'\n          ? await import('./languages/html')\n          : {\n              extractBoundary: (content: string, position?: number): Boundary | null => {\n                const start =\n                  Math.max(\n                    content.lastIndexOf(' ', position),\n                    content.lastIndexOf('\\n', position),\n                    content.lastIndexOf('\\t', position),\n                  ) + 1\n\n                let end = content.indexOf(' ', start)\n\n                if (end === -1) end = content.indexOf('\\n', start)\n                if (end === -1) end = content.indexOf('\\t', start)\n                if (end === -1) end = content.length\n\n                return { start, end, content: content.slice(start, end) }\n              },\n            }\n\n      const boundary = extractBoundary(content, position)\n\n      if (!boundary) return null\n\n      const isEmptyPosition = !boundary.content || /[\\s():/!-@]$/.test(boundary.content)\n\n      const parsed = parse(boundary.content + (isEmptyPosition ? '\\uffff' : ''))\n\n      const rule = parsed[parsed.length - 1] as ParsedDevRule | undefined\n\n      if (!rule) return null\n      if (context.isIgnored(rule.n)) return null\n\n      const active = isEmptyPosition ? rule.a.slice(0, -1) : rule.a\n\n      let negated = false\n      const parts: string[] = []\n      for (let value of active) {\n        if (value == '(' || /[~@]$/.test(value)) {\n          parts.push('')\n          continue\n        }\n\n        if (value[0] == '!') {\n          value = value.slice(1)\n        }\n\n        if (value.endsWith(':')) {\n          parts.push('')\n          continue\n        }\n\n        if (value[0] == '-') {\n          value = value.slice(1)\n          negated = !negated\n        }\n\n        if (value.endsWith('-')) {\n          value = value.slice(0, -1)\n        }\n\n        if (value && value != '&') {\n          parts.push(value)\n        }\n      }\n\n      let prefix = (negated ? '-' : '') + parts.slice(0, -1).filter(Boolean).join('-')\n      if (prefix && negated) {\n        prefix = '-' + prefix + '-'\n      } else if (prefix) {\n        prefix = prefix + '-'\n      }\n\n      const input = (isEmptyPosition ? rule.n.replace(/\\uffff$/, '') : rule.n).slice(prefix.length)\n\n      return {\n        start: position - input.length,\n        end: position,\n        suggestions: await this.suggest(input, { prefix, ignore: rule.v.map((v) => v + ':') }),\n      }\n    },\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async documentationFor(token, { format = 'md' }: DocumentationForOptions = {}) {\n      if (documentationCache.has(token)) {\n        return convert(documentationCache.get(token), format)\n      }\n\n      const rule = parse(token)[0] || {\n        n: token.endsWith(':') ? '' : token,\n        v: token.endsWith(':') ? [token] : [],\n      }\n\n      const css = cssbeautify(context.generateCSS(token), { autosemicolon: true, indent: '  ' })\n\n      // { title: \"display\", url: \"/en-US/docs/Web/CSS/display\" },\n      // { title: \"@media\", url: \"/en-US/docs/Web/CSS/@media\" },\n      // { title: \"prefers-contrast\", url: \"/en-US/docs/Web/CSS/@media/prefers-contrast\" }\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/@media/index.json\n      // {doc: { summary: \"\", \"browserCompat\": [ \"css.properties.display\" ] },\n      // https://caniuse.com/mdn-css_properties_display\n      const mdnIndex = await (mdnIndexPromise ||= (async () => {\n        try {\n          const response = await fetch(`${mdnOrigin}/en-US/search-index.json`)\n\n          if (response.ok && response.status === 200) {\n            const index: { title: string; url: string }[] = await response.json()\n\n            return index.filter(({ url }) => url.includes('/CSS/'))\n          }\n        } catch (error) {\n          console.warn('Failed to fetch MDN index')\n        }\n\n        return []\n      })())\n\n      const cssFeatureLinks =\n        mdnIndex.length &&\n        (await Promise.all(\n          Array.from(\n            css.matchAll(\n              /\\\\[!\"'`*+.,;:\\\\/<=>?@#$%&^|~()[\\]{}]|(@\\S+|:?:[a-z-]+(?:\\([^)]+\\))?|[a-z-]+:)/g,\n            ),\n            (match) => {\n              const candidate = match[1]\n              if (candidate && !candidate.startsWith('-')) {\n                // color: transparent\n                // @media (prefers-contrast:) -> @media, prefers-contrast\n                // &:hover -> :hover, hover\n                // ::backdrop -> ::backdrop, backdrop\n                // :nth-child(odd) -> :nth-child(odd), :nth-child(), :nth-child, nth-child\n                const candidates = new Set([\n                  candidate,\n                  // :nth-child(odd) -> :nth-child()\n                  candidate.replace(/\\(.+?\\)/g, '()'),\n                  // :nth-child(odd) -> :nth-child\n                  candidate.replace(/\\(.*?\\)/g, ''),\n                  // :nth-child(odd) -> nth-child\n                  // ::backdrop -> backdrop\n                  candidate.replace(/\\(.*?\\)|[^a-z-]+/gi, ''),\n                ])\n\n                for (const candidate of candidates) {\n                  const found = mdnIndex.find(({ title }) => title === candidate)\n                  if (found) {\n                    return { match, mdn: found }\n                  }\n                }\n              }\n            },\n          )\n            .filter(\n              <T>(result: T, index: number, list: T[]): result is NonNullable<T> =>\n                result && list.indexOf(result) === index,\n            )\n            .map(async (result) => {\n              let cached = mdnCache.get(result.mdn.url)\n\n              if (!cached) {\n                mdnCache.set(\n                  result.mdn.url,\n                  (cached = (async () => {\n                    try {\n                      const response = await fetch(`${mdnOrigin}${result.mdn.url}/index.json`)\n\n                      // http://www.whateverorigin.org/get?url=https://developer.mozilla.org/en-US/search-index.json\n                      // http://www.whateverorigin.org/get?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fsearch-index.json\n                      // https://cors-anywhere.herokuapp.com/https://developer.mozilla.org/en-US/search-index.json\n                      // https://mdn-twind-run.sastan.workers.dev/en-US/search-index.json\n                      if (response.ok && response.status === 200) {\n                        const index: {\n                          doc: { title: string; summary?: string; browserCompat?: string[] }\n                        } = await response.json()\n\n                        return {\n                          title: index.doc.title,\n                          summary: index.doc.summary,\n                          browserCompat: index.doc.browserCompat,\n                        }\n                      }\n                    } catch (error) {\n                      console.warn('Failed to fetch MDN index')\n                    }\n\n                    return { title: result.mdn.title }\n                  })()),\n                )\n              }\n\n              const { title, browserCompat } = await cached\n              const links = [\n                `[Documentation](${MDN}${result.mdn.url})`,\n                browserCompat?.[0] &&\n                  `[Browser Support](https://caniuse.com/mdn-${browserCompat[0].replace(\n                    /\\./g,\n                    '_',\n                  )})`,\n              ]\n                .filter(Boolean)\n                .join(' • ')\n\n              return `⁃ \\`${title}\\` (${links})`\n            }),\n        ))\n\n      let theme: any\n      const sources: string[] = []\n\n      // TODO: arbitrary class/variant lookup would not work\n      for (const completion of [\n        ...rule.v.map((v) => context.variants.get(v + ':')),\n        context.classes.get(rule.n),\n      ]) {\n        if (!completion) continue\n\n        const links =\n          // regexp -> create links to Regex101 and Regexper\n          completion.source.startsWith('/') && completion.source.endsWith('/')\n            ? [\n                `[Regex101](https://regex101.com/?flavor=JavaScript&regex=${encodeURIComponent(\n                  completion.source.slice(1, -1),\n                )}&testString=${encodeURIComponent(completion.value)})`,\n                `[Regexper](https://regexper.com/#${encodeURIComponent(completion.source)})`,\n              ].join(' • ')\n            : ''\n\n        sources.push(\n          `⁃ \\`${completion.name}\\` → \\`${completion.source}\\`${links && ' (' + links + ')'}`,\n        )\n\n        if (completion.theme) {\n          const { section, key } = completion.theme\n\n          const keys =\n            completion.color || /color|fill|stroke/i.test(section)\n              ? key.replace(/-/g, '.').split('.')\n              : [key]\n\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          let obj: any = ((theme ||= {})[section] = {})\n\n          while (keys.length) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            obj = obj[keys.shift() as string] = keys.length\n              ? {}\n              : context.tw.theme(section, key) ?? '…'\n          }\n        }\n      }\n\n      const result =\n        [\n          css && '```css\\n' + css + '\\n```',\n          cssFeatureLinks &&\n            cssFeatureLinks.length &&\n            `### CSS Features\\n\\n${cssFeatureLinks.join('<br>')}\\n`,\n          theme && '### Theme\\n\\n```json\\n' + JSON.stringify(theme, null, 2) + '\\n```',\n          sources.length && `### Source\\n\\n${sources.join('<br>')}\\n`,\n        ]\n          .filter(Boolean)\n          .join('\\n\\n') || null\n\n      documentationCache.set(token, result)\n\n      return convert(result, format)\n    },\n    async documentationAt(content, offset, language) {\n      let result: DocumentationAt | null = null\n\n      if (language === 'html') {\n        const { documentationAt } = await import('./languages/html')\n\n        result = documentationAt(content, offset, context)\n      }\n\n      if (result) {\n        const documentation = await this.documentationFor(result.value)\n\n        if (documentation) {\n          return { ...result, value: documentation }\n        }\n      }\n\n      return null\n    },\n    async collectColors(content, language) {\n      if (language === 'html') {\n        const { collectColors } = await import('./languages/html')\n\n        return collectColors(content, context)\n      }\n\n      return []\n    },\n    async validate(content, language) {\n      if (language === 'html') {\n        const { validate } = await import('./languages/html')\n\n        return validate(content, context)\n      }\n\n      return []\n    },\n    *enumerate() {\n      for (const completion of context.suggestions) {\n        yield toSuggestion(completion)\n      }\n    },\n  }\n}\n\nfunction convert(\n  md: string | null | undefined,\n  format?: DocumentationForOptions['format'],\n): string | null | Promise<string> {\n  if (md && format === 'html') {\n    return import('showdown').then((showdown) => {\n      const Converter = showdown.Converter || showdown.default.Converter\n      const converter = new Converter({ openLinksInNewWindow: true })\n      converter.setFlavor('github')\n      return converter.makeHtml(md)\n    })\n  }\n\n  return md ?? null\n}\n","import type { BaseTheme, Context } from '../types'\nimport type { ParsedRule } from '../parse'\nimport { asArray, mql } from '../utils'\nimport { toClassName } from './to-class-name'\n\n// Based on https://github.com/kripod/otion\n// License MIT\n\n// export const enum Shifts {\n//   darkMode = 30,\n//   layer = 27,\n//   screens = 26,\n//   responsive = 22,\n//   atRules = 18,\n//   variants = 0,\n// }\n\nexport const Layer = {\n  /**\n   * 1. `default` (public)\n   */\n  d /* efaults */: 0b000 << 27 /* Shifts.layer */,\n\n  /**\n   * 2. `base` (public) — for things like reset rules or default styles applied to plain HTML elements.\n   */\n  b /* ase */: 0b001 << 27 /* Shifts.layer */,\n\n  /**\n   * 3. `components` (public, used by `style()`) — is for class-based styles that you want to be able to override with utilities.\n   */\n  c /* omponents */: 0b010 << 27 /* Shifts.layer */,\n  // reserved for style():\n  // - props: 0b011\n  // - when: 0b100\n\n  /**\n   * 6. `aliases` (public, used by `apply()`) — `~(...)`\n   */\n  a /* liases */: 0b101 << 27 /* Shifts.layer */,\n\n  /**\n   * 6. `utilities` (public) — for small, single-purpose classes\n   */\n  u /* tilities */: 0b110 << 27 /* Shifts.layer */,\n\n  /**\n   * 7. `overrides` (public, used by `css()`)\n   */\n  o /* verrides */: 0b111 << 27 /* Shifts.layer */,\n} as const\n\n/*\nTo have a predictable styling the styles must be ordered.\n\nThis order is represented by a precedence number. The lower values\nare inserted before higher values. Meaning higher precedence styles\noverwrite lower precedence styles.\n\nEach rule has some traits that are put into a bit set which form\nthe precedence:\n\n| bits | trait                                                |\n| ---- | ---------------------------------------------------- |\n| 1    | dark mode                                            |\n| 2    | layer: preflight, global, components, utilities, css |\n| 1    | screens: is this a responsive variation of a rule    |\n| 5    | responsive based on min-width                        |\n| 4    | at-rules                                             |\n| 18   | pseudo and group variants                            |\n| 4    | number of declarations (descending)                  |\n| 4    | greatest precedence of properties                    |\n\n**Dark Mode: 1 bit**\n\nFlag for dark mode rules.\n\n**Layer: 3 bits**\n\n- defaults = 0: The preflight styles and any base styles registered by plugins.\n- base = 1: The global styles registered by plugins.\n- components = 2\n- variants = 3\n- compounds = 4\n- aliases = 5\n- utilities = 6: Utility classes and any utility classes registered by plugins.\n- css = 7: Styles generated by css\n\n**Screens: 1 bit**\n\nFlag for screen variants. They may not always have a `min-width` to be detected by _Responsive_ below.\n\n**Responsive: 4 bits**\n\nBased on extracted `min-width` value:\n\n- 576px -> 3\n- 1536px -> 10\n- 36rem -> 3\n- 96rem -> 9\n\n**At-Rules: 4 bits**\n\nBased on the count of special chars (`-:,`) within the at-rule.\n\n**Pseudo and group variants: 18 bits**\n\nEnsures predictable order of pseudo classes.\n\n- https://bitsofco.de/when-do-the-hover-focus-and-active-pseudo-classes-apply/#orderofstyleshoverthenfocusthenactive\n- https://developer.mozilla.org/docs/Web/CSS/:active#Active_links\n- https://github.com/tailwindlabs/tailwindcss/blob/master/stubs/defaultConfig.stub.js#L718\n\n**Number of declarations (descending): 4 bits**\n\nAllows single declaration styles to overwrite styles from multi declaration styles.\n\n**Greatest precedence of properties: 4 bits**\n\nEnsure shorthand properties are inserted before longhand properties; eg longhand override shorthand\n*/\n\nexport function moveToLayer(precedence: number, layer: number): number {\n  // Set layer (first reset, than set)\n  return (precedence & ~Layer.o) | layer\n}\n\n/*\nTo set a bit: n |= mask;\nTo clear a bit: n &= ~mask;\nTo test if a bit is set: (n & mask)\n\nBit shifts for the primary bits:\n\n| bits | trait                                                   | shift |\n| ---- | ------------------------------------------------------- | ----- |\n| 1    | dark mode                                               | 30    |\n| 3    | layer: preflight, global, components, utilities, css    | 27    |\n| 1    | screens: is this a responsive variation of a rule       | 26    |\n| 4    | responsive based on min-width, max-width or width       | 22    |\n| 4    | at-rules                                                | 18    |\n| 18   | pseudo and group variants                               | 0     |\n\nLayer: 0 - 7: 3 bits\n  - defaults: 0 << 27\n  - base: 1 << 27\n  - components: 2 << 27\n  - variants: 3 << 27\n  - joints: 4 << 27\n  - aliases: 5 << 27\n  - utilities: 6 << 27\n  - overrides: 7 << 27\n\nThese are calculated by serialize and added afterwards:\n\n| bits | trait                               |\n| ---- | ----------------------------------- |\n| 4    | number of selectors (descending)    |\n| 4    | number of declarations (descending) |\n| 4    | greatest precedence of properties   |\n\nThese are added by shifting the primary bits using multiplication as js only\nsupports bit shift up to 32 bits.\n*/\n\n// Colon and dash count of string (ascending)\nexport function seperatorPrecedence(string: string): number {\n  return string.match(/[-=:;]/g)?.length || 0\n}\n\nexport function atRulePrecedence(css: string): number {\n  // 0 - 15: 4 bits (max 144rem or 2304px)\n  // rem -> bit\n  // <20 ->  0 (<320px)\n  //  20 ->  1 (320px)\n  //  24 ->  2 (384px)\n  //  28 ->  3 (448px)\n  //  32 ->  4 (512px)\n  //  36 ->  5 (576px)\n  //  42 ->  6 (672px)\n  //  48 ->  7 (768px)\n  //  56 ->  8 (896px)\n  //  64 ->  9 (1024px)\n  //  72 -> 10 (1152px)\n  //  80 -> 11 (1280px)\n  //  96 -> 12 (1536px)\n  // 112 -> 13 (1792px)\n  // 128 -> 14 (2048px)\n  // 144 -> 15 (2304px)\n  // https://www.dcode.fr/function-equation-finder\n  return (\n    (Math.min(\n      /(?:^|width[^\\d]+)(\\d+(?:.\\d+)?)(p)?/.test(css)\n        ? Math.max(0, 29.63 * (+RegExp.$1 / (RegExp.$2 ? 15 : 1)) ** 0.137 - 43)\n        : 0,\n      15,\n    ) <<\n      22) /* Shifts.responsive */ |\n    (Math.min(seperatorPrecedence(css), 15) << 18) /* Shifts.atRules */\n  )\n}\n\n// Pesudo variant presedence\n// Chars 3 - 8: Uniquely identifies a pseudo selector\n// represented as a bit set for each relevant value\n// 18 bits: one for each variant plus one for unknown variants\n//\n// ':group-*' variants are normalized to their native pseudo class (':group-hover' -> ':hover')\n// as they already have a higher selector presedence due to the add '.group' ('.group:hover .group-hover:...')\n\n// Sources:\n// - https://bitsofco.de/when-do-the-hover-focus-and-active-pseudo-classes-apply/#orderofstyleshoverthenfocusthenactive\n// - https://developer.mozilla.org/docs/Web/CSS/:active#Active_links\n// - https://github.com/tailwindlabs/tailwindcss/blob/master/stubs/defaultConfig.stub.js#L931\n\nconst PRECEDENCES_BY_PSEUDO_CLASS = [\n  /* fi */ 'rst-c' /* hild: 0 */,\n  /* la */ 'st-ch' /* ild: 1 */,\n  // even and odd use: nth-child\n  /* nt */ 'h-chi' /* ld: 2 */,\n  /* an */ 'y-lin' /* k: 3 */,\n  /* li */ 'nk' /* : 4 */,\n  /* vi */ 'sited' /* : 5 */,\n  /* ch */ 'ecked' /* : 6 */,\n  /* em */ 'pty' /* : 7 */,\n  /* re */ 'ad-on' /* ly: 8 */,\n  /* fo */ 'cus-w' /* ithin : 9 */,\n  /* ho */ 'ver' /* : 10 */,\n  /* fo */ 'cus' /* : 11 */,\n  /* fo */ 'cus-v' /* isible : 12 */,\n  /* ac */ 'tive' /* : 13 */,\n  /* di */ 'sable' /* d : 14 */,\n  /* op */ 'tiona' /* l: 15 */,\n  /* re */ 'quire' /* d: 16 */,\n]\n\nfunction pseudoPrecedence(selector: string): number {\n  // use first found pseudo-class\n\n  return (\n    1 <<\n    ~(\n      (/:([a-z-]+)/.test(selector) &&\n        ~PRECEDENCES_BY_PSEUDO_CLASS.indexOf(RegExp.$1.slice(2, 7))) ||\n      ~17\n    )\n  )\n}\n\n// https://github.com/kripod/otion/blob/main/packages/otion/src/propertyMatchers.ts\n// \"+1\": [\n// \t/* ^border-.*(w|c|sty) */\n// \t\"border-.*(width,color,style)\",\n\n// \t/* ^[tlbr].{2,4}m?$ */\n// \t\"top\",\n// \t\"left\",\n// \t\"bottom\",\n// \t\"right\",\n\n// \t/* ^c.{7}$ */\n// \t\"continue\",\n\n// \t/* ^c.{8}$ */\n// \t\"container\",\n// ],\n\n// \"-1\": [\n// \t/* ^[fl].{5}l */\n// \t\"flex-flow\",\n// \t\"line-clamp\",\n\n// \t/* ^g.{8}$ */\n// \t\"grid-area\",\n\n// \t/* ^pl */\n// \t\"place-content\",\n// \t\"place-items\",\n// \t\"place-self\",\n\n// ],\n\n// group: 1 => +1\n// group: 2 => -1\n\n// 0 - 15 => 4 bits\n// Ignore vendor prefixed and custom properties\nexport function declarationPropertyPrecedence(property: string): number {\n  return property[0] == '-'\n    ? 0\n    : seperatorPrecedence(property) +\n        (/^(?:(border-(?!w|c|sty)|[tlbr].{2,4}m?$|c.{7,8}$)|([fl].{5}l|g.{8}$|pl))/.test(property)\n          ? +!!RegExp.$1 /* +1 */ || -!!RegExp.$2 /* -1 */\n          : 0) +\n        1\n}\n\nexport interface ConvertedRule {\n  /** The name to use for `&` expansion in selectors. Maybe empty for at-rules like `@import`, `@font-face`, `@media`, ... */\n  n?: string | undefined\n\n  /** The calculated precedence taking all variants into account. */\n  p: number\n\n  /** The rulesets (selectors and at-rules). expanded variants `@media ...`, `@supports ...`, `&:focus`, `.dark &` */\n  r?: string[]\n\n  /** Is this rule `!important` eg something like `!underline` or `!bg-red-500` or `!red-500` */\n  i?: boolean | undefined\n}\n\nexport function convert<Theme extends BaseTheme = BaseTheme>(\n  { n: name, i: important, v: variants = [] }: Partial<ParsedRule>,\n  context: Context<Theme>,\n  precedence: number,\n  conditions?: string[],\n): ConvertedRule {\n  if (name) {\n    name = toClassName({ n: name, i: important, v: variants })\n  }\n\n  conditions = [...asArray(conditions)]\n\n  for (const variant of variants) {\n    const screen = context.theme('screens', variant)\n\n    for (const condition of asArray((screen && mql(screen)) || context.v(variant))) {\n      conditions.push(condition)\n\n      precedence |= screen\n        ? (1 << 26) /* Shifts.screens */ | atRulePrecedence(condition)\n        : variant == 'dark'\n        ? 1 << 30 /* Shifts.darkMode */\n        : condition[0] == '@'\n        ? atRulePrecedence(condition)\n        : pseudoPrecedence(condition)\n    }\n  }\n\n  return { n: name, p: precedence, r: conditions, i: important }\n}\n","import type {\n  BaseTheme,\n  Context,\n  RuleResult,\n  TwindConfig,\n  CSSProperties,\n  MatchResult,\n  MaybeArray,\n  RuleResolver,\n  MatchConverter,\n  Rule,\n  CSSObject,\n  Variant,\n  VariantResult,\n  VariantResolver,\n  Falsey,\n} from '../types'\n\nimport { DEV } from 'distilt/env'\n\nimport { makeThemeFunction } from './theme'\nimport { asArray, escape, hash as defaultHash, identity, noop } from '../utils'\nimport { fromMatch } from '../rules'\nimport { warn } from './warn'\n\ntype ResolveFunction<Theme extends BaseTheme = BaseTheme> = (\n  className: string,\n  context: Context<Theme>,\n  isDark?: boolean,\n) => RuleResult\n\ntype VariantFunction<Theme extends BaseTheme = BaseTheme> = (\n  variant: string,\n  context: Context<Theme>,\n) => VariantResult\n\nexport function createContext<Theme extends BaseTheme = BaseTheme>({\n  theme,\n  darkMode,\n  darkColor = noop,\n  variants,\n  rules,\n  hash,\n  stringify,\n  ignorelist,\n  finalize,\n}: TwindConfig<Theme>): Context<Theme> {\n  // Used to cache resolved rule values\n  const variantCache = new Map<string, MaybeArray<string>>()\n\n  // lazy created resolve functions\n  const variantResolvers = new Map<Variant<Theme>, VariantFunction<Theme>>()\n\n  // Used to cache resolved rule values\n  const ruleCache = new Map<string, RuleResult>()\n\n  // lazy created resolve functions\n  const ruleResolvers = new Map<Rule<Theme>, ResolveFunction<Theme>>()\n\n  const ignored = createRegExpExecutor(ignorelist, (value, condition) => condition.test(value))\n\n  const reportedUnknownClasses = /* #__PURE__ */ new Set<string>()\n\n  // add dark as last variant to allow user to override it\n  // we can modify variants as it has been passed through defineConfig which already made a copy\n  variants.push([\n    'dark',\n    Array.isArray(darkMode) || darkMode == 'class'\n      ? `${asArray(darkMode)[1] || '.dark'} &`\n      : typeof darkMode == 'string' && darkMode != 'media'\n      ? darkMode // a custom selector\n      : '@media (prefers-color-scheme:dark)',\n  ])\n\n  const h =\n    typeof hash == 'function'\n      ? (value: string) => hash(value, defaultHash)\n      : hash\n      ? defaultHash\n      : identity\n\n  if (h !== identity) {\n    finalize.push((rule) => ({\n      ...rule,\n      n: rule.n && h(rule.n),\n      d: rule.d?.replace(\n        /--(tw(?:-[\\w-]+)?)\\b/g,\n        (_: string, property: string) => '--' + h(property).replace('#', ''),\n      ),\n    }))\n  }\n\n  const ctx: Context<Theme> = {\n    theme: makeThemeFunction(theme),\n\n    e: escape,\n\n    h,\n\n    s(property, value) {\n      return stringify(property, value, ctx)\n    },\n\n    d(section, key, color) {\n      return darkColor(section, key, ctx, color)\n    },\n\n    v(value) {\n      if (!variantCache.has(value)) {\n        variantCache.set(\n          value,\n          find(value, variants, variantResolvers, getVariantResolver, ctx) || '&:' + value,\n        )\n      }\n\n      return variantCache.get(value) as string\n    },\n\n    r(className, isDark) {\n      const key = JSON.stringify([className, isDark])\n\n      if (!ruleCache.has(key)) {\n        ruleCache.set(\n          key,\n          !ignored(className, ctx) &&\n            find(className, rules, ruleResolvers, getRuleResolver, ctx, isDark),\n        )\n\n        if (DEV) {\n          const rule = ruleCache.get(key)\n          if (rule == null && !reportedUnknownClasses.has(className)) {\n            reportedUnknownClasses.add(className)\n\n            warn(\n              `Unknown class ${JSON.stringify(className)} found.`,\n              'TWIND_INVALID_CLASS',\n              className,\n            )\n          }\n        }\n      }\n\n      return ruleCache.get(key)\n    },\n\n    f(rule) {\n      return finalize.reduce((rule, p) => p(rule, ctx), rule)\n    },\n  }\n\n  return ctx\n}\n\nfunction find<Value, Config, Result, Theme extends BaseTheme = BaseTheme>(\n  value: Value,\n  list: Config[],\n  cache: Map<Config, (value: Value, context: Context<Theme>, isDark?: boolean) => Result>,\n  getResolver: (\n    item: Config,\n  ) => (value: Value, context: Context<Theme>, isDark?: boolean) => Result,\n  context: Context<Theme>,\n  isDark?: boolean,\n) {\n  for (const item of list) {\n    let resolver = cache.get(item)\n\n    if (!resolver) {\n      cache.set(item, (resolver = getResolver(item)))\n    }\n\n    const resolved = resolver(value, context, isDark)\n\n    if (resolved) return resolved\n  }\n}\n\nfunction getVariantResolver<Theme extends BaseTheme = BaseTheme>(\n  variant: Variant<Theme>,\n): VariantFunction<Theme> {\n  return createVariantFunction(variant[0], variant[1])\n}\n\nfunction getRuleResolver<Theme extends BaseTheme = BaseTheme>(\n  rule: Rule<Theme>,\n): ResolveFunction<Theme> {\n  if (Array.isArray(rule)) {\n    return createResolveFunction(rule[0], rule[1], rule[2])\n  }\n\n  return createResolveFunction(rule)\n}\n\nfunction createVariantFunction<Theme extends BaseTheme = BaseTheme>(\n  patterns: MaybeArray<string | RegExp>,\n  resolve: string | VariantResolver<Theme>,\n): VariantFunction<Theme> {\n  return createResolve(patterns, typeof resolve == 'function' ? resolve : () => resolve)\n}\n\nfunction createResolveFunction<Theme extends BaseTheme = BaseTheme>(\n  patterns: MaybeArray<string | RegExp>,\n  resolve?: keyof CSSProperties | string | CSSObject | RuleResolver<Theme>,\n  convert?: MatchConverter<Theme>,\n): ResolveFunction<Theme> {\n  return createResolve(patterns, fromMatch(resolve as keyof CSSProperties, convert))\n}\n\nfunction createResolve<Result, Theme extends BaseTheme = BaseTheme>(\n  patterns: MaybeArray<string | RegExp>,\n  resolve: (match: MatchResult, context: Context<Theme>) => Result,\n): (value: string, context: Context<Theme>, isDark?: boolean) => Result | undefined {\n  return createRegExpExecutor(patterns, (value, condition, context, isDark?: boolean) => {\n    const match = condition.exec(value) as MatchResult | Falsey\n\n    if (match) {\n      // MATCH.$_ = value\n      match.$$ = value.slice(match[0].length)\n      match.dark = isDark\n\n      return resolve(match, context)\n    }\n  })\n}\n\nfunction createRegExpExecutor<Result, Theme extends BaseTheme = any>(\n  patterns: MaybeArray<string | RegExp>,\n  run: (value: string, condition: RegExp, context: Context<Theme>, isDark?: boolean) => Result,\n): (value: string, context: Context<Theme>, isDark?: boolean) => Result | undefined {\n  const conditions = asArray(patterns).map(toCondition)\n\n  return (value, context, isDark) => {\n    for (const condition of conditions) {\n      const result = run(value, condition, context, isDark)\n\n      if (result) return result\n    }\n  }\n}\n\nexport function toCondition(value: string | RegExp): RegExp {\n  // \"visible\" -> /^visible$/\n  // \"(float)-(left|right|none)\" -> /^(float)-(left|right|none)$/\n  // \"auto-rows-\" -> /^auto-rows-/\n  // \"gap(-|$)\" -> /^gap(-|$)/\n  return typeof value == 'string'\n    ? new RegExp('^' + value + (value.includes('$') || value.slice(-1) == '-' ? '' : '$'))\n    : value\n}\n","export const simplePseudoClasses = [\n  ':active',\n  ':after',\n  ':any-link',\n  ':before',\n  // \":blank\", // Experimental\n  ':checked',\n  // \":current\", // Experimental\n  ':default',\n  ':defined',\n  ':disabled',\n  ':empty',\n  ':enabled',\n  // ':first',\n  ':first-child',\n  ':first-letter',\n  ':first-line',\n  ':first-of-type',\n  ':focus',\n  ':focus-visible',\n  ':focus-within',\n  ':fullscreen',\n  // \":future\", // Experimental\n  ':hover',\n  ':in-range',\n  ':indeterminate',\n  ':invalid',\n  ':last-child',\n  ':last-of-type',\n  ':link',\n  // \":local-link\", // Experimental\n  // \":nth-col\", // Experimental\n  // \":nth-last-col\", // Experimental\n  ':only-child',\n  ':only-of-type',\n  ':optional',\n  ':out-of-range',\n  // \":past\", // Experimental\n  ':paused',\n  ':picture-in-picture',\n  ':placeholder-shown',\n  ':playing',\n  ':read-only',\n  ':read-write',\n  ':required',\n  // \":root\",\n  // \":scope\",\n  ':target',\n  // \":target-within\", // Experimental\n  // \":user-invalid\", // Experimental\n  // \":user-valid\", // Experimental\n  ':valid',\n  ':visited',\n]\n","export const VARIANT_MARKER_RULE = /^…$/\n","import type { ColorInformation } from '../types'\n\nimport QuickLRU from 'quick-lru'\nimport { names as namedColors, TinyColor } from '@ctrl/tinycolor'\n\nconst colorNames = Object.keys(namedColors)\nexport const editabelColorRe = new RegExp(\n  `-\\\\[(${colorNames.join('|')}|(?:(?:#|(?:(?:hsl|rgb)a?|hwb|lab|lch|color)\\\\())[^]\\\\(]+)\\\\]$`,\n  'i',\n)\n\nconst colorCache = new QuickLRU<string, ColorInformation['rgba'] | null>({ maxSize: 1000 })\n\nexport function parseColor(value: string): ColorInformation['rgba'] | null {\n  let result = colorCache.get(value)\n\n  if (!result) {\n    const color = new TinyColor(value)\n\n    colorCache.set(value, (result = color.isValid ? color.toRgb() : null))\n  }\n\n  return result\n}\n","export function spacify(value: string): string {\n  return (value[0] === '-' ? '- ' : '') + value.replace(/[-\\s]+/g, ' ')\n}\n","import type { IntellisenseClass, IntellisenseVariant } from './types'\nimport { atRulePrecedence, seperatorPrecedence } from '../../../core/src/internal/precedence'\n\nconst collator = new Intl.Collator('en', { numeric: true })\n\nexport function compareSuggestions(\n  a: IntellisenseVariant | IntellisenseClass,\n  b: IntellisenseVariant | IntellisenseClass,\n  prefix?: string | undefined,\n): number {\n  // sort variants and classes\n  const variantsFirst = !prefix\n  if (a.type === 'variant' && b.type === 'class') {\n    return variantsFirst ? -1 : 1\n  }\n\n  if (a.type === 'class' && b.type === 'variant') {\n    return variantsFirst ? 1 : -1\n  }\n\n  // Move special chars after \"normal\"\n  if (!/^[-a-z\\d]/i.test(a.value) && /^[-a-z\\d]/i.test(b.value)) {\n    return 1\n  }\n\n  if (/^[-a-z\\d]/i.test(a.value) && !/^[-a-z\\d]/i.test(b.value)) {\n    return -1\n  }\n\n  const isVariant = a.type === 'variant'\n  // by min width\n  if (isVariant) {\n    const aMinWidth = a.description?.startsWith('@') && a.description.includes('min-width')\n    const bMinWidth = b.description?.startsWith('@') && b.description.includes('min-width')\n\n    if (aMinWidth && !bMinWidth) {\n      return -1\n    }\n\n    if (!aMinWidth && bMinWidth) {\n      return 1\n    }\n\n    if (aMinWidth && bMinWidth) {\n      const byAtRulePrecedence =\n        atRulePrecedence(a.description as string) - atRulePrecedence(b.description as string)\n\n      if (byAtRulePrecedence) {\n        return byAtRulePrecedence\n      }\n    }\n  }\n\n  // group by first part\n  if (!prefix) {\n    const aInitial = a.value.replace(/^-/, '').split('-', 1)[0]\n    const bInitial = b.value.replace(/^-/, '').split('-', 1)[0]\n\n    const byInitial = collator.compare(byName(aInitial), byName(bInitial))\n    if (byInitial) {\n      return byInitial\n    }\n\n    // bump root class up\n    if (a.value === aInitial && b.value !== bInitial) {\n      return -1\n    }\n\n    if (b.value === bInitial && a.value !== aInitial) {\n      return 1\n    }\n\n    const bySeperator = seperatorPrecedence(a.value) - seperatorPrecedence(b.value)\n    if (bySeperator) {\n      return bySeperator\n    }\n  }\n\n  // sort arbitrary values after other values\n  const arbitrarySuffix = isVariant ? '[:' : '['\n  if (a.value.endsWith(arbitrarySuffix) && !b.value.endsWith(arbitrarySuffix)) {\n    return 1\n  }\n\n  if (!a.value.endsWith(arbitrarySuffix) && b.value.endsWith(arbitrarySuffix)) {\n    return -1\n  }\n\n  // sort modifier values after other values\n  const modifierSuffix = isVariant ? '/:' : '/'\n  if (a.value.endsWith(modifierSuffix) && !b.value.endsWith(modifierSuffix)) {\n    return 1\n  }\n\n  if (!a.value.endsWith(modifierSuffix) && b.value.endsWith(modifierSuffix)) {\n    return -1\n  }\n\n  if (!isVariant) {\n    // opacity last\n    if (a.value.includes('-opacity') && !b.value.includes('-opacity')) {\n      return 1\n    }\n\n    if (!a.value.includes('-opacity') && b.value.includes('-opacity')) {\n      return -1\n    }\n\n    // color next to last\n    if (a.color && !b.color) {\n      return 1\n    }\n\n    if (!a.color && b.color) {\n      return -1\n    }\n  }\n\n  // keep same rules together\n  const byIndex = b.index - a.index\n  if (byIndex) {\n    return byIndex\n  }\n\n  // group by source\n  if (a.source === b.source) {\n    // sort negative classes after regular one\n    if (a.value.startsWith('-') && !b.value.startsWith('-')) {\n      return 1\n    }\n\n    if (!a.value.startsWith('-') && b.value.startsWith('-')) {\n      return -1\n    }\n  }\n\n  return collator.compare(byName(a.value), byName(b.value))\n}\n\nfunction byName(s: string | null | undefined) {\n  return (s || '').replace(/\\W/g, (c) => String.fromCharCode(127 + c.charCodeAt(0))) + '\\x00'\n}\n"],"names":["completion","suggestion","seperatorPrecedence","string","match","length","atRulePrecedence","css","Math","min","test","max","RegExp","$1","$2","toCondition","value","includes","slice","simplePseudoClasses","VARIANT_MARKER_RULE","colorNames","Object","keys","namedColors","editabelColorRe","join","colorCache","QuickLRU","maxSize","parseColor","result","get","color","TinyColor","set","isValid","toRgb","spacify","replace","collator","Intl","Collator","numeric","compareSuggestions","a","b","prefix","variantsFirst","type","isVariant","aMinWidth","description","startsWith","bMinWidth","byAtRulePrecedence","aInitial","split","bInitial","byInitial","compare","byName","bySeperator","arbitrarySuffix","endsWith","modifierSuffix","byIndex","index","source","s","c","String","fromCharCode","charCodeAt","MDN","createIntellisense","config","options","suggestionCache","cache","documentationCache","context","createIntellisenseContext","tw","twind","defineConfig","hash","preflight","stringify","property","presets","rules","ignorelist","virtual","asArray","map","isIgnored","className","some","re","variants","Map","classes","suggestions","cssCache","add","target","modifiers","name","has","JSON","console","warn","filter","push","modifier","theme","label","position","undefined","deferreds","fromEntries","Array","from","values","variant","nextIndex","screen","size","section","key","mql","pattern","resolver","provider","getAutocompleteProvider","condition","toString","flags","genex","count","Infinity","create","input","$$","suffix","generate","exec","base","pseudoClass","deferred","rule","sort","generateCSS","token","clear","needle","startIndex","indexOf","nextDeclarationStart","mdnOrigin","toSuggestion","detail","generateClassDescription","bodyStart","lastIndexOf","bodyEnd","cssbeautify","indent","mdnIndexPromise","mdnCache","suggest","ignore","threshold","matchSorter","rankings","MATCHES","CONTAINS","search","baseSort","item","suggestAt","content","language","extractBoundary","start","end","boundary","isEmptyPosition","parsed","parse","n","active","negated","parts","Boolean","v","documentationFor","format","convert","autosemicolon","mdnIndex","response","fetch","ok","status","json","url","error","cssFeatureLinks","Promise","all","matchAll","candidate","candidates","Set","found","find","title","mdn","list","cached","doc","summary","browserCompat","links","sources","encodeURIComponent","obj","shift","documentationAt","offset","documentation","collectColors","validate","enumerate","md","then","showdown","Converter","default","converter","openLinksInNewWindow","setFlavor","makeHtml"],"mappings":"IAwFMA,aACAA,cACAA,cCKcC;;;;;;;ACgCpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA,GAAA,6CAAA;AAGO,SAASC,oBAAoBC,MAAc,EAAU;IAC1D,OAAOA,OAAOC,KAAK,CAAC,YAAYC,UAAU;AAC5C;AAEO,SAASC,iBAAiBC,GAAW,EAAU;;;;;;;;;;;;;;;;;;;;IAoBpD,OACEC,KAAMC,GAAG,CACP,sCAAsCC,IAAI,CAACH,OACvCC,KAAKG,GAAG,CAAC,GAAG,QAAS,AAAA,CAAA,CAACC,OAAOC,EAAE,GAAID,CAAAA,OAAOE,EAAE,GAAG,KAAK,CAAC,AAAD,CAAC,KAAM,QAAQ,MACnE,CAAC,EACL,OAEA,KACDN,qBAAAA,GAAAA,KAAKC,GAAG,CAACP,oBAAoBK,MAAM,OAAO;AAE/C;ACuCO,SAASQ,YAAYC,KAAsB,EAAU;;;;;IAK1D,OAAO,AAAgB,YAAhB,OAAOA,QACV,AAAIJ,OAAO,MAAMI,QAASA,CAAAA,MAAMC,QAAQ,CAAC,QAAQD,AAAmB,OAAnBA,MAAME,KAAK,CAAC,MAAa,KAAK,GAAG,AAAH,KAC/EF,KAAK;AACX;ACvPO,IAAMG,sBAAsB;IACjC;IACA;IACA;IACA;;IAEA;;IAEA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;;;;IAIA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;;;IAGA;;;;IAIA;IACA;CACD,ECrDYC,sBAAsB,OCK7BC,aAAaC,OAAOC,IAAI,CAACC,QAClBC,kBAAkB,AAAIb,OACjC,CAAC,KAAK,EAAES,WAAWK,IAAI,CAAC,KAAK,8DAA8D,CAAC,EAC5F,MAGIC,aAAa,IAAIC,SAAkD;IAAEC,SAAS;AAAK;AAElF,SAASC,WAAWd,KAAa,EAAmC;IACzE,IAAIe,SAASJ,WAAWK,GAAG,CAAChB;IAE5B,IAAI,CAACe,QAAQ;QACX,IAAME,QAAQ,IAAIC,UAAUlB;QAE5BW,WAAWQ,GAAG,CAACnB,OAAQe,SAASE,MAAMG,OAAO,GAAGH,MAAMI,KAAK,KAAK,IAAI;IACrE,CAAA;IAED,OAAON;AACT;ACvBO,SAASO,QAAQtB,KAAa,EAAU;IAC7C,OAAO,AAACA,CAAAA,AAAa,QAAbA,KAAK,CAAC,EAAE,GAAW,OAAO,EAAE,AAAA,IAAIA,MAAMuB,OAAO,CAAC,WAAW;AACnE;ACCA,IAAMC,WAAW,IAAIC,KAAKC,QAAQ,CAAC,MAAM;IAAEC,SAAS,IAAI;AAAC;AAElD,SAASC,mBACdC,CAA0C,EAC1CC,CAA0C,EAC1CC,MAA2B,EACnB;;IAER,IAAMC,gBAAgB,CAACD;IACvB,IAAIF,AAAW,cAAXA,EAAEI,IAAI,IAAkBH,AAAW,YAAXA,EAAEG,IAAI,EAChC,OAAOD,gBAAgB,KAAK,CAAC;IAG/B,IAAIH,AAAW,YAAXA,EAAEI,IAAI,IAAgBH,AAAW,cAAXA,EAAEG,IAAI,EAC9B,OAAOD,gBAAgB,IAAI,EAAE;;IAI/B,IAAI,CAAC,aAAatC,IAAI,CAACmC,EAAE7B,KAAK,KAAK,aAAaN,IAAI,CAACoC,EAAE9B,KAAK,GAC1D,OAAO;IAGT,IAAI,aAAaN,IAAI,CAACmC,EAAE7B,KAAK,KAAK,CAAC,aAAaN,IAAI,CAACoC,EAAE9B,KAAK,GAC1D,OAAO;IAGT,IAAMkC,YAAYL,AAAW,cAAXA,EAAEI,IAAI;;IAExB,IAAIC,WAAW;QACb,IAAMC,YAAYN,EAAEO,WAAW,EAAEC,WAAW,QAAQR,EAAEO,WAAW,CAACnC,QAAQ,CAAC,cACrEqC,YAAYR,EAAEM,WAAW,EAAEC,WAAW,QAAQP,EAAEM,WAAW,CAACnC,QAAQ,CAAC;QAE3E,IAAIkC,aAAa,CAACG,WAChB,OAAO;QAGT,IAAI,CAACH,aAAaG,WAChB,OAAO;QAGT,IAAIH,aAAaG,WAAW;YAC1B,IAAMC,qBACJjD,iBAAiBuC,EAAEO,WAAW,IAAc9C,iBAAiBwC,EAAEM,WAAW;YAE5E,IAAIG,oBACF,OAAOA;QAEV,CAAA;IACF,CAAA;;IAGD,IAAI,CAACR,QAAQ;QACX,IAAMS,WAAWX,EAAE7B,KAAK,CAACuB,OAAO,CAAC,MAAM,IAAIkB,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE,EACrDC,WAAWZ,EAAE9B,KAAK,CAACuB,OAAO,CAAC,MAAM,IAAIkB,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE,EAErDE,YAAYnB,SAASoB,OAAO,CAACC,OAAOL,WAAWK,OAAOH;QAC5D,IAAIC,WACF,OAAOA;;QAIT,IAAId,EAAE7B,KAAK,KAAKwC,YAAYV,EAAE9B,KAAK,KAAK0C,UACtC,OAAO;QAGT,IAAIZ,EAAE9B,KAAK,KAAK0C,YAAYb,EAAE7B,KAAK,KAAKwC,UACtC,OAAO;QAGT,IAAMM,cAAc5D,oBAAoB2C,EAAE7B,KAAK,IAAId,oBAAoB4C,EAAE9B,KAAK;QAC9E,IAAI8C,aACF,OAAOA;IAEV,CAAA;;IAGD,IAAMC,kBAAkBb,YAAY,OAAO,GAAG;IAC9C,IAAIL,EAAE7B,KAAK,CAACgD,QAAQ,CAACD,oBAAoB,CAACjB,EAAE9B,KAAK,CAACgD,QAAQ,CAACD,kBACzD,OAAO;IAGT,IAAI,CAAClB,EAAE7B,KAAK,CAACgD,QAAQ,CAACD,oBAAoBjB,EAAE9B,KAAK,CAACgD,QAAQ,CAACD,kBACzD,OAAO;;IAIT,IAAME,iBAAiBf,YAAY,OAAO,GAAG;IAC7C,IAAIL,EAAE7B,KAAK,CAACgD,QAAQ,CAACC,mBAAmB,CAACnB,EAAE9B,KAAK,CAACgD,QAAQ,CAACC,iBACxD,OAAO;IAGT,IAAI,CAACpB,EAAE7B,KAAK,CAACgD,QAAQ,CAACC,mBAAmBnB,EAAE9B,KAAK,CAACgD,QAAQ,CAACC,iBACxD,OAAO;IAGT,IAAI,CAACf,WAAW;;QAEd,IAAIL,EAAE7B,KAAK,CAACC,QAAQ,CAAC,eAAe,CAAC6B,EAAE9B,KAAK,CAACC,QAAQ,CAAC,aACpD,OAAO;QAGT,IAAI,CAAC4B,EAAE7B,KAAK,CAACC,QAAQ,CAAC,eAAe6B,EAAE9B,KAAK,CAACC,QAAQ,CAAC,aACpD,OAAO;;QAIT,IAAI4B,EAAEZ,KAAK,IAAI,CAACa,EAAEb,KAAK,EACrB,OAAO;QAGT,IAAI,CAACY,EAAEZ,KAAK,IAAIa,EAAEb,KAAK,EACrB,OAAO;IAEV,CAAA;;IAGD,IAAMiC,UAAUpB,EAAEqB,KAAK,GAAGtB,EAAEsB,KAAK;IACjC,IAAID,SACF,OAAOA;;IAIT,IAAIrB,EAAEuB,MAAM,KAAKtB,EAAEsB,MAAM,EAAE;;QAEzB,IAAIvB,EAAE7B,KAAK,CAACqC,UAAU,CAAC,QAAQ,CAACP,EAAE9B,KAAK,CAACqC,UAAU,CAAC,MACjD,OAAO;QAGT,IAAI,CAACR,EAAE7B,KAAK,CAACqC,UAAU,CAAC,QAAQP,EAAE9B,KAAK,CAACqC,UAAU,CAAC,MACjD,OAAO;IAEV,CAAA;IAED,OAAOb,SAASoB,OAAO,CAACC,OAAOhB,EAAE7B,KAAK,GAAG6C,OAAOf,EAAE9B,KAAK;AACzD;AAEA,SAAS6C,OAAOQ,CAA4B,EAAE;IAC5C,OAAO,AAACA,CAAAA,KAAK,EAAC,EAAG9B,OAAO,CAAC,OAAO,CAAC+B,IAAMC,OAAOC,YAAY,CAAC,MAAMF,EAAEG,UAAU,CAAC,OAAO;AACvF;AP/GA,IAAMC,MAAM;AAiBL,SAASC,mBACdC,MAA6C,EAC7CC,UAA+B,EAAE,EACnB;IACd,IAAMC,kBAAkB,IAAIlD,SAA+B;QAAEC,SAAS;QAAM,GAAGgD,QAAQE,KAAK;IAAC,IACvFC,qBAAqB,IAAIpD,SAAgC;QAC7DC,SAAS;QACT,GAAGgD,QAAQE,KAAK;IAClB,IAEME,UAAUC,ADzBX,SACLN,MAA6C,EAC7CC,UAA+B,EAAE,EACZ;QACrB,IAAMM,KAAKC,MACTC,aAAa;YACXC,MAAM,KAAK;YACXC,WAAW,KAAK;;YAEhBC,WAAUC,QAAQ,EAAEzE,KAAK,EAAE;gBACzB,OAAOyE,WAAW,MAAMzE;YAC1B;YACA0E,SAAS;gBACPL,aAAc,AAAiB,cAAjB,OAAOT,SAAuBA,OAAOA,MAAM,GAAGA,MAAM;aACnE;YACDe,OAAO;;gBAEL;oBAACvE;oBAAqB;wBAAE,KAAK;oBAAI;iBAAE;aACpC;YACDwE,YAAY;;gBAEV;aACD;QACH,IACAC,QAAQ,IAAI,IAGRD,aAAaE,QAAQX,GAAGP,MAAM,CAACgB,UAAU,EAAEG,GAAG,CAAChF,cAC/CiF,YAAY,CAACC,YAAsBL,WAAWM,IAAI,CAAC,CAACC,KAAOA,GAAGzF,IAAI,CAACuF,aACnEG,WAA4C,IAAIC,OAChDC,UAA0C,IAAID,OAC9CE,cAAkD,EAAE,EAEpDC,WAAW,IAAI5E,SAAyB;YAAEC,SAAS;YAAM,GAAGgD,QAAQE,KAAK;QAAC,IAE1E0B,MAAM,CACVC,QACA,EACEC,YACA,GAAG3G,YAMJ,GACE;YACH,IAAIA,AAAoB,YAApBA,WAAWiD,IAAI,IAAgB+C,UAAUhG,WAAW4G,IAAI,GAAG;YAE/D,IACEF,OAAOG,GAAG,CAAC7G,WAAW4G,IAAI,KAC1BE,KAAKtB,SAAS,CAACkB,OAAO1E,GAAG,CAAChC,WAAW4G,IAAI,GAAG;gBAAC;gBAAQ;aAAO,MAC1DE,KAAKtB,SAAS,CAACxF,YAAY;gBAAC;gBAAQ;aAAO,GAE7C+G,QAAQC,IAAI,CAAC,CAAC,UAAU,EAAEhH,WAAWiD,IAAI,CAAC,EAAE,EAAE6D,KAAKtB,SAAS,CAACxF,WAAW4G,IAAI,EAAE,CAAC;iBAC1E;gBACL5G,CAAAA,cAAAA,UAAAA,EAAWgB,KAAAA,IAAXhB,CAAAA,YAAWgB,KAAAA,GAAUhB,WAAW4G,IAAI,AAAJA;gBAChC5G,CAAAA,eAAAA,YAAWiH,MAAAA,IAAXjH,CAAAA,aAAWiH,MAAW3E,GAAAA,QAAQtC,WAAWgB,KAAK,CAAA;gBAC9ChB,CAAAA,eAAAA,UAAAA,EAAWoD,WAAXpD,IAAAA,CAAAA,aAAWoD,WAAgB,GAAA,EAAA;gBAE3BsD,OAAOvE,GAAG,CAACnC,WAAW4G,IAAI,EAAE5G;gBAC5BuG,YAAYW,IAAI,CAAClH;gBAEjB,IAAI2G,aAAaA,UAAUtG,MAAM,EAAE;oBACjCkG,YAAYW,IAAI,CAAC;wBACf,GAAIlH,UAAU;wBACd4G,MAAM5G,WAAW4G,IAAI,GAAG;wBACxB5F,OAAOhB,WAAWgB,KAAK,GAAG;wBAC1BiG,QAAQ3E,QAAQtC,WAAWgB,KAAK,GAAG;wBACnCoC,aAAa;oBACf;;oBAEEpD,WAAmB2G,SAAS,GAAGA,UAC9BZ,GAAG,CAAC,CAAC,EAAEoB,SAAAA,EAAUC,MAAAA,EAAOnF,MAAK,EAAEoF,QAAO,EAAEC,WAAc,CAAA;4BACrD,GAAItH,UAAU;4BACdsH;4BACAV,MAAM,CAAC,EAAE5G,WAAW4G,IAAI,CAAC,CAAC,EAAEO,SAAS,CAAC;4BACtCnG,OAAO,CAAC,EAAEhB,WAAWgB,KAAK,CAAC,CAAC,EAAEmG,SAAS,CAAC;4BACxCF,QAAQ3E,QAAQ6E;4BAChB/D,aAAaiE,SAAS;4BACtBD;4BACAnF,OAAOA,SAASH,WAAWG,SAASA,QAAQsF,KAAAA,CAAS;wBACvD,CAAA,GACCN,MAAM,CAAC,CAAChH,aAAe;+BACtB,CAAID,CAAAA,AAAoB,YAApBA,WAAWiD,IAAI,IAAgB+C,UAAUhG,WAAW4G,IAAI,CAAA,MAI5DF,OAAOvE,GAAG,CAAClC,WAAW2G,IAAI,EAAE3G,aAErB,IAAI;oBACb;gBACH,CAAA;YACF,CAAA;QACH,GAEMuH,YAA4B,EAAE,EAE9BvC,UAA+B;YACnC,IAAImC,SAAQ;gBACV,OAAOjC,GAAGiC,KAAK;YACjB;YACA,IAAIhB,YAAW;gBACb,OAAO9E,OAAOmG,WAAW,CACvBC,MAAMC,IAAI,CAACvB,SAASwB,MAAM,IAAI,CAACC,UAAY;wBACzCA,QAAQjB,IAAI,CAAC1F,KAAK,CAAC,GAAG;wBACtB2G,QAAQzE,WAAW,IAAIyE,QAAQjB,IAAI;qBACpC;YAEL;QACF,GAEIkB,YAAY;QAEhB,KAAK,IAAMC,UAAUzG,OAAOC,IAAI,CAAC4D,GAAGiC,KAAK,CAAC,YAAa;YACrD,IAAMR,OAAOmB,SAAS;YACtBtB,IAAIL,UAAU;gBACZnD,MAAM;gBACNmB,QAAQ;gBACRD,OAAO2D;gBACPR,UAAUlB,SAAS4B,IAAI;gBACvBpB;gBACAQ,OAAO;oBAAEa,SAAS;oBAAWC,KAAKH;gBAAO;gBACzC3E,aAAa+E,IAAIhD,GAAGiC,KAAK,CAAC,WAAWW;YACvC;QACF;QAEA,KAAK,IAAM,CAACK,SAASC,SAAS,IAAIlD,GAAGP,MAAM,CAACwB,QAAQ,CAAE;YACpD,IAAMjC,QAAQ2D,aACVR,WAAW,GAETgB,WAAW,AAAoB,cAApB,OAAOD,YAA2BE,wBAAwBF;YAE3E,KAAK,IAAMrH,SAAS8E,QAAQsC,SAAU;gBACpC,IAAMI,YAAYzH,YAAYC,QACxBoD,SAASoE,UAAUC,QAAQ,IAE3BtC,KAAK,AAAIvF,OAAO4H,UAAUpE,MAAM,CAAC7B,OAAO,CAAC,iBAAiB,OAAOiG,UAAUE,KAAK,GAChFN,WAAUO,MAAMxC,KAChByC,QAAQR,SAAQQ,KAAK;gBAEvBA,UAAUC,QACRP,WACFd,UAAUN,IAAI,CAAC,IAAM;oBACnB,IAAM9G,QAAqBkB,OAAOwH,MAAM,CAAC;wBAACvE,OAAOvD;qBAAO,EAAE;wBACxDmD,OAAO;4BAAEnD,OAAO;wBAAE;wBAClB+H,OAAO;4BAAE/H,OAAOuD,OAAOvD;wBAAO;wBAC9BgI,IAAI;4BAAEhI,OAAO;wBAAG;oBAClB;oBAEA,KAAK,IAAMhB,cAAcsI,SAASlI,OAAO6E,SACnC,AAAsB,YAAtB,OAAOjF,aACTyG,IAAIL,UAAU;wBACZnD,MAAM;wBACNmB;wBACAD;wBACAmD,UAAUA;wBACVV,MAAM5G,aAAa;oBACrB,KAEAyG,IAAIL,UAAU;wBACZnD,MAAM;wBACNmB;wBACAD;wBACAmD,UAAUA;wBACVV,MAAM,AAAC5G,CAAAA,WAAW+C,MAAM,IAAI,EAAA,IAAO/C,CAAAA,WAAWiJ,MAAM,IAAI,EAAC,IAAK;wBAC9D7B,OAAOpH,WAAWoH,KAAK;wBACvBhE,aAAapD,WAAWqH,KAAK;wBAC7BV,WAAW3G,WAAW2G,SAAS;oBACjC;gBAGN,KAEAI,QAAQC,IAAI,CACV,CAAC,wCAAwC,EAAEwB,UAAU,wBAAwB,CAAC,IAIlFJ,SAAQc,QAAQ,CAAC,CAAClI,QAAU;oBAC1B,IAAMZ,QAAQ+F,GAAGgD,IAAI,CAACnI;oBAEtB,IAAIZ,OAAO;wBACTA,MAAM4I,EAAE,GAAGhI,MAAME,KAAK,CAACd,KAAK,CAAC,EAAE,CAACC,MAAM;wBAEtC,IAAM+I,OAAOpI,MAAMuB,OAAO,CAAC,OAAO;wBAElC,IAAI+F,UACF,KAAK,IAAMtI,cAAcsI,SAASlI,OAAO6E,SACnC,AAAsB,YAAtB,OAAOjF,aACTyG,IAAIL,UAAU;4BACZnD,MAAM;4BACNmB;4BACAD;4BACAmD,UAAUA;4BACVV,MAAMwC,OAAOpJ,aAAa;4BAC1BoD,aAAa;wBACf,KAEAqD,IAAIL,UAAU;4BACZnD,MAAM;4BACNmB;4BACAD;4BACAmD,UAAUA;4BACVV,MAAM,AAAC5G,CAAAA,WAAW+C,MAAM,IAAIqG,IAAAA,IAASpJ,CAAAA,WAAWiJ,MAAM,IAAI,EAAC,IAAK;4BAChE7B,OAAOpH,WAAWoH,KAAK;4BACvBhE,aAAapD,WAAWqH,KAAK;4BAC7BV,WAAW3G,WAAW2G,SAAS;wBACjC;6BAIA3F,MAAMC,QAAQ,CAAC,SAASD,MAAMgD,QAAQ,CAAC,OACzC+C,QAAQC,IAAI,CACV,CAAC,wCAAwC,EAAEwB,UAAU,MAAM,EAAE1B,KAAKtB,SAAS,CACzExE,OACA,kBAAkB,CAAC,IAGvByF,IAAIL,UAAU;4BACZnD,MAAM;4BACNmB;4BACAD;4BACAmD,UAAUA;4BACVV,MAAM5F,QAAQ;4BACdoC,aAAa,AAAmB,YAAnB,OAAOiF,WAAuBA,WAAW,EAAE;wBAC1D;oBAGL,CAAA;gBACH;YAEJ;QACF;QAEA,KAAK,IAAMgB,eAAelI,oBAAqB;YAC7C,IAAMyF,QAAOyC,YAAYnI,KAAK,CAAC,KAAK;YAC/BkF,SAASS,GAAG,CAACD,UAChBH,IAAIL,UAAU;gBACZnD,MAAM;gBACNmB,QAAQ;gBACRD,OAAO2D;gBACPR,UAAUlB,SAAS4B,IAAI;gBACvBpB,MAAAA;gBACA5F,OAAO4F;gBACPxD,aAAa,CAAC,CAAC,EAAEiG,YAAY,CAAC;YAChC;QAEJ;QAEA,IAAI7B,UAAUnH,MAAM,EAClB,KAAK,IAAMiJ,YAAY9B,UACrB8B;QAIJ,KAAK,IAAMC,QAAQpE,GAAGP,MAAM,CAACe,KAAK,CAAE;YAClC,IAAM,CAACyC,UAASC,UAAS,GAAGvC,QAAQyD,OAE9BpF,SAAQ2D,aACVR,YAAW,GAETgB,YAAW,AAAoB,cAApB,OAAOD,aAA2BE,wBAAwBF;YAE3E,KAAK,IAAMrH,UAAS8E,QAAQsC,UAAU;gBACpC,IAAIpH,WAAUI,qBACZ,QAAQ;gBAGV,IAAMoH,aAAYzH,YAAYC,SACxBoD,UAASoE,WAAUC,QAAQ,IAE3BtC,MAAK,AAAIvF,OAAO4H,WAAUpE,MAAM,CAAC7B,OAAO,CAAC,iBAAiB,OAAOiG,WAAUE,KAAK,GAChFN,WAAUO,MAAMxC,MAChByC,SAAQR,SAAQQ,KAAK;gBAE3B,IAAIA,WAAUC;oBACZ,IAAIP,WAAU;wBACZ,IAAMlI,QAAqBkB,OAAOwH,MAAM,CAAC;4BAACvE,OAAOvD;yBAAO,EAAE;4BACxDmD,OAAO;gCAAEnD,OAAO;4BAAE;4BAClB+H,OAAO;gCAAE/H,OAAOuD,OAAOvD;4BAAO;4BAC9BgI,IAAI;gCAAEhI,OAAO;4BAAG;wBAClB;wBAEA,KAAK,IAAMhB,cAAcsI,UAASlI,OAAO6E,SACnC,AAAsB,YAAtB,OAAOjF,aACTyG,IAAIH,SAAS;4BACXrD,MAAM;4BACNmB,QAAAA;4BACAD,OAAAA;4BACAmD,UAAUA;4BACVV,MAAM5G;wBACR,KAEAyG,IAAIH,SAAS;4BACXrD,MAAM;4BACNmB,QAAAA;4BACAD,OAAAA;4BACAmD,UAAUA;4BACVV,MAAO5G,AAAAA,CAAAA,WAAW+C,MAAM,IAAI,EAAC,IAAM/C,CAAAA,WAAWiJ,MAAM,IAAI;4BACxD7B,OAAOpH,WAAWoH,KAAK;4BACvBhE,aAAapD,WAAWqH,KAAK;4BAC7BpF,OACEjC,WAAWiC,KAAK,IAAIH,WAAW9B,WAAWiC,KAAK,IAAIjC,WAAWiC,KAAK,GAAGsF,KAAAA,CAAS;4BACjFZ,WAAW3G,WAAW2G,SAAS;wBACjC;2BAIJI,QAAQC,IAAI,CAAC,CAAC,qCAAqC,EAAEwB,WAAU,wBAAwB,CAAC;uBAG1FJ,SAAQc,QAAQ,CAAC,CAACtC,OAAS;oBACzB,IAAMxG,QAAQ+F,IAAGgD,IAAI,CAACvC;oBAEtB,IAAIxG,OAAO;wBACTA,MAAM4I,EAAE,GAAGpC,KAAK1F,KAAK,CAACd,KAAK,CAAC,EAAE,CAACC,MAAM;wBACrC,IAAM+I,OAAOxC,KAAKrE,OAAO,CAAC,OAAO;wBAEjC,IAAI+F,WACF,KAAK,IAAMtI,cAAcsI,UAASlI,OAAO6E,SACnC,AAAsB,YAAtB,OAAOjF,aACTyG,IAAIH,SAAS;4BACXrD,MAAM;4BACNmB,QAAAA;4BACAD,OAAAA;4BACAmD,UAAUA;4BACVV,MAAMwC,OAAOpJ;wBACf,KAEAyG,IAAIH,SAAS;4BACXrD,MAAM;4BACNmB,QAAAA;4BACAD,OAAAA;4BACAmD,UAAUA;4BACVV,MAAO5G,AAAAA,CAAAA,WAAW+C,MAAM,IAAIqG,IAAG,IAAMpJ,CAAAA,WAAWiJ,MAAM,IAAI;4BAC1D7B,OAAOpH,WAAWoH,KAAK;4BACvBhE,aAAapD,WAAWqH,KAAK;4BAC7BpF,OACEjC,WAAWiC,KAAK,IAAIH,WAAW9B,WAAWiC,KAAK,IAC3CjC,WAAWiC,KAAK,GAChBsF,KAAAA,CAAS;4BACfZ,WAAW3G,WAAW2G,SAAS;wBACjC;6BAIAC,KAAK3F,QAAQ,CAAC,SAAS2F,KAAK5C,QAAQ,CAAC,OACvC+C,QAAQC,IAAI,CACV,CAAC,qCAAqC,EAAEwB,WAAU,MAAM,EAAE1B,KAAKtB,SAAS,CACtEoB,MACA,kBAAkB,CAAC,IAGvBH,IAAIH,SAAS;4BACXrD,MAAM;4BACNmB,QAAAA;4BACAD,OAAAA;4BACAmD,UAAUA;4BACVV;wBACF;oBAGL,CAAA;gBACH;YAEJ;QACF;eAEAL,YAAYiD,IAAI,CAAC5G,qBAEV;YACLuC;YACAiB;YACAE;YACAC;YACAP;YACAyD,aAAa,CAACC,QAAU;gBACtB,IAAI3H,SAASyE,SAASxE,GAAG,CAAC0H;gBAE1B,IAAI,CAAC3H,QAAQ;oBACXoD,GAAGwE,KAAK;oBAER,IAAMzG,YAAYkD,SAASS,GAAG,CAAC6C,QAE3B9C,OACF1D,aAAawG,MAAM1F,QAAQ,CAAC,QACxB,CAAC,EAAE0F,MAAMxI,KAAK,CAAC,GAAG,IAAI,GAAG,CAAC,GAC1BwI,MAAM1F,QAAQ,CAAC,OACf,CAAC,EAAE0F,MAAM,EAAE,CAAC,GACZxG,aAAawG,MAAM1F,QAAQ,CAAC,QAC5B,CAAC,EAAE0F,MAAMxI,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GACzBwI,MAAM1F,QAAQ,CAAC,OACf,CAAC,EAAE0F,MAAM,CAAC,CAAC,GACXA,KAAK;oBAEX,IAAIxG,WAAW;wBACR0D,KAAK5C,QAAQ,CAAC,QACjB4C,CAAAA,QAAQ,GAAA;wBAGVA,QAAQ;oBACT,CAAA;oBAEDzB,GAAGyB;oBAEH,IAAMrG,MAAMiF,UAAUL,GAAGuB,MAAM,GAEzBkD,SAAS,CAAC,CAAC,EAAEhD,KAAK,EAAE,CAAC,EACrBiD,aAAatJ,IAAIuJ,OAAO,CAACF;oBAE/B,IAAIC,AAAe,OAAfA,YACF9H,SAASxB;yBACJ;wBACL,IAAMwJ,uBAAuBxJ,IAAIuJ,OAAO,CAAC,MAAMD;wBAE/C9H,SAASxB,IAAIW,KAAK,CAChB2I,aAAaD,OAAOvJ,MAAM,EAC1B0J,AAAyB,OAAzBA,uBAA8BA,uBAAuBxJ,IAAIF,MAAM;oBAElE,CAAA;oBAEG6C,aACFnB,CAAAA,SAASA,OAAOQ,OAAO,CAAC,SAAS,GAAA;oBAGnCiE,SAASrE,GAAG,CAACuH,OAAO3H;gBACrB,CAAA;gBAED,OAAOA;YACT;QACF;IACF,ECvZ4C6C,QAAQC,UAC5C,EAAEmF,WAAYtF,IAAG,EAAE,GAAGG;;IAG5BC,gBAAgB3C,GAAG,CAAC,IAAI8C,QAAQsB,WAAW,CAACR,GAAG,CAACkE;IAkBhD,SAASA,aAAahK,UAAsB,EAAc;eACxD,AAAIA,AAAoB,cAApBA,WAAWgD,IAAI,GACV;YACLA,MAAMhD,WAAWgD,IAAI;YACrB2D,MAAM3G,WAAW2G,IAAI;YACrB5F,OAAOf,WAAWe,KAAK;YACvBoC,aAAanD,WAAWmD,WAAW;YACnC8G,QAAQjK,WAAWiK,MAAM;YACzBjI,OAAOhC,WAAWgC,KAAK;QACzB,IAGK;YACLgB,MAAMhD,WAAWgD,IAAI;YACrB2D,MAAM3G,WAAW2G,IAAI;YACrB5F,OAAOf,WAAWe,KAAK;YACvBoC,aAAcnD,AAAAA,CAAAA,cAAAA,UAAAA,EAAWmD,WAAAA,IAAXnD,CAAAA,YAAWmD,WAAgB+G,GAAAA,AAhC7C,SAAkClE,SAAiB,EAAU;gBAC3D,IAAM1F,MAAM0E,QAAQwE,WAAW,CAACxD,YAE1BmE,YAAY7J,IAAI8J,WAAW,CAAC,MAC5BC,UAAU/J,IAAIuJ,OAAO,CAAC;uBAE5B,AAAIM,AAAc,OAAdA,aAAoBE,AAAY,OAAZA,UACf/J,MAGFgK,YAAY,CAAC,GAAG,EAAEhK,IAAIW,KAAK,CAACkJ,YAAY,GAAGE,SAAS,CAAC,CAAC,EAAE;oBAAEE,QAAQ;mBACtE/G,KAAK,CAAC,MACNvC,KAAK,CAAC,GAAG,IACTQ,IAAI,CAAC,IALP;YAMH,EAkBsEzB,WAAW2G,IAAI,CAAA;YACjFsD,QAAQjK,WAAWiK,MAAM;YACzBjI,OAAOhC,WAAWgC,KAAK;QACzB,CATC;IAUH;IAEA,IAAIwI,kBAAoE,IAAI,EACtEC,WAAW,IAAI9I,SAGnB;QACAC,SAAS;QACT,GAAGgD,QAAQE,KAAK;IAClB;IACA,OAAO;QACL,IAAIqC,SAAQ;YACV,OAAOnC,QAAQE,EAAE,CAACiC,KAAK;QACzB;QACA,IAAIxC,UAAS;YACX,OAAOK,QAAQE,EAAE,CAACP,MAAM;QAC1B;;QAEA,MAAM+F,SAAQ5B,KAAK,EAAE,EAAEhG,QAAS,GAAA,EAAI6H,OAAAA,EAAQ,GAAG,EAAE,EAAE;YACjD,IAAM1C,MAAMpB,KAAKtB,SAAS,CAAC;gBAAEuD;gBAAOhG;gBAAQ6H;YAAO,IAC/C7I,SAAS+C,gBAAgB9C,GAAG,CAACkG;YAEjC,IAAI,CAACnG,QAAQ;gBACX,IAAIqC,SAASa,QAAQsB,WAAW,EAC5BsE,YAA6CC,YAAYC,QAAQ,CAACC,OAAO,EAEvEtB,QAAQ3G,SAASgG,OAEjB3I,QAAQ,oCAAoC+I,IAAI,CAACO;gBACvD,IAAItJ,OAAO;oBACT,IAAM,EAAE,GAAG8H,KAAG,EAAE,GAAGf,WAAW,EAAE,CAAA,EAAE,GAAG/G,OAC/BH,aAAagF,QAAQqB,OAAO,CAACtE,GAAG,CAACkG,SAAQjD,QAAQmB,QAAQ,CAACpE,GAAG,CAACkG;oBACpE,IAAIjI,YAAY0G,WAAW;wBACzBvC,SAASnE,YAAY0G;wBACrBoC,QAAQ5B;oBACT,CAAA;gBACF,CAAA;gBAED,IAAIuC,AAAa,QAAbA,KAAK,CAAC,EAAE,EAAU;oBACpBtF,SAASA,OAAO6C,MAAM,CAAC,CAAC,EAAEL,KAAI,EAAE,GAAKA,AAAY,QAAZA,IAAI,CAAC,EAAE;oBAExC7D,SACFA,SAASA,OAAO7B,KAAK,CAAC,KAEtB6H,QAAQA,MAAM7H,KAAK,CAAC;gBAEvB,CAAA;gBAEG0J,QAAQvK,UACV+D,CAAAA,SAASA,OAAO6C,MAAM,CAAC,CAAC,EAAEjG,MAAK,EAAE,GAAK,CAAC4J,OAAO3J,QAAQ,CAACD,OAAAA;gBAGrD+B,UACFqB,CAAAA,SAASA,OACN6C,MAAM,CAAC,CAAC,EAAEhE,OAAMjC,MAAAA,EAAO,GAAKiC,AAAS,cAATA,QAAsBjC,MAAMqC,UAAU,CAACN,SACnEgD,GAAG,CAAC,CAAC9F,aACJA,AAAoB,cAApBA,WAAWgD,IAAI,GACXhD,aACA;wBACE,GAAGA,UAAU;wBACbgH,QAAQ3E,QAAQrC,WAAWe,KAAK,CAACE,KAAK,CAAC6B,OAAO1C,MAAM;wBACpDW,OAAOf,WAAWe,KAAK,CAACE,KAAK,CAAC6B,OAAO1C,MAAM;qBAC5C,CAAA;gBAIX,IAAM,EAAEA,OAAM,EAAE,GAAG0I,MAAMxG,OAAO,CAAC,WAAW;gBAE5C,IAAIlC,AAAW,MAAXA,QAAc;oBACZ0C,UACFqB,CAAAA,SAASA,OAAOoF,IAAI,CAAC,CAAC3G,GAAGC,IAAMF,mBAAmBC,GAAGC,GAAGC,QAAAA;oBAG1D+B,gBAAgB3C,GAAG,CAAC+F,KAAMnG,SAASqC,OAAO2B,GAAG,CAACkE;uBACzC;oBACD5J,SAAS,KACXwK,CAAAA,YAAYC,YAAYC,QAAQ,CAACE,QAAQ;;oBAI3C,IAAMC,SAAS5I,QAAQyG;oBAEvBjE,gBAAgB3C,GAAG,CACjB+F,KACCnG,SAAS+I,YAAY1G,QAAQ8G,QAAQ;wBACpC3J,MAAM;4BAAC;yBAAS;wBAChBsJ;wBACAM,UAAU,CAACtI,GAAGC,IAAMF,mBAAmBC,EAAEuI,IAAI,EAAEtI,EAAEsI,IAAI,EAAErI;oBACzD,GAAGgD,GAAG,CAACkE;gBAEV,CAAA;YACF,CAAA;YAED,OAAOlI;QACT;QACA,MAAMsJ,WAAUC,OAAO,EAAEhE,QAAQ,EAAEiE,QAAQ,EAAE;;;;;;;;;;;;YAc3C,IAAM,EAAEC,kBAAiB,GACvBD,AAAa,WAAbA,WACI,MAAM,MAAO,CAAA,wBACb;gBACEC,iBAAiB,CAACF,SAAiBhE,WAAuC;oBACxE,IAAMmE,QACJjL,KAAKG,GAAG,CACN2K,QAAQjB,WAAW,CAAC,KAAK/C,WACzBgE,QAAQjB,WAAW,CAAC,MAAM/C,WAC1BgE,QAAQjB,WAAW,CAAC,MAAM/C,aACxB,GAEFoE,MAAMJ,QAAQxB,OAAO,CAAC,KAAK2B;2BAEnB,OAARC,OAAYA,CAAAA,MAAMJ,QAAQxB,OAAO,CAAC,MAAM2B,MAAAA,GAChC,OAARC,OAAYA,CAAAA,MAAMJ,QAAQxB,OAAO,CAAC,MAAM2B,MAAAA,GAChC,OAARC,OAAYA,CAAAA,MAAMJ,QAAQjL,MAAM,AAANA,GAEvB;wBAAEoL;wBAAOC;wBAAKJ,SAASA,QAAQpK,KAAK,CAACuK,OAAOC;oBAAK;gBAC1D;aACD,EAEDC,WAAWH,gBAAgBF,SAAShE;YAE1C,IAAI,CAACqE,UAAU,OAAO,IAAI;YAE1B,IAAMC,kBAAkB,CAACD,SAASL,OAAO,IAAI,eAAe5K,IAAI,CAACiL,SAASL,OAAO,GAE3EO,SAASC,MAAMH,SAASL,OAAO,GAAIM,CAAAA,kBAAkB,WAAW,EAAE,AAAA,IAElErC,OAAOsC,MAAM,CAACA,OAAOxL,MAAM,GAAG,EAAE;YAEtC,IAAI,CAACkJ,QACDtE,QAAQe,SAAS,CAACuD,KAAKwC,CAAC,GADjB,OAAO,IAAI;YAGtB,IAAMC,SAASJ,kBAAkBrC,KAAK1G,CAAC,CAAC3B,KAAK,CAAC,GAAG,MAAMqI,KAAK1G,CAAC,EAEzDoJ,UAAU,KAAK,EACbC,QAAkB,EAAE;YAC1B,KAAK,IAAIlL,SAASgL,OAAQ;gBACxB,IAAIhL,AAAS,OAATA,SAAgB,QAAQN,IAAI,CAACM,QAAQ;oBACvCkL,MAAMhF,IAAI,CAAC;oBACX,QAAQ;gBACT,CAAA;gBAEe,OAAZlG,KAAK,CAAC,EAAE,IACVA,CAAAA,QAAQA,MAAME,KAAK,CAAC,EAAA;gBAGtB,IAAIF,MAAMgD,QAAQ,CAAC,MAAM;oBACvBkI,MAAMhF,IAAI,CAAC;oBACX,QAAQ;gBACT,CAAA;gBAED,IAAIlG,AAAY,OAAZA,KAAK,CAAC,EAAE,EAAS;oBACnBA,QAAQA,MAAME,KAAK,CAAC;oBACpB+K,UAAU,CAACA;gBACZ,CAAA;gBAEGjL,MAAMgD,QAAQ,CAAC,QACjBhD,CAAAA,QAAQA,MAAME,KAAK,CAAC,GAAG,GAAC;gBAGtBF,SAASA,AAAS,OAATA,SACXkL,MAAMhF,IAAI,CAAClG;YAEf;YAEA,IAAI+B,SAAS,AAACkJ,CAAAA,UAAU,MAAM,EAAE,AAAA,IAAIC,MAAMhL,KAAK,CAAC,GAAG,IAAI+F,MAAM,CAACkF,SAASzK,IAAI,CAAC;YACxEqB,UAAUkJ,UACZlJ,SAAS,MAAMA,SAAS,MACfA,UACTA,CAAAA,UAAkB;YAGpB,IAAMgG,QAAQ,AAAC6C,CAAAA,kBAAkBrC,KAAKwC,CAAC,CAACxJ,OAAO,CAAC,WAAW,MAAMgH,KAAKwC,CAAAA,AAAAA,EAAG7K,KAAK,CAAC6B,OAAO1C,MAAM;YAE5F,OAAO;gBACLoL,OAAOnE,WAAWyB,MAAM1I,MAAM;gBAC9BqL,KAAKpE;gBACLf,aAAa,MAAM,IAAI,CAACoE,OAAO,CAAC5B,OAAO;oBAAEhG;oBAAQ6H,QAAQrB,KAAK6C,CAAC,CAACrG,GAAG,CAAC,CAACqG,IAAMA,IAAI;gBAAK;YACtF;QACF;;QAEA,MAAMC,kBAAiB3C,KAAK,EAAE,EAAE4C,QAAS,OAA+B,GAAG,EAAE,EAAE;gBA2HzElF;YA1HJ,IAAIpC,mBAAmB6B,GAAG,CAAC6C,QACzB,OAAO6C,QAAQvH,mBAAmBhD,GAAG,CAAC0H,QAAQ4C;YAGhD,IAAM/C,OAAOuC,MAAMpC,MAAM,CAAC,EAAE,IAAI;gBAC9BqC,GAAGrC,MAAM1F,QAAQ,CAAC,OAAO,KAAK0F,KAAK;gBACnC0C,GAAG1C,MAAM1F,QAAQ,CAAC,OAAO;oBAAC0F;iBAAM,GAAG,EAAE;YACvC,GAEMnJ,MAAMgK,YAAYtF,QAAQwE,WAAW,CAACC,QAAQ;gBAAE8C,eAAe,IAAI;gBAAEhC,QAAQ;YAAK;;;;;;YAQlFiC,WAAW,MAAOhC,CAAAA,mBAAAA,CAAAA,kBAAqB,AAAA,CAAA,UAAY;gBACvD,IAAI;oBACF,IAAMiC,WAAW,MAAMC,MAAM,CAAC,EAAE3C,UAAU,wBAAwB,CAAC;oBAEnE,IAAI0C,SAASE,EAAE,IAAIF,AAAoB,QAApBA,SAASG,MAAM,EAAU;wBAC1C,IAAM1I,QAA0C,MAAMuI,SAASI,IAAI;wBAEnE,OAAO3I,MAAM8C,MAAM,CAAC,CAAC,EAAE8F,MAAK,GAAKA,IAAI9L,QAAQ,CAAC;oBAC/C,CAAA;gBACH,EAAE,OAAO+L,OAAO;oBACdjG,QAAQC,IAAI,CAAC;gBACf;gBAEA,OAAO,EAAE;YACX,CAAA,GAAA,CAAG,GAEGiG,kBACJR,SAASpM,MAAM,IACd,MAAM6M,QAAQC,GAAG,CAChBzF,MAAMC,IAAI,CACRpH,IAAI6M,QAAQ,CACV,mFAEF,CAAChN,QAAU;gBACT,IAAMiN,YAAYjN,KAAK,CAAC,EAAE;gBAC1B,IAAIiN,aAAa,CAACA,UAAUhK,UAAU,CAAC,MAAM;;;;;;oBAM3C,IAAMiK,aAAa,IAAIC,IAAI;wBACzBF;;wBAEAA,UAAU9K,OAAO,CAAC,YAAY;;wBAE9B8K,UAAU9K,OAAO,CAAC,YAAY;;;wBAG9B8K,UAAU9K,OAAO,CAAC,sBAAsB;qBACzC;oBAED,KAAK,IAAM8K,cAAaC,WAAY;wBAClC,IAAME,QAAQf,SAASgB,IAAI,CAAC,CAAC,EAAEC,MAAAA,EAAO,GAAKA,UAAUL;wBACrD,IAAIG,OACF,OAAO;4BAAEpN;4BAAOuN,KAAKH;wBAAM;oBAE/B;gBACD,CAAA;YACH,GAECvG,MAAM,CACL,CAAIlF,QAAWoC,OAAeyJ,OAC5B7L,UAAU6L,KAAK9D,OAAO,CAAC/H,YAAYoC,OAEtC4B,GAAG,CAAC,OAAOhE,SAAW;gBACrB,IAAI8L,SAASnD,SAAS1I,GAAG,CAACD,OAAO4L,GAAG,CAACZ,GAAG;gBAEnCc,UACHnD,SAASvI,GAAG,CACVJ,OAAO4L,GAAG,CAACZ,GAAG,EACbc,SAAS,AAAC,CAAA,UAAY;oBACrB,IAAI;wBACF,IAAMnB,WAAW,MAAMC,MAAM,CAAC,EAAE3C,UAAU,EAAEjI,OAAO4L,GAAG,CAACZ,GAAG,CAAC,WAAW,CAAC;;;;;wBAMvE,IAAIL,SAASE,EAAE,IAAIF,AAAoB,QAApBA,SAASG,MAAM,EAAU;4BAC1C,IAAM1I,QAEF,MAAMuI,SAASI,IAAI;4BAEvB,OAAO;gCACLY,OAAOvJ,MAAM2J,GAAG,CAACJ,KAAK;gCACtBK,SAAS5J,MAAM2J,GAAG,CAACC,OAAO;gCAC1BC,eAAe7J,MAAM2J,GAAG,CAACE,aAAa;4BACxC;wBACD,CAAA;oBACH,EAAE,OAAOhB,OAAO;wBACdjG,QAAQC,IAAI,CAAC;oBACf;oBAEA,OAAO;wBAAE0G,OAAO3L,OAAO4L,GAAG,CAACD,KAAK;oBAAC;gBACnC,CAAA;gBAIJ,IAAM,EAAEA,MAAK,EAAEM,cAAa,EAAE,GAAG,MAAMH,QACjCI,QAAQ;oBACZ,CAAC,gBAAgB,EAAEvJ,IAAI,EAAE3C,OAAO4L,GAAG,CAACZ,GAAG,CAAC,CAAC,CAAC;oBAC1CiB,gBAAgB,EAAE,IAChB,CAAC,0CAA0C,EAAEA,aAAa,CAAC,EAAE,CAACzL,OAAO,CACnE,OACA,KACA,CAAC,CAAC;iBACP,CACE0E,MAAM,CAACkF,SACPzK,IAAI,CAAC;gBAER,OAAO,CAAC,IAAI,EAAEgM,MAAM,IAAI,EAAEO,MAAM,CAAC,CAAC;YACpC,KAIAC,UAAoB,EAAE;;YAG5B,KAAK,IAAMlO,cAAc;mBACpBuJ,KAAK6C,CAAC,CAACrG,GAAG,CAAC,CAACqG,IAAMnH,QAAQmB,QAAQ,CAACpE,GAAG,CAACoK,IAAI;gBAC9CnH,QAAQqB,OAAO,CAACtE,GAAG,CAACuH,KAAKwC,CAAC;aAC3B,CAAE;gBACD,IAAI,CAAC/L,YAAY,QAAQ;gBAEzB,IAAMiO;gBAEJjO,WAAWoE,MAAM,CAACf,UAAU,CAAC,QAAQrD,WAAWoE,MAAM,CAACJ,QAAQ,CAAC,OAC5D,4DAC8DmK,mBAC1DnO,WAAWoE,MAAM,CAAClD,KAAK,CAAC,GAAG,mBACbiN,mBAAmBnO,WAAWgB,KAAK,yCACfmN,mBAAmBnO,WAAWoE,MAAM,IACzE,GACD,EAAE;gBAER8J,QAAQhH,IAAI,CACV,CAAC,IAAI,EAAElH,WAAW4G,IAAI,CAAC,OAAO,EAAE5G,WAAWoE,MAAM,CAAC,EAAE,EAAE6J,SAAS,OAAOA,QAAQ,IAAI,CAAC;gBAGrF,IAAIjO,WAAWoH,KAAK,EAAE;oBACpB,IAAM,EAAEa,QAAO,EAAEC,MAAK,GAAGlI,WAAWoH,KAAK,EAEnC7F,OACJvB,WAAWiC,KAAK,IAAI,qBAAqBvB,IAAI,CAACuH,WAC1CC,IAAI3F,OAAO,CAAC,MAAM,KAAKkB,KAAK,CAAC,OAC7B;wBAACyE;qBAAI;oBAGPkG,MAAY,AAAChH,CAAAA,SAAAA,CAAAA,QAAU,CAAA,CAAA,CAAC,CAAGa,CAAAA,QAAQ,GAAG;oBAE1C,MAAO1G,KAAKlB,MAAM;oBAEhB+N,MAAMA,GAAG,CAAC7M,KAAK8M,KAAK,GAAa,GAAG9M,KAAKlB,MAAM,GAC3C,CAAC,IACD4E,QAAQE,EAAE,CAACiC,KAAK,CAACa,SAASC,QAAQ,GAAG;gBAE5C,CAAA;YACH;YAEA,IAAMnG,SACJ;gBACExB,OAAO,aAAaA,MAAM;gBAC1B0M,mBACEA,gBAAgB5M,MAAM,IACtB,CAAC,oBAAoB,EAAE4M,gBAAgBvL,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACzD0F,SAAS,2BAA2BN,KAAKtB,SAAS,CAAC4B,OAAO,IAAI,EAAE,KAAK;gBACrE8G,QAAQ7N,MAAM,IAAI,CAAC,cAAc,EAAE6N,QAAQxM,IAAI,CAAC,QAAQ,EAAE,CAAC;aAC5D,CACEuF,MAAM,CAACkF,SACPzK,IAAI,CAAC,WAAW,IAAI;mBAEzBsD,mBAAmB7C,GAAG,CAACuH,OAAO3H,SAEvBwK,QAAQxK,QAAQuK;QACzB;QACA,MAAMgC,iBAAgBhD,OAAO,EAAEiD,MAAM,EAAEhD,QAAQ,EAAE;YAC/C,IAAIxJ,SAAiC,IAAI;YAEzC,IAAIwJ,AAAa,WAAbA,UAAqB;gBACvB,IAAM,EAAE+C,gBAAe,EAAE,GAAG,MAAM,MAAA,CAAO;gBAEzCvM,SAASuM,gBAAgBhD,SAASiD,QAAQtJ;YAC3C,CAAA;YAED,IAAIlD,QAAQ;gBACV,IAAMyM,gBAAgB,MAAM,IAAI,CAACnC,gBAAgB,CAACtK,OAAOf,KAAK;gBAE9D,IAAIwN,eACF,OAAO;oBAAE,GAAGzM,MAAM;oBAAEf,OAAOwN;gBAAc;YAE5C,CAAA;YAED,OAAO,IAAI;QACb;QACA,MAAMC,eAAcnD,OAAO,EAAEC,QAAQ,EAAE;YACrC,IAAIA,AAAa,WAAbA,UAAqB;gBACvB,IAAM,EAAEkD,cAAa,EAAE,GAAG,MAAM,MAAA,CAAO;gBAEvC,OAAOA,cAAcnD,SAASrG;YAC/B,CAAA;YAED,OAAO,EAAE;QACX;QACA,MAAMyJ,UAASpD,OAAO,EAAEC,QAAQ,EAAE;YAChC,IAAIA,AAAa,WAAbA,UAAqB;gBACvB,IAAM,EAAEmD,SAAQ,EAAE,GAAG,MAAM,MAAA,CAAO;gBAElC,OAAOA,SAASpD,SAASrG;YAC1B,CAAA;YAED,OAAO,EAAE;QACX;QACA,CAAC0J,aAAY;YACX,KAAK,IAAM3O,cAAciF,QAAQsB,WAAW,CAC1C,MAAM0D,aAAajK;QAEvB;IACF;AACF;AAEA,SAASuM,QACPqC,EAA6B,EAC7BtC,MAA0C,EACT;WACjC,AAAIsC,MAAMtC,AAAW,WAAXA,SACD,OAAO,YAAYuC,IAAI,CAAC,CAACC,WAAa;QAC3C,IAAMC,YAAYD,SAASC,SAAS,IAAID,SAASE,OAAO,CAACD,SAAS,EAC5DE,YAAY,IAAIF,UAAU;YAAEG,sBAAsB,IAAI;QAAC;eAC7DD,UAAUE,SAAS,CAAC,WACbF,UAAUG,QAAQ,CAACR;IAC5B,KAGKA,MAAM,IAAI,AAFhB;AAGH;"}